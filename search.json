[{"path":"https://marberts/github.io/piar/LICENSE.html","id":"mit-license","dir":"","previous_headings":"","what":"MIT License","title":"NA","text":"Copyright (c) 2022 Steve Martin Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://marberts/github.io/piar/articles/piar.html","id":"matched-sample-index","dir":"Articles","previous_headings":"","what":"Matched-sample index","title":"Making price indexes","text":"first example covers calculating matched-sample index, fixed set businesses provide prices collection products time. products reported businesses can change time, set businesses fixed duration sample. businesses weight established sample drawn, represents particular segment economy. usual approach calculating matched-sample index starts computing elemental index business equally-weighted geometric mean price relatives (.e., Jevons index). , index values different segments economy calculated arithmetic mean elemental indexes, using businesses-level weights (either Young Lowe index, depending weights constructed). ms_prices dataset price data five businesses four quarters, ms_weights dataset weight data. Note data fairly realistic patterns missing data. elemental_index() function makes, well, elemental indexes, using information price relatives, elemental aggregates (businesses), time periods (quarters). default makes Jevons index, bilateral generalized-mean index possible. wrinkle price data levels, relatives, price_relative() function can make necessary conversion. (Homogeneous elemental aggregates often leads unit-value elemental indexes based price relatives. cases can dealt first aggregating prices elemental aggregate, aggregate(price ~ period + product, ms_prices, mean), point time arithmetic mean, forming price relatives feed elemental_index().) functions R, missing values contagious default piar. Setting na.rm = TRUE elemental_index() means missing price relatives ignored, equivalent imputing missing relatives value elemental index respective businesses (.e., parental overall mean imputation). types imputation possible, topic subsequent example. elemental_index() function returns special index object, number methods working objects. Probably useful methods allows resulting elemental indexes extracted like matrix, even though ’s matrix. (Note indexes four businesses, five, fifth business never reports prices; elemental index can made business small change call elemental_index().) elemental indexes way, ’s time make price-index aggregation structure maps business position aggregation hierarchy. hiccup unpacking digit-wise classification businesses defines hierarchy. ’s job expand_classification() function. now simple aggregate elemental indexes according aggregation structure aggregate() function. elemental indexes, missing values ignored setting na.rm = TRUE, equivalent parentally imputing missing values. Note , unlike elemental indexes, missing values filled ensure index can chained time. Although simple, example covers core functionality piar. remaining examples vignette build one adding complexities often arise practice.","code":"library(piar)  head(ms_prices) #>   period business product price #> 1 202001       B1       1  1.14 #> 2 202001       B1       2    NA #> 3 202001       B1       3  6.09 #> 4 202001       B2       4  6.23 #> 5 202001       B2       5  8.61 #> 6 202001       B2       6  6.40  ms_weights #>   business classification weight #> 1       B1             11    553 #> 2       B2             11    646 #> 3       B3             11    312 #> 4       B4             12    622 #> 5       B5             12    330 relative <- with(ms_prices, price_relative(price, period, product))  (ms_epr <- with(ms_prices,                 elemental_index(relative, period, business, na.rm = TRUE))) #> Period-over-period price index for 4 levels over 4 time periods  #>    202001    202002    202003   202004 #> B1      1 0.8949097 0.3342939      NaN #> B2      1       NaN       NaN 2.770456 #> B3      1 2.0200036 1.6353355 0.537996 #> B4    NaN       NaN       NaN 4.576286 ms_epr[, \"202004\"] #> Period-over-period price index for 4 levels over 1 time periods  #>      202004 #> B1      NaN #> B2 2.770456 #> B3 0.537996 #> B4 4.576286 ms_epr[\"B1\", ] #> Period-over-period price index for 1 levels over 4 time periods  #>    202001    202002    202003 202004 #> B1      1 0.8949097 0.3342939    NaN hierarchy <- with(ms_weights,                    c(expand_classification(classification), list(business)))  pias <- aggregation_structure(hierarchy, ms_weights$weight) (ms_index <- aggregate(ms_epr, pias, na.rm = TRUE)) #> Aggregate period-over-period price index for 8 levels over 4 time periods  #>    202001    202002    202003   202004 #> 1       1 1.3007239 1.0630743 2.734761 #> 11      1 1.3007239 1.0630743 1.574515 #> 12      1 1.3007239 1.0630743 4.576286 #> B1      1 0.8949097 0.3342939 1.574515 #> B2      1 1.3007239 1.0630743 2.770456 #> B3      1 2.0200036 1.6353355 0.537996 #> B4      1 1.3007239 1.0630743 4.576286 #> B5      1 1.3007239 1.0630743 4.576286"},{"path":"https://marberts/github.io/piar/articles/piar.html","id":"chaining","dir":"Articles","previous_headings":"","what":"Chaining","title":"Making price indexes","text":"elemental_index() function makes period--period elemental indexes default, can aggregated make period--period index. Chaining index process taking cumulative product period--period indexes make time series compares prices fixed base period. chain() function can used chain values index object. gives almost result directly manipulating index matrix, except former returns index object (matrix). Chained indexes often need rebased, can done rebase() function. example, rebasing index 202004 base period just requires dividing chained index slice 202004. cases base period average several periods; setting base period second half 2020 just requires dividing row-wise mean.","code":"(ms_index_chained <- chain(ms_index)) #> Aggregate fixed-base price index for 8 levels over 4 time periods  #>    202001    202002    202003    202004 #> 1       1 1.3007239 1.3827662 3.7815355 #> 11      1 1.3007239 1.3827662 2.1771866 #> 12      1 1.3007239 1.3827662 6.3279338 #> B1      1 0.8949097 0.2991629 0.4710366 #> B2      1 1.3007239 1.3827662 3.8308934 #> B3      1 2.0200036 3.3033836 1.7772072 #> B4      1 1.3007239 1.3827662 6.3279338 #> B5      1 1.3007239 1.3827662 6.3279338 t(apply(as.matrix(ms_index), 1, cumprod)) #>    202001    202002    202003    202004 #> 1       1 1.3007239 1.3827662 3.7815355 #> 11      1 1.3007239 1.3827662 2.1771866 #> 12      1 1.3007239 1.3827662 6.3279338 #> B1      1 0.8949097 0.2991629 0.4710366 #> B2      1 1.3007239 1.3827662 3.8308934 #> B3      1 2.0200036 3.3033836 1.7772072 #> B4      1 1.3007239 1.3827662 6.3279338 #> B5      1 1.3007239 1.3827662 6.3279338 rebase(ms_index_chained, ms_index_chained[, \"202004\"]) #> Aggregate fixed-base price index for 8 levels over 4 time periods  #>       202001    202002    202003 202004 #> 1  0.2644428 0.3439671 0.3656626      1 #> 11 0.4593084 0.5974334 0.6351161      1 #> 12 0.1580295 0.2055527 0.2185178      1 #> B1 2.1229774 1.8998731 0.6351161      1 #> B2 0.2610357 0.3395354 0.3609514      1 #> B3 0.5626806 1.1366169 1.8587499      1 #> B4 0.1580295 0.2055527 0.2185178      1 #> B5 0.1580295 0.2055527 0.2185178      1 rebase(ms_index_chained,        rowMeans(as.matrix(ms_index_chained)[, c(\"202003\", \"202004\")])) #> Aggregate fixed-base price index for 8 levels over 4 time periods  #>       202001    202002    202003    202004 #> 1  0.3872740 0.5037366 0.5355095 1.4644905 #> 11 0.5618052 0.7307535 0.7768452 1.2231548 #> 12 0.2593798 0.3373815 0.3586616 1.6413384 #> B1 2.5967299 2.3238388 0.7768452 1.2231548 #> B2 0.3836077 0.4989677 0.5304398 1.4695602 #> B3 0.3936550 0.7951845 1.3003935 0.6996065 #> B4 0.2593798 0.3373815 0.3586616 1.6413384 #> B5 0.2593798 0.3373815 0.3586616 1.6413384"},{"path":"https://marberts/github.io/piar/articles/piar.html","id":"multi-dimensional-aggregation-structures","dir":"Articles","previous_headings":"","what":"Multi-dimensional aggregation structures","title":"Making price indexes","text":"Price indexes often aggregated multiple dimensions. Matched sample indexes use sequential Poisson sampling good example, usually take-take-strata addition , say, industry classification. easiest way deal multiple digit-wise classifications turn one classification. example “stratum” dimension comes “classification” dimension purposes parental imputation. classification can expanded expand_classification() function , just extra instruction say last “digit” classification two characters wide, one. elemental indexes can now aggregated according new aggregation structure.","code":"(ms_weights <- transform(ms_weights, stratum = c(\"TS\", \"TA\", \"TS\", \"TS\", \"TS\"))) #>   business classification weight stratum #> 1       B1             11    553      TS #> 2       B2             11    646      TA #> 3       B3             11    312      TS #> 4       B4             12    622      TS #> 5       B5             12    330      TS (classification_sps <- with(ms_weights, paste0(classification, stratum))) #> [1] \"11TS\" \"11TA\" \"11TS\" \"12TS\" \"12TS\" (classification_sps <- expand_classification(classification_sps,                                              width = c(1, 1, 2))) #> [[1]] #> [1] \"1\" \"1\" \"1\" \"1\" \"1\" #>  #> [[2]] #> [1] \"11\" \"11\" \"11\" \"12\" \"12\" #>  #> [[3]] #> [1] \"11TS\" \"11TA\" \"11TS\" \"12TS\" \"12TS\" pias_sps <- with(   ms_weights,    aggregation_structure(c(classification_sps, list(business)), weight) ) aggregate(ms_epr, pias_sps, na.rm = TRUE) #> Aggregate period-over-period price index for 11 levels over 4 time periods  #>      202001    202002    202003   202004 #> 1         1 1.3007239 1.0630743 2.684412 #> 11        1 1.3007239 1.0630743 1.492443 #> 12        1 1.3007239 1.0630743 4.576286 #> 11TS      1 1.3007239 1.0630743 0.537996 #> 11TA      1 1.3007239 1.0630743 2.770456 #> 12TS      1 1.3007239 1.0630743 4.576286 #> B1        1 0.8949097 0.3342939 0.537996 #> B2        1 1.3007239 1.0630743 2.770456 #> B3        1 2.0200036 1.6353355 0.537996 #> B4        1 1.3007239 1.0630743 4.576286 #> B5        1 1.3007239 1.0630743 4.576286"},{"path":"https://marberts/github.io/piar/articles/piar.html","id":"computing-the-shadow-of-an-index","dir":"Articles","previous_headings":"","what":"Computing the shadow of an index","title":"Making price indexes","text":"’s often useful determine higher-level index values missing, subsequently get imputed aggregation (.e., compute shadow index). simple ’s elemental index elemental aggregate aggregation structure. idea simply aggregate indicator missingness get matrix gives share missing elemental indexes higher-level index. value 1 means non-missing elemental indexes, value level index imputed parent aggregation structure. value 1 zero means elemental indexes missing, index value level based non-missing elemental indexes. value zero means ’s imputation level index.","code":"ms_epr2 <- with(   ms_prices,   elemental_index(relative, period, factor(business, ms_weights$business),                   na.rm = TRUE) ) pias_matrix <- as.matrix(pias) > 0  pias_matrix %*% is.na(as.matrix(ms_epr2)) / rowSums(pias_matrix) #>    202001    202002    202003    202004 #> 1     0.4 0.6000000 0.6000000 0.4000000 #> 11    0.0 0.3333333 0.3333333 0.3333333 #> 12    1.0 1.0000000 1.0000000 0.5000000"},{"path":"https://marberts/github.io/piar/articles/piar.html","id":"non-parental-imputation-during-aggregation","dir":"Articles","previous_headings":"","what":"Non-parental imputation during aggregation","title":"Making price indexes","text":"Parental imputation usual way impute missing index values aggregation, simple aggregate(). cases, however, business-level index may get imputed value , say, another business, rather entire group businesses. simplest way sort imputation alter elemental indexes prior aggregation. also possible augment aggregation structure imputation layer, complex. Suppose missing index values business B2 imputed 1, rather value group 11. replacement can done index matrix. index can now aggregated usual.","code":"ms_epr2 <- ms_epr ms_epr2[\"B2\", 2:3] <- 1 ms_epr2 #> Period-over-period price index for 4 levels over 4 time periods  #>    202001    202002    202003   202004 #> B1      1 0.8949097 0.3342939      NaN #> B2      1 1.0000000 1.0000000 2.770456 #> B3      1 2.0200036 1.6353355 0.537996 #> B4    NaN       NaN       NaN 4.576286 aggregate(ms_epr2, pias, na.rm = TRUE) #> Aggregate period-over-period price index for 8 levels over 4 time periods  #>    202001    202002    202003   202004 #> 1       1 1.1721550 1.0400686 2.626560 #> 11      1 1.1721550 1.0400686 1.398142 #> 12      1 1.1721550 1.0400686 4.576286 #> B1      1 0.8949097 0.3342939 1.398142 #> B2      1 1.0000000 1.0000000 2.770456 #> B3      1 2.0200036 1.6353355 0.537996 #> B4      1 1.1721550 1.0400686 4.576286 #> B5      1 1.1721550 1.0400686 4.576286"},{"path":"https://marberts/github.io/piar/articles/piar.html","id":"alternate-index-number-formulas","dir":"Articles","previous_headings":"","what":"Alternate index-number formulas","title":"Making price indexes","text":"default, elemental_index() function calculates Jevons index. Although standard index-number formula making elemental indexes, many types index-numbers possible. Carli index (equally-weighted arithmetic mean price relatives) main competitor Jevons, requires specifying order index r calling elemental_index(). order 1 corresponds arithmetic mean. Coggeshall index (equally-weighted harmonic mean price relatives) another competitor Jevons, seldom used practice. Despite exotic, just easy make specifying order r -1. type mean used aggregate elemental indexes can controlled way call aggregate(). default makes arithmetic index, type generalized-mean index possible. Many superlative indexes can made supplying unequal (usually) time-varying weights making elemental indexes. weights often come information quantities. Tornqvist index popular superlative index-number formula, using average period--period value shares weights geometric mean. tricky part making weights data prices quantities. elemental_index() makes geometric index default, needed make Tornqvist index provide weights.","code":"with(ms_prices,       elemental_index(relative, period, business, na.rm = TRUE, r = 1)) #> Period-over-period price index for 4 levels over 4 time periods  #>    202001     202002    202003   202004 #> B1      1  0.8949097 0.3342939      NaN #> B2      1        NaN       NaN 5.155942 #> B3      1 23.7480455 2.4900997 0.607197 #> B4    NaN        NaN       NaN 9.368610 with(ms_prices,      elemental_index(relative, period, business, na.rm = TRUE, r = -1)) #> Period-over-period price index for 4 levels over 4 time periods  #>    202001    202002    202003    202004 #> B1      1 0.8949097 0.3342939       NaN #> B2      1       NaN       NaN 1.7205750 #> B3      1 0.6591433 0.8185743 0.4746769 #> B4    NaN       NaN       NaN 2.2353790 ms_prices2 <- transform(ms_prices, quantity = 10 - price) library(gpindex)  tw <- grouped(index_weights(\"Tornqvist\"))  ms_prices2[c(\"back_price\", \"back_quantity\")] <-    ms_prices2[back_period(ms_prices2$period, ms_prices2$product),              c(\"price\", \"quantity\")]  ms_prices2 <- na.omit(ms_prices2) # can't have NAs for Tornqvist weights  ms_prices2$weight <- with(   ms_prices2,   tw(price, back_price, quantity, back_quantity,      group = interaction(period, business)) ) with(ms_prices2, elemental_index(price / back_price, period, business, weight)) #> Period-over-period price index for 4 levels over 4 time periods  #>    202001    202002    202003   202004 #> B1      1 0.8949097 0.3342939      NaN #> B2      1       NaN       NaN 2.165152 #> B3      1 0.9520982 1.5913929 0.542372 #> B4    NaN       NaN       NaN 5.904237"},{"path":"https://marberts/github.io/piar/articles/piar.html","id":"percent-change-contributions","dir":"Articles","previous_headings":"","what":"Percent-change contributions","title":"Making price indexes","text":"’s often convenient decompose index (additive) contribution price relative, also known percent-change contributions. can done work flow previous examples, specifying contrib = TRUE calling elemental_index(). index values, percent-change contributions given level index can extracted matrix. Aggregating elemental indexes automatically aggregates percent-change contributions, extra steps needed elemental indexes made.","code":"ms_epr <- with(   ms_prices,   elemental_index(relative, period, business, contrib = TRUE, na.rm = TRUE) ) contrib(ms_epr) #>   202001     202002     202003 202004 #> 1      0  0.0000000  0.0000000      0 #> 2     NA         NA -0.6657061      0 #> 3      0 -0.1050903         NA     NA"},{"path":"https://marberts/github.io/piar/articles/piar.html","id":"updating-a-basket","dir":"Articles","previous_headings":"","what":"Updating a basket","title":"Making price indexes","text":"functions piar designed work within “basket”, fancy way saying within given aggregation structure. time, however, aggregation structures change weights used aggregate index get updated, new samples businesses drawn. general approach keep time series going “chain” index across baskets. easier see chain index time simple example just splits ms_prices data two. index first basket can calculate usual. Nothing special needs done make elemental indexes new basket, ’s easier remove index values 1 quarter 3 2020. Aggregating elemental indexes, however, requires aggregation structure. results first example can reproduced simply “price updating” original weights, building aggregation structure usual. produces two sets period--period indexes can stacked together chained.","code":"ms_prices1 <- subset(ms_prices, period <= \"202003\") ms_prices2 <- subset(ms_prices, period >= \"202003\") ms_epr1 <- with(   ms_prices1,    elemental_index(price_relative(price, period, product), period, business,                   na.rm = TRUE) )  (ms_index1 <- aggregate(ms_epr1, pias, na.rm = TRUE)) #> Aggregate period-over-period price index for 8 levels over 3 time periods  #>    202001    202002    202003 #> 1       1 1.3007239 1.0630743 #> 11      1 1.3007239 1.0630743 #> 12      1 1.3007239 1.0630743 #> B1      1 0.8949097 0.3342939 #> B2      1 1.3007239 1.0630743 #> B3      1 2.0200036 1.6353355 #> B4      1 1.3007239 1.0630743 #> B5      1 1.3007239 1.0630743 ms_epr2 <- with(   subset(transform(ms_prices2, rel = price_relative(price, period, product)),          period > \"202003\"),   elemental_index(rel, period, business, na.rm = TRUE) ) (ms_index2 <- aggregate(ms_epr2, update(pias, ms_index1), na.rm = TRUE)) #> Aggregate period-over-period price index for 8 levels over 1 time periods  #>      202004 #> 1  2.734761 #> 11 1.574515 #> 12 4.576286 #> B1 1.574515 #> B2 2.770456 #> B3 0.537996 #> B4 4.576286 #> B5 4.576286 chain(stack(ms_index1, ms_index2)) #> Aggregate fixed-base price index for 8 levels over 4 time periods  #>    202001    202002    202003    202004 #> 1       1 1.3007239 1.3827662 3.7815355 #> 11      1 1.3007239 1.3827662 2.1771866 #> 12      1 1.3007239 1.3827662 6.3279338 #> B1      1 0.8949097 0.2991629 0.4710366 #> B2      1 1.3007239 1.3827662 3.8308934 #> B3      1 2.0200036 3.3033836 1.7772072 #> B4      1 1.3007239 1.3827662 6.3279338 #> B5      1 1.3007239 1.3827662 6.3279338"},{"path":"https://marberts/github.io/piar/articles/piar.html","id":"carry-forward-imputation","dir":"Articles","previous_headings":"","what":"Carry-forward imputation","title":"Making price indexes","text":"previous examples used parental imputation impute missing price relatives calculating elemental indexes, impute missing elemental indexes aggregation. Another common imputation strategy making elemental indexes carry forward previous price impute missing prices, parentally impute missing elemental indexes aggregation. elemental_index() function accepts price relatives input, types imputations can done prior passing price relatives function. Aggregation follows steps previous examples, missing values set ignored order parentally impute missing elemental indexes.","code":"(ms_epr2 <- with(   ms_prices,    elemental_index(     price_relative(carry_forward(price, period, product),period, product),     period, business, na.rm = TRUE   ) )) #> Period-over-period price index for 4 levels over 4 time periods  #>    202001    202002    202003   202004 #> B1      1 0.8949097 0.5781816 1.000000 #> B2      1 1.0000000 0.1777227 2.770456 #> B3      1 2.0200036 1.6353355 0.537996 #> B4    NaN       NaN       NaN 4.576286 (ms_index <- aggregate(ms_epr2, pias, na.rm = TRUE)) #> Aggregate period-over-period price index for 8 levels over 4 time periods  #>    202001    202002    202003    202004 #> 1       1 1.1721550 0.8082981 2.2653614 #> 11      1 1.1721550 0.8082981 0.8093718 #> 12      1 1.1721550 0.8082981 4.5762862 #> B1      1 0.8949097 0.5781816 1.0000000 #> B2      1 1.0000000 0.1777227 2.7704563 #> B3      1 2.0200036 1.6353355 0.5379960 #> B4      1 1.1721550 0.8082981 4.5762862 #> B5      1 1.1721550 0.8082981 4.5762862"},{"path":"https://marberts/github.io/piar/articles/piar.html","id":"calculating-an-index-from-multiple-sources","dir":"Articles","previous_headings":"","what":"Calculating an index from multiple sources","title":"Making price indexes","text":"examples far built index single source price data. many cases elemental indexes built multiple sources data, either single source data necessary coverage, different index-number formulas employed different elemental aggregates. straightforward merge index objects together, provided ’re time periods. keep example simple, suppose ms_prices split two. Elemental indexes can made groups separately usual recipe. Note data business B4 first two periods, time periods need made explicit. elemental indexes made, can merged together aggregated. slightly complex case input data already price index. example, suppose index values businesses B4 B5 come outside process, taken inputs. required pass pre-existing indexes as_index() cast correct form. won’t affect values, allow merged elemental indexes, aggregated.","code":"ms_prices1 <- subset(ms_prices, business %in% c(\"B1\", \"B2\", \"B3\")) ms_prices2 <- subset(ms_prices, business == \"B4\") ms_epr1 <- with(   ms_prices1,    elemental_index(price_relative(price, period, product),                   period, business, na.rm = TRUE) ) ms_epr1 #> Period-over-period price index for 3 levels over 4 time periods  #>    202001    202002    202003   202004 #> B1      1 0.8949097 0.3342939      NaN #> B2      1       NaN       NaN 2.770456 #> B3      1 2.0200036 1.6353355 0.537996 ms_epr2 <- with(   transform(ms_prices2, period = factor(period, levels = time(ms_epr1))),    elemental_index(price_relative(price, period, product),                   period, business, na.rm = TRUE) ) ms_epr2 #> Period-over-period price index for 1 levels over 4 time periods  #>    202001 202002 202003   202004 #> B4    NaN    NaN    NaN 4.576286 aggregate(merge(ms_epr1, ms_epr2), pias, na.rm = TRUE) #> Aggregate period-over-period price index for 8 levels over 4 time periods  #>    202001    202002    202003   202004 #> 1       1 1.3007239 1.0630743 2.734761 #> 11      1 1.3007239 1.0630743 1.574515 #> 12      1 1.3007239 1.0630743 4.576286 #> B1      1 0.8949097 0.3342939 1.574515 #> B2      1 1.3007239 1.0630743 2.770456 #> B3      1 2.0200036 1.6353355 0.537996 #> B4      1 1.3007239 1.0630743 4.576286 #> B5      1 1.3007239 1.0630743 4.576286 ms_prices2 <- subset(   as.data.frame(aggregate(ms_epr, pias, na.rm = TRUE)),   level %in% c(\"B4\", \"B5\") ) ms_prices2 #>    period level    value #> 7  202001    B4 1.000000 #> 8  202001    B5 1.000000 #> 15 202002    B4 1.300724 #> 16 202002    B5 1.300724 #> 23 202003    B4 1.063074 #> 24 202003    B5 1.063074 #> 31 202004    B4 4.576286 #> 32 202004    B5 4.576286 ms_epr2 <- as_index(ms_prices2) aggregate(merge(ms_epr1, ms_epr2), pias, na.rm = TRUE) #> Aggregate period-over-period price index for 8 levels over 4 time periods  #>    202001    202002    202003   202004 #> 1       1 1.3007239 1.0630743 2.734761 #> 11      1 1.3007239 1.0630743 1.574515 #> 12      1 1.3007239 1.0630743 4.576286 #> B1      1 0.8949097 0.3342939 1.574515 #> B2      1 1.3007239 1.0630743 2.770456 #> B3      1 2.0200036 1.6353355 0.537996 #> B4      1 1.3007239 1.0630743 4.576286 #> B5      1 1.3007239 1.0630743 4.576286"},{"path":"https://marberts/github.io/piar/articles/piar.html","id":"aggregating-a-paasche-index","dir":"Articles","previous_headings":"","what":"Aggregating a Paasche index","title":"Making price indexes","text":"examples far used single set weights aggregate index. Although far common case, situations aggregation weights change every period. Paasche index notable example, weights aggregation current-period revenue shares period. new tools needed deal time-varying weights stack() unstack() functions. stack() appends later index series onto earlier one levels, whereas unstack() pulls apart index series many periods collection one-period indexes. first step making Paasche index unstack elemental indexes list elemental indexes period. (Trying make elemental indexes period--period can dangerous missing values.) second step make sequence aggregation structures set weights. Making Paasche index period now just case mapping aggregate() function elemental index aggregation structure, reducing result stack() function.","code":"weights <- data.frame(   period = rep(c(\"202001\", \"202002\", \"202003\", \"202004\"), each = 5),   classification = ms_weights$classification,   weight = 1:20 ) head(weights) #>   period classification weight #> 1 202001             11      1 #> 2 202001             11      2 #> 3 202001             11      3 #> 4 202001             12      4 #> 5 202001             12      5 #> 6 202002             11      6 (ms_epr <- unstack(ms_epr)) #> $`202001` #> Period-over-period price index for 4 levels over 1 time periods  #>    202001 #> B1      1 #> B2      1 #> B3      1 #> B4    NaN #>  #> $`202002` #> Period-over-period price index for 4 levels over 1 time periods  #>       202002 #> B1 0.8949097 #> B2       NaN #> B3 2.0200036 #> B4       NaN #>  #> $`202003` #> Period-over-period price index for 4 levels over 1 time periods  #>       202003 #> B1 0.3342939 #> B2       NaN #> B3 1.6353355 #> B4       NaN #>  #> $`202004` #> Period-over-period price index for 4 levels over 1 time periods  #>      202004 #> B1      NaN #> B2 2.770456 #> B3 0.537996 #> B4 4.576286 pias <- with(weights,               Map(aggregation_structure,                   list(hierarchy),                   split(weight, period)) ) (paasche <- Reduce(stack, Map(aggregate, ms_epr, pias, na.rm = TRUE, r = -1))) #> Aggregate period-over-period price index for 8 levels over 4 time periods  #>    202001    202002    202003    202004 #> 1       1 1.3127080 0.5874490 1.3591916 #> 11      1 1.3127080 0.5874490 0.8839797 #> 12      1 1.3127080 0.5874490 4.5762862 #> B1      1 0.8949097 0.3342939 0.8839797 #> B2      1 1.3127080 0.5874490 2.7704563 #> B3      1 2.0200036 1.6353355 0.5379960 #> B4      1 1.3127080 0.5874490 4.5762862 #> B5      1 1.3127080 0.5874490 4.5762862"},{"path":"https://marberts/github.io/piar/articles/piar.html","id":"making-a-fisher-index","dir":"Articles","previous_headings":"","what":"Making a Fisher index","title":"Making price indexes","text":"Paasche index hand, now trivial make Fisher index first making period--period Laspeyres index, simple matrix operation. Percent-change contributions can similarly computed matrix operation. despite matrix, resulting Fisher index can chained just like index. chained Fisher index can also made first chaining Laspyeres Paasche indexes, taking geometric mean.","code":"laspeyres <- Reduce(stack,                     Map(aggregate, ms_epr, pias[c(1, 1, 2, 3)], na.rm = TRUE))  (fisher <- sqrt(as.matrix(laspeyres) * as.matrix(paasche))) #>    202001    202002    202003   202004 #> 1       1 1.5107763 0.7956890 1.996688 #> 11      1 1.5107763 0.7956890 1.192826 #> 12      1 1.5107763 0.7956890 4.576286 #> B1      1 0.8949097 0.3342939 1.192826 #> B2      1 1.5107763 0.7956890 2.770456 #> B3      1 2.0200036 1.6353355 0.537996 #> B4      1 1.5107763 0.7956890 4.576286 #> B5      1 1.5107763 0.7956890 4.576286 geometric_weights <- transmute_weights(0, 1) w <- mapply(\\(x, y) scale_weights(geometric_weights(c(x, y))),             as.numeric(laspeyres[1]),             as.numeric(paasche[1]))  laspeyres_contrib <- contrib(laspeyres) paasche_contrib <- contrib(paasche)  fisher_contrib <- w[1, col(laspeyres_contrib)] * laspeyres_contrib +   w[2, col(paasche_contrib)] * paasche_contrib  fisher_contrib #>    202001      202002      202003       202004 #> 1       0  0.00000000  0.00000000  0.000000000 #> 10      0 -0.13327742  0.17296129 -0.131946938 #> 11      0  0.00000000          NA  0.039533034 #> 12      0  0.00000000          NA  0.880561300 #> 2      NA          NA -0.42962331  0.000000000 #> 3       0 -0.04756479          NA           NA #> 4       0          NA          NA -0.012019870 #> 5       0          NA          NA  0.062419211 #> 6       0          NA          NA  0.282471798 #> 7       0  0.78379264 -0.13008203 -0.018866231 #> 8       0  0.02893842  0.11116498 -0.006388331 #> 9       0 -0.12111255  0.07126804 -0.099076370 chain(fisher) #> Fixed-base price index for 8 levels over 4 time periods  #>    202001    202002    202003    202004 #> 1       1 1.5107763 1.2021080 2.4002342 #> 11      1 1.5107763 1.2021080 1.4339054 #> 12      1 1.5107763 1.2021080 5.5011904 #> B1      1 0.8949097 0.2991629 0.3568492 #> B2      1 1.5107763 1.2021080 3.3303878 #> B3      1 2.0200036 3.3033836 1.7772072 #> B4      1 1.5107763 1.2021080 5.5011904 #> B5      1 1.5107763 1.2021080 5.5011904 sqrt(as.matrix(chain(laspeyres)) * as.matrix(chain(paasche))) #>    202001    202002    202003    202004 #> 1       1 1.5107763 1.2021080 2.4002342 #> 11      1 1.5107763 1.2021080 1.4339054 #> 12      1 1.5107763 1.2021080 5.5011904 #> B1      1 0.8949097 0.2991629 0.3568492 #> B2      1 1.5107763 1.2021080 3.3303878 #> B3      1 2.0200036 3.3033836 1.7772072 #> B4      1 1.5107763 1.2021080 5.5011904 #> B5      1 1.5107763 1.2021080 5.5011904"},{"path":"https://marberts/github.io/piar/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Steve Martin. Author, maintainer, copyright holder.","code":""},{"path":"https://marberts/github.io/piar/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Martin S (2024). piar: Price Index Aggregation. doi:10.5281/zenodo.10110046, R package version 0.6.0.9009, https://cran.r-project.org/package=piar.","code":"@Manual{,   title = {{piar}: Price Index Aggregation},   author = {Steve Martin},   year = {2024},   doi = {10.5281/zenodo.10110046},   url = {https://cran.r-project.org/package=piar},   note = {R package version 0.6.0.9009}, }"},{"path":"https://marberts/github.io/piar/index.html","id":"price-index-aggregation-in-r-","dir":"","previous_headings":"","what":"Price Index Aggregation","title":"Price Index Aggregation","text":"price indexes made two-step procedure, period--period elemental indexes first calculated collection elemental aggregates point time, aggregated according price index aggregation structure. indexes can chained together form time series gives evolution prices respect fixed base period. package contains collections functions revolve around work flow, making easy build standard price indexes, implement methods described Balk (2008), von der Lippe (2001), CPI manual (2020) bilateral price indexes.","code":""},{"path":"https://marberts/github.io/piar/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Price Index Aggregation","text":"Get stable version CRAN. development version can installed R-Universe directly Github.","code":"install.packages(\"piar\") install.packages(\"piar\", repos = c(\"https://marberts.r-universe.dev\", \"https://cloud.r-project.org\")) pak::pak(\"marberts/piar\")"},{"path":"https://marberts/github.io/piar/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Price Index Aggregation","text":"detailed vignette showing use piar: browseVignettes(\"piar\"). basic work flow fairly simple. starting point make period--period elemental price indexes elemental_index() function. aggregation structure aggregation_structure() function. aggregate() method can used aggregate elemental indexes according aggregation structure. variety methods work index objects, chaining time.","code":"library(piar)  # Make Jevons business-level elemental indexes  head(ms_prices) #>   period business product price #> 1 202001       B1       1  1.14 #> 2 202001       B1       2    NA #> 3 202001       B1       3  6.09 #> 4 202001       B2       4  6.23 #> 5 202001       B2       5  8.61 #> 6 202001       B2       6  6.40  elementals <- with(   ms_prices,    elemental_index(     price_relative(price, period, product),      period, business, na.rm = TRUE   ) )  elementals #> Period-over-period price index for 4 levels over 4 time periods  #>    202001    202002    202003   202004 #> B1      1 0.8949097 0.3342939      NaN #> B2      1       NaN       NaN 2.770456 #> B3      1 2.0200036 1.6353355 0.537996 #> B4    NaN       NaN       NaN 4.576286 # Make an aggregation structure from businesses to higher-level # industrial classifications  head(ms_weights) #>   business classification weight #> 1       B1             11    553 #> 2       B2             11    646 #> 3       B3             11    312 #> 4       B4             12    622 #> 5       B5             12    330  pias <- with(   ms_weights,   aggregation_structure(     c(expand_classification(classification), list(business)),     weight   ) )  pias #> Aggregation structure for 5 elemental aggregates with 2 levels above the elemental aggregates  #>   level1 level2 ea weight #> 1      1     11 B1    553 #> 2      1     11 B2    646 #> 3      1     11 B3    312 #> 4      1     12 B4    622 #> 5      1     12 B5    330 # Aggregate elemental indexes with an arithmetic index  index <- aggregate(elementals, pias, na.rm = TRUE)  # Chain them to get a time series  chain(index) #> Aggregate fixed-base price index for 8 levels over 4 time periods  #>    202001    202002    202003    202004 #> 1       1 1.3007239 1.3827662 3.7815355 #> 11      1 1.3007239 1.3827662 2.1771866 #> 12      1 1.3007239 1.3827662 6.3279338 #> B1      1 0.8949097 0.2991629 0.4710366 #> B2      1 1.3007239 1.3827662 3.8308934 #> B3      1 2.0200036 3.3033836 1.7772072 #> B4      1 1.3007239 1.3827662 6.3279338 #> B5      1 1.3007239 1.3827662 6.3279338"},{"path":"https://marberts/github.io/piar/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Price Index Aggregation","text":"Balk, B. M. (2008). Price Quantity Index Numbers. Cambridge University Press. Chiru, R., Huang, N., Lequain, M. Smith, P., Wright, . (2015). Canadian Consumer Price Index Reference Paper, Statistics Canada catalogue 62-553-X. Statistics Canada. ILO, IMF, OECD, Eurostat, UN, World Bank. (2020). Consumer Price Index Manual: Theory Practice. International Monetary Fund. von der Lippe, P. (2001). Chain Indices: Study Price Index Theory, Spectrum Federal Statistics vol. 16. Federal Statistical Office, Wiesbaden.","code":""},{"path":"https://marberts/github.io/piar/reference/aggregate.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregate elemental price indexes — aggregate.piar_index","title":"Aggregate elemental price indexes — aggregate.piar_index","text":"Aggregate elemental price indexes price index aggregation structure.","code":""},{"path":"https://marberts/github.io/piar/reference/aggregate.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregate elemental price indexes — aggregate.piar_index","text":"","code":"# S3 method for chainable_piar_index aggregate(x, pias, na.rm = FALSE, r = 1, contrib = TRUE, ...)  # S3 method for direct_piar_index aggregate(x, pias, na.rm = FALSE, r = 1, contrib = TRUE, ...)"},{"path":"https://marberts/github.io/piar/reference/aggregate.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregate elemental price indexes — aggregate.piar_index","text":"x price index, usually made elemental_index(). pias price index aggregation structure something can coerced one. can made aggregation_structure(). na.rm missing values removed? default, missing values removed. Setting na.rm = TRUE equivalent overall mean imputation. r Order generalized mean aggregate index values. 0 geometric index (default making elemental indexes), 1 arithmetic index (default aggregating elemental indexes averaging indexes subperiods), -1 harmonic index (usually Paasche index). values possible; see gpindex::generalized_mean() details. contrib Aggregate percent-change contributions x ()? ... arguments passed used methods.","code":""},{"path":"https://marberts/github.io/piar/reference/aggregate.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregate elemental price indexes — aggregate.piar_index","text":"aggregate price index inherits aggregate_piar_index class x.","code":""},{"path":"https://marberts/github.io/piar/reference/aggregate.piar_index.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Aggregate elemental price indexes — aggregate.piar_index","text":"aggregate() method loops time period x aggregates elemental indexes gpindex::generalized_mean(r)() level pias; aggregates percent-change contributions level pias (contrib = TRUE); price updates weights pias gpindex::factor_weights(r)() (period--period elemental indexes). result collection aggregated period--period indexes can chained together get fixed-base index x period--period elemental indexes. Otherwise, x fixed-base elemental indexes, result collection aggregated fixed-base (direct) indexes. default, missing elemental indexes propagate aggregating index. Missing elemental indexes can due missingness values x, presence elemental aggregates pias part x. Setting na.rm = TRUE ignores missing values, equivalent parental (overall mean) imputation. aggregated price index generally missing values (otherwise chained time weights price updated), missing values level pias removed recursively replaced value immediate parent. cases aggregation done arithmetic mean (default), detailed chapter 8 (pp. 190--198) CPI manual (2020). Aggregating non-arithmetic mean follows steps, except elemental indexes aggregated mean different order (e.g., harmonic Paasche index), method price updating weights slightly different. Note , aggregation done generalized mean, resulting index consistent--aggregation point time. Aggregating percent-change contributions uses method chapter 9 CPI manual (equations 9.26 9.28) aggregating arithmetic mean. non-arithmetic mean, arithmetic weights constructed using gpindex::transmute_weights(r, 1)() order apply method. may contributions prices relatives elemental aggregate elemental indexes built several sources (merge()). case contribution price relative aggregated index correct, sum contributions equal change value index. can also happen aggregating already aggregated index missing index values imputed (.e., na.rm = TRUE).","code":""},{"path":"https://marberts/github.io/piar/reference/aggregate.piar_index.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Aggregate elemental price indexes — aggregate.piar_index","text":"large indexes can much faster turn aggregation structure aggregation matrix .matrix(), aggregate elemental indexes matrix operation missing values---see examples details.","code":""},{"path":"https://marberts/github.io/piar/reference/aggregate.piar_index.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Aggregate elemental price indexes — aggregate.piar_index","text":"Balk, B. M. (2008). Price Quantity Index Numbers. Cambridge University Press. ILO, IMF, OECD, Eurostat, UN, World Bank. (2020). Consumer Price Index Manual: Theory Practice. International Monetary Fund.","code":""},{"path":[]},{"path":"https://marberts/github.io/piar/reference/aggregate.piar_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregate elemental price indexes — aggregate.piar_index","text":"","code":"prices <- data.frame(   rel = 1:8,   period = rep(1:2, each = 4),   ea = rep(letters[1:2], 4) )  # A two-level aggregation structure  pias <- aggregation_structure(   list(c(\"top\", \"top\", \"top\"), c(\"a\", \"b\", \"c\")), 1:3 )  # Calculate Jevons elemental indexes  (epr <- with(prices, elemental_index(rel, period, ea))) #> Period-over-period price index for 2 levels over 2 time periods  #>          1        2 #> a 1.732051 5.916080 #> b 2.828427 6.928203  # Aggregate (note the imputation for elemental index 'c')  (index <- aggregate(epr, pias, na.rm = TRUE)) #> Aggregate period-over-period price index for 4 levels over 2 time periods  #>            1        2 #> top 2.462968 6.690949 #> a   1.732051 5.916080 #> b   2.828427 6.928203 #> c   2.462968 6.690949  # Aggregation can equivalently be done as matrix multiplication  as.matrix(pias) %*% as.matrix(chain(index[letters[1:3]])) #>            1       2 #> top 2.462968 16.4796"},{"path":"https://marberts/github.io/piar/reference/aggregation_structure.html","id":null,"dir":"Reference","previous_headings":"","what":"Make a price index aggregation structure — aggregation_structure","title":"Make a price index aggregation structure — aggregation_structure","text":"Create price index aggregation structure hierarchical classification aggregation weights can used aggregate elemental indexes.","code":""},{"path":"https://marberts/github.io/piar/reference/aggregation_structure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make a price index aggregation structure — aggregation_structure","text":"","code":"aggregation_structure(x, weights = NULL)"},{"path":"https://marberts/github.io/piar/reference/aggregation_structure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make a price index aggregation structure — aggregation_structure","text":"x list character vectors give codes/labels level classification, ordered moving list goes hierarchy. last vector gives elemental aggregates, duplicates. vectors length, without NAs, duplicates across different levels x. weights numeric vector aggregation weights elemental aggregates (.e., last vector x). default give elemental aggregate weight.","code":""},{"path":"https://marberts/github.io/piar/reference/aggregation_structure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make a price index aggregation structure — aggregation_structure","text":"price index aggregation structure class piar_aggregation_structure. list-S3 class following components. child nested list gives positions immediate children node level aggregation structure terminal nodes. parent list gives position immediate parent node aggregation structure initial nodes. levels character vector gives levels x. eas character vector gives subset levels elemental aggregates. weights named vector giving weight elemental aggregate. height length x.","code":""},{"path":"https://marberts/github.io/piar/reference/aggregation_structure.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"Make a price index aggregation structure — aggregation_structure","text":"aggregation_structure() function best check arguments, expectation result aggregation_structure() make sense x represent nested hierarchy.","code":""},{"path":[]},{"path":"https://marberts/github.io/piar/reference/aggregation_structure.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make a price index aggregation structure — aggregation_structure","text":"","code":"# A simple aggregation structure #            1 #      |-----+-----| #      11          12 #  |---+---|       | #  111     112     121 #  (1)     (3)     (4)  aggregation_weights <- data.frame(   level1 = c(\"1\", \"1\", \"1\"),   level2 = c(\"11\", \"11\", \"12\"),   ea     = c(\"111\", \"112\", \"121\"),   weight = c(1, 3, 4) )  pias <- aggregation_structure(   aggregation_weights[1:3],   weights = aggregation_weights[[4]] )  # The aggregation structure can also be made by expanding the # elemental aggregates  all.equal(   with(     aggregation_weights,     aggregation_structure(expand_classification(ea), weight)   ),   pias ) #> [1] TRUE"},{"path":"https://marberts/github.io/piar/reference/as.data.frame.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce an index into a tabular form — as.data.frame.piar_index","title":"Coerce an index into a tabular form — as.data.frame.piar_index","text":"Turn index data frame matrix.","code":""},{"path":"https://marberts/github.io/piar/reference/as.data.frame.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce an index into a tabular form — as.data.frame.piar_index","text":"","code":"# S3 method for piar_index as.data.frame(x, ..., stringsAsFactors = FALSE)  # S3 method for piar_index as.matrix(x, ...)"},{"path":"https://marberts/github.io/piar/reference/as.data.frame.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce an index into a tabular form — as.data.frame.piar_index","text":"x price index, made , e.g., elemental_index(). ... arguments passed used methods. stringsAsFactors See .data.frame().","code":""},{"path":"https://marberts/github.io/piar/reference/as.data.frame.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce an index into a tabular form — as.data.frame.piar_index","text":".data.frame() returns data frame three columns: period, level, value. .matrix() returns matrix row level column period.","code":""},{"path":[]},{"path":"https://marberts/github.io/piar/reference/as.data.frame.piar_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce an index into a tabular form — as.data.frame.piar_index","text":"","code":"prices <- data.frame(   rel = 1:8,   period = rep(1:2, each = 4),   ea = rep(letters[1:2], 4) )  epr <- with(prices, elemental_index(rel, period, ea))  as.data.frame(epr) #>   period level    value #> 1      1     a 1.732051 #> 2      1     b 2.828427 #> 3      2     a 5.916080 #> 4      2     b 6.928203 as.matrix(epr) #>          1        2 #> a 1.732051 5.916080 #> b 2.828427 6.928203"},{"path":"https://marberts/github.io/piar/reference/as.matrix.piar_aggregation_structure.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce a price index aggregation structure into a tabular form — as.matrix.piar_aggregation_structure","title":"Coerce a price index aggregation structure into a tabular form — as.matrix.piar_aggregation_structure","text":"Coerce price index aggregation structure aggregation matrix, data frame.","code":""},{"path":"https://marberts/github.io/piar/reference/as.matrix.piar_aggregation_structure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce a price index aggregation structure into a tabular form — as.matrix.piar_aggregation_structure","text":"","code":"# S3 method for piar_aggregation_structure as.matrix(x, sparse = FALSE, ...)  # S3 method for piar_aggregation_structure as.data.frame(x, ..., stringsAsFactors = FALSE)"},{"path":"https://marberts/github.io/piar/reference/as.matrix.piar_aggregation_structure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce a price index aggregation structure into a tabular form — as.matrix.piar_aggregation_structure","text":"x price index aggregation structure, made aggregation_structure(). sparse result sparse matrix Matrix? faster large aggregation structures. default returns ordinary dense matrix. ... arguments passed used methods. stringsAsFactors See .data.frame().","code":""},{"path":"https://marberts/github.io/piar/reference/as.matrix.piar_aggregation_structure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce a price index aggregation structure into a tabular form — as.matrix.piar_aggregation_structure","text":".matrix() represents aggregation structure matrix, multiplying (column) vector elemental indexes gives aggregated index. .data.frame() takes aggregation structure returns data frame generated , columns level1, level2, ..., ea, weight.","code":""},{"path":[]},{"path":"https://marberts/github.io/piar/reference/as.matrix.piar_aggregation_structure.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce a price index aggregation structure into a tabular form — as.matrix.piar_aggregation_structure","text":"","code":"# A simple aggregation structure #            1 #      |-----+-----| #      11          12 #  |---+---|       | #  111     112     121 #  (1)     (3)     (4)  aggregation_weights <- data.frame(   level1 = c(\"1\", \"1\", \"1\"),   level2 = c(\"11\", \"11\", \"12\"),   ea     = c(\"111\", \"112\", \"121\"),   weight = c(1, 3, 4) )  pias <- as_aggregation_structure(aggregation_weights)  as.matrix(pias) #>      111   112 121 #> 1  0.125 0.375 0.5 #> 11 0.250 0.750 0.0 #> 12 0.000 0.000 1.0  all.equal(as.data.frame(pias), aggregation_weights) #> [1] TRUE"},{"path":"https://marberts/github.io/piar/reference/as_aggregation_structure.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to an aggregation structure — as_aggregation_structure","title":"Coerce to an aggregation structure — as_aggregation_structure","text":"Coerce object aggregation structure object.","code":""},{"path":"https://marberts/github.io/piar/reference/as_aggregation_structure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to an aggregation structure — as_aggregation_structure","text":"","code":"as_aggregation_structure(x, ...)  # S3 method for default as_aggregation_structure(x, weights = NULL, ...)  # S3 method for data.frame as_aggregation_structure(x, ...)  # S3 method for matrix as_aggregation_structure(x, ...)  # S3 method for aggregate_piar_index as_aggregation_structure(x, weights = NULL, ...)"},{"path":"https://marberts/github.io/piar/reference/as_aggregation_structure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to an aggregation structure — as_aggregation_structure","text":"x object coerce aggregation structure. ... arguments passed used methods. weights numeric vector aggregation weights elemental aggregates. default give elemental aggregate weight.","code":""},{"path":"https://marberts/github.io/piar/reference/as_aggregation_structure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to an aggregation structure — as_aggregation_structure","text":"price index aggregation structure inherits piar_aggregation_structure.","code":""},{"path":"https://marberts/github.io/piar/reference/as_aggregation_structure.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Coerce to an aggregation structure — as_aggregation_structure","text":"default method attempts coerce x list prior calling aggregation_structure(). data frame matrix methods treat x table row elemental aggregate, column labels level aggregation structure, column weights elemental aggregates. method aggregate indexes reconstructs aggregation structure used generate index (optional weights).","code":""},{"path":[]},{"path":"https://marberts/github.io/piar/reference/as_aggregation_structure.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce to an aggregation structure — as_aggregation_structure","text":"","code":"# A simple aggregation structure #            1 #      |-----+-----| #      11          12 #  |---+---|       | #  111     112     121 #  (1)     (3)     (4)  aggregation_weights <- data.frame(   level1 = c(\"1\", \"1\", \"1\"),   level2 = c(\"11\", \"11\", \"12\"),   ea     = c(\"111\", \"112\", \"121\"),   weight = c(1, 3, 4) )  pias <- aggregation_structure(aggregation_weights[1:3],   weights = aggregation_weights[[4]] )  all.equal(   pias,   as_aggregation_structure(aggregation_weights) ) #> [1] TRUE  all.equal(   pias,   as_aggregation_structure(as.matrix(aggregation_weights)) ) #> [1] TRUE"},{"path":"https://marberts/github.io/piar/reference/as_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to a price index — as_index","title":"Coerce to a price index — as_index","text":"Coerce pre-computed index values index object.","code":""},{"path":"https://marberts/github.io/piar/reference/as_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to a price index — as_index","text":"","code":"as_index(x, ...)  # S3 method for default as_index(x, chainable = TRUE, ...)  # S3 method for matrix as_index(x, chainable = TRUE, ...)  # S3 method for data.frame as_index(x, cols = NULL, chainable = TRUE, ...)  # S3 method for chainable_piar_index as_index(x, chainable = TRUE, ...)  # S3 method for direct_piar_index as_index(x, chainable = FALSE, ...)"},{"path":"https://marberts/github.io/piar/reference/as_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to a price index — as_index","text":"x object coerce price index. ... arguments passed used methods. chainable index values x period--period indexes, suitable chained calculation (default)? FALSE x fixed-base (direct) index. cols Deprecated. vector giving positions/names period, level, value columns x. default assumes first column contains time periods, second contains levels, third contains index values.","code":""},{"path":"https://marberts/github.io/piar/reference/as_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to a price index — as_index","text":"as_index() returns price index inherits piar_index. chainable = TRUE period--period price index also inherits chainable_piar_index; otherwise, fixed-base index inherits direct_piar_index.","code":""},{"path":"https://marberts/github.io/piar/reference/as_index.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Coerce to a price index — as_index","text":"Numeric matrices coerced index object treating column separate time period, row elemental aggregate. Column names used denote time periods, row names used denote elemental aggregates (must unique). essentially reverses calling .matrix() index object. dimension unnamed, given sequential label 1 size dimension. default method coerces x matrix prior using matrix method. data frame method as_index() best understood reversing effect .data.frame() index object. constructs matrix taking levels x[[1]] columns levels x[[1]] rows (coercing factor necessary). populates matrix corresponding values x[[3]], uses matrix method as_index(). x period--period index returned unchanged chainable = TRUE chained otherwise. Similarly, x fixed-base index returned unchanged chainable == FALSE unchain otherwise.","code":""},{"path":[]},{"path":"https://marberts/github.io/piar/reference/as_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce to a price index — as_index","text":"","code":"prices <- data.frame(   rel = 1:8,   period = rep(1:2, each = 4),   ea = rep(letters[1:2], 4) )  # Calculate period-over-period Jevons elemental indexes  epr <- with(prices, elemental_index(rel, period, ea))  all.equal(as_index(as.data.frame(epr)), epr) #> [1] TRUE all.equal(as_index(as.matrix(epr)), epr) #> [1] TRUE"},{"path":"https://marberts/github.io/piar/reference/chain.html","id":null,"dir":"Reference","previous_headings":"","what":"Chain and rebase a price index — chain","title":"Chain and rebase a price index — chain","text":"Chain period--period index taking cumulative product values turn fixed-base (direct) index. Unchain fixed-base index dividing values successive periods get period--period index. Rebase fixed-base index dividing values value index new base period.","code":""},{"path":"https://marberts/github.io/piar/reference/chain.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chain and rebase a price index — chain","text":"","code":"chain(x, ...)  # S3 method for default chain(x, ...)  # S3 method for chainable_piar_index chain(x, link = rep(1, nlevels(x)), ...)  # S3 method for direct_piar_index chain(x, ...)  unchain(x, ...)  # S3 method for default unchain(x, ...)  # S3 method for chainable_piar_index unchain(x, ...)  # S3 method for direct_piar_index unchain(x, ...)  rebase(x, ...)  # S3 method for default rebase(x, ...)  # S3 method for chainable_piar_index rebase(x, ...)  # S3 method for direct_piar_index rebase(x, base = rep(1, nlevels(x)), ...)"},{"path":"https://marberts/github.io/piar/reference/chain.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chain and rebase a price index — chain","text":"x price index, made , e.g., elemental_index(). ... arguments passed used methods. link numeric vector, something can coerced one, link values level x. default vector 1s linking done. base numeric vector, something can coerced one, base-period index values level x. default vector 1s base period remains .","code":""},{"path":"https://marberts/github.io/piar/reference/chain.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chain and rebase a price index — chain","text":"chain() rebase() return fixed-base index inherits direct_piar_index. unchain() returns period--period index inherits chainable_piar_index.","code":""},{"path":"https://marberts/github.io/piar/reference/chain.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chain and rebase a price index — chain","text":"default methods attempts coerce x index as_index() prior chaining/unchaining/rebasing. Chaining index takes cumulative product index values level; roughly t(apply(.matrix(x), 1, cumprod)) * link. Unchaining opposite, inverse operations. Note unchaining period--period index (.e., is_chainable_index(x) == TRUE) nothing, chaining fixed-base index (.e., is_chainable_index(x) == FALSE). Rebasing fixed-base index divides values level index corresponding values level new base period. roughly .matrix(x) / base. Like unchaining, rebasing period--period index nothing. Percent-change contributions removed chaining/unchaining/rebasing index, usually possible update correctly.","code":""},{"path":[]},{"path":"https://marberts/github.io/piar/reference/chain.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chain and rebase a price index — chain","text":"","code":"prices <- data.frame(   rel = 1:8,   period = rep(1:2, each = 4),   ea = rep(letters[1:2], 4) )  # A simple period-over-period elemental index  (epr <- with(prices, elemental_index(rel, period, ea))) #> Period-over-period price index for 2 levels over 2 time periods  #>          1        2 #> a 1.732051 5.916080 #> b 2.828427 6.928203  # Make period 0 the fixed base period  chain(epr) #> Fixed-base price index for 2 levels over 2 time periods  #>          1        2 #> a 1.732051 10.24695 #> b 2.828427 19.59592  # Chaining and unchaining reverse each other  all.equal(epr, unchain(chain(epr))) #> [1] TRUE  # Change the base period to period 2 (note the # loss of information for period 0)  epr <- chain(epr) rebase(epr, epr[, 2]) #> Fixed-base price index for 2 levels over 2 time periods  #>           1 2 #> a 0.1690309 1 #> b 0.1443376 1"},{"path":"https://marberts/github.io/piar/reference/contrib.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract percent-change contributions — contrib","title":"Extract percent-change contributions — contrib","text":"Extract matrix percent-change contributions price index.","code":""},{"path":"https://marberts/github.io/piar/reference/contrib.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract percent-change contributions — contrib","text":"","code":"contrib(x, ...)  # S3 method for piar_index contrib(x, level = levels(x)[1L], period = time(x), pad = 0, ...)"},{"path":"https://marberts/github.io/piar/reference/contrib.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract percent-change contributions — contrib","text":"x price index, made , e.g., elemental_index(). ... arguments passed used methods. level level index percent-change contributions desired, defaulting first level (usually top-level aggregate index). period time periods percent-change contributions desired, defaulting time periods. pad numeric value pad contributions fit rectangular array products differ time. default 0.","code":""},{"path":"https://marberts/github.io/piar/reference/contrib.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract percent-change contributions — contrib","text":"matrix percent-change contributions column period row product (sorted) contributions level. Contributions padded pad fit rectangular array products differ time.","code":""},{"path":[]},{"path":"https://marberts/github.io/piar/reference/contrib.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract percent-change contributions — contrib","text":"","code":"prices <- data.frame(   rel = 1:8,   period = rep(1:2, each = 4),   ea = rep(letters[1:2], 4) )  epr <- with(   prices,   elemental_index(rel, period, ea, contrib = TRUE) )  pias <- aggregation_structure(   list(c(\"top\", \"top\", \"top\"), c(\"a\", \"b\", \"c\")), 1:3 )  index <- aggregate(epr, pias, na.rm = TRUE)  # Percent-change contributions for the top-level index  contrib(index) #>             1         2 #> a.1 0.0000000 0.5081686 #> a.2 0.2440169 0.6442213 #> b.1 0.3905243 2.0513858 #> b.2 0.8284271 2.4871732  # Calculate EA contributions for the chained index  library(gpindex)  arithmetic_contributions(   as.matrix(chain(index))[c(\"a\", \"b\", \"c\"), 2],   weights(pias, ea_only = TRUE) ) #>        a        b        c  #> 1.541158 6.198639 7.739798"},{"path":"https://marberts/github.io/piar/reference/elemental_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Make elemental price indexes — elemental_index","title":"Make elemental price indexes — elemental_index","text":"Compute period--period (chainable) fixed-base (direct) elemental price indexes, optional percent-change contributions.","code":""},{"path":"https://marberts/github.io/piar/reference/elemental_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make elemental price indexes — elemental_index","text":"","code":"elemental_index(x, ...)  # S3 method for default elemental_index(x, ...)  # S3 method for numeric elemental_index(   x,   period = gl(1, length(x)),   ea = gl(1, length(x)),   weights = NULL,   contrib = FALSE,   chainable = TRUE,   na.rm = FALSE,   r = 0,   ... )"},{"path":"https://marberts/github.io/piar/reference/elemental_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make elemental price indexes — elemental_index","text":"x Period--period fixed-base price relatives. Currently method numeric vectors; can made price_relative(). ... arguments passed used methods. period factor, something can coerced one, giving time period associated price relative x. ordering time periods follows levels period, agree cut(). default assumes price relatives belong one time period. ea factor, something can coerced one, giving elemental aggregate associated price relative x. default assumes price relatives belong one elemental aggregate. weights numeric vector weights price relatives x. default equal weights. contrib percent-change contributions calculated? default calculate contributions. chainable price relatives x period--period relatives chained calculation (default)? FALSE x contains fixed-base relatives. na.rm missing values removed? default, missing values removed. Setting na.rm = TRUE equivalent overall mean imputation. r Order generalized mean aggregate price relatives. 0 geometric index (default making elemental indexes), 1 arithmetic index (default aggregating elemental indexes averaging indexes subperiods), -1 harmonic index (usually Paasche index). values possible; see gpindex::generalized_mean() details.","code":""},{"path":"https://marberts/github.io/piar/reference/elemental_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make elemental price indexes — elemental_index","text":"price index inherits piar_index. chainable = TRUE period--period index also inherits chainable_piar_index; otherwise, fixed-based index inherits direct_piar_index.","code":""},{"path":"https://marberts/github.io/piar/reference/elemental_index.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Make elemental price indexes — elemental_index","text":"supplied numeric vector, elemental_index() simple wrapper applies gpindex::generalized_mean(r)() gpindex::contributions(r)() (contrib = TRUE) x weights grouped ea period. , every combination elemental aggregate time period, elemental_index() calculates index based generalized mean order r , optionally, percent-change contributions. default (r = 0 weights) makes Jevons elemental indexes. See chapter 8 (pp. 175--190) CPI manual (2020) detail making elemental indexes, chapter 5 Balk (2008). default method simply coerces x numeric vector prior calling method . Names x used product names calculating percent-change contributions. Product names unique within time period, , , passed make.unique() warning. x names elements x given sequential names within elemental aggregate. interpretation index depends price relatives x made. period--period relatives, result collection period--period (chainable) elemental indexes; fixed-base relatives, result collection fixed-base (direct) elemental indexes. latter, chainable set FALSE subsequent methods assume chained calculation used. default, missing price relatives x propagate throughout index calculation. Ignoring missing values na.rm = TRUE overall mean (parental) imputation, needs explicitly set call elemental_index(). Explicit imputation missing relatives, especially imputation missing prices, done prior calling elemental_index(). Indexes based nested generalized means, like Fisher index (superlative quadratic mean indexes generally), can calculated supplying appropriate weights gpindex::nested_transmute(); see example . important note several ways make weights, affects percent-change contributions calculated.","code":""},{"path":"https://marberts/github.io/piar/reference/elemental_index.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Make elemental price indexes — elemental_index","text":"Balk, B. M. (2008). Price Quantity Index Numbers. Cambridge University Press. ILO, IMF, OECD, Eurostat, UN, World Bank. (2020). Consumer Price Index Manual: Theory Practice. International Monetary Fund.","code":""},{"path":[]},{"path":"https://marberts/github.io/piar/reference/elemental_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make elemental price indexes — elemental_index","text":"","code":"library(gpindex)  prices <- data.frame(   rel = 1:8,   period = rep(1:2, each = 4),   ea = rep(letters[1:2], 4) )  # Calculate Jevons elemental indexes  (epr <- with(prices, elemental_index(rel, period, ea))) #> Period-over-period price index for 2 levels over 2 time periods  #>          1        2 #> a 1.732051 5.916080 #> b 2.828427 6.928203  # Same as using lm() or tapply()  exp(coef(lm(log(rel) ~ ea:factor(period) - 1, prices))) #> eaa:factor(period)1 eab:factor(period)1 eaa:factor(period)2 eab:factor(period)2  #>            1.732051            2.828427            5.916080            6.928203   with(   prices,   t(tapply(rel, list(period, ea), geometric_mean, na.rm = TRUE)) ) #>          1        2 #> a 1.732051 5.916080 #> b 2.828427 6.928203  # A general function to calculate weights to turn the geometric # mean of the arithmetic and harmonic mean (i.e., Fisher mean) # into an arithmetic mean  fw <- grouped(nested_transmute(0, c(1, -1), 1))  # Calculate a CSWD index (same as the Jevons in this example) # as an arithmetic index by using the appropriate weights  with(   prices,   elemental_index(     rel, period, ea,     fw(rel, group = interaction(period, ea)),     r = 1   ) ) #> Period-over-period price index for 2 levels over 2 time periods  #>          1        2 #> a 1.732051 5.916080 #> b 2.828427 6.928203"},{"path":"https://marberts/github.io/piar/reference/expand_classification.html","id":null,"dir":"Reference","previous_headings":"","what":"Expand a hierarchical classification — expand_classification","title":"Expand a hierarchical classification — expand_classification","text":"Expand character representation hierarchical classification make price index aggregation structure.","code":""},{"path":"https://marberts/github.io/piar/reference/expand_classification.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expand a hierarchical classification — expand_classification","text":"","code":"expand_classification(x, width = 1L)"},{"path":"https://marberts/github.io/piar/reference/expand_classification.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expand a hierarchical classification — expand_classification","text":"x character vector, something can coerced one, codes/labels specific level classification (e.g., 5-digit COICOP, 5-digit NAICS, 4-digit SIC). width integer vector gives width digit x. single value recycled span longest element x. contain NAs. default assumes digit width 1, NAICS, NAPCS, SIC classifications.","code":""},{"path":"https://marberts/github.io/piar/reference/expand_classification.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expand a hierarchical classification — expand_classification","text":"list entry level x giving \"digits\" represent level hierarchy.","code":""},{"path":[]},{"path":"https://marberts/github.io/piar/reference/expand_classification.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Expand a hierarchical classification — expand_classification","text":"","code":"# A simple classification structure #            1 #      |-----+-----| #      11          12 #  |---+---|       | #  111     112     121  expand_classification(c(\"111\", \"112\", \"121\")) #> [[1]] #> [1] \"1\" \"1\" \"1\" #>  #> [[2]] #> [1] \"11\" \"11\" \"12\" #>  #> [[3]] #> [1] \"111\" \"112\" \"121\" #>   # Expanding more complex classifications # ... if last 'digit' is either TA or TS  expand_classification(   c(\"111TA\", \"112TA\", \"121TS\"),   width = c(1, 1, 1, 2) ) #> [[1]] #> [1] \"1\" \"1\" \"1\" #>  #> [[2]] #> [1] \"11\" \"11\" \"12\" #>  #> [[3]] #> [1] \"111\" \"112\" \"121\" #>  #> [[4]] #> [1] \"111TA\" \"112TA\" \"121TS\" #>   # ... if first 'digit' is either 11 or 12  expand_classification(c(\"111\", \"112\", \"121\"), width = c(2, 1)) #> [[1]] #> [1] \"11\" \"11\" \"12\" #>  #> [[2]] #> [1] \"111\" \"112\" \"121\" #>   # ...if there are delimiters in the classification (like COICOP)  expand_classification(c(\"01.1.1\", \"01.1.2\", \"01.2.1\"), width = 2) #> [[1]] #> [1] \"01\" \"01\" \"01\" #>  #> [[2]] #> [1] \"01.1\" \"01.1\" \"01.2\" #>  #> [[3]] #> [1] \"01.1.1\" \"01.1.2\" \"01.2.1\" #>"},{"path":"https://marberts/github.io/piar/reference/head.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Return the first/last parts of an index — head.piar_index","title":"Return the first/last parts of an index — head.piar_index","text":"Extract first/last parts index matrix.","code":""},{"path":"https://marberts/github.io/piar/reference/head.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return the first/last parts of an index — head.piar_index","text":"","code":"# S3 method for piar_index head(x, n = 6L, ...)  # S3 method for piar_index tail(x, n = 6L, ...)"},{"path":"https://marberts/github.io/piar/reference/head.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return the first/last parts of an index — head.piar_index","text":"x price index, made , e.g., elemental_index(). n See head()/tail(). default takes first/last 6 levels x. ... arguments passed used methods.","code":""},{"path":"https://marberts/github.io/piar/reference/head.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return the first/last parts of an index — head.piar_index","text":"price index inherits chainable_piar_index x period--period index, direct_piar_index() x fixed-base index.","code":""},{"path":[]},{"path":"https://marberts/github.io/piar/reference/head.piar_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Return the first/last parts of an index — head.piar_index","text":"","code":"prices <- data.frame(   rel = 1:8,   period = rep(1:2, each = 4),   ea = rep(letters[1:2], 4) )  # Calculate Jevons elemental indexes  epr <- with(prices, elemental_index(rel, period, ea))  # Get the first/last time series  head(epr, 1) #> Period-over-period price index for 1 levels over 2 time periods  #>          1       2 #> a 1.732051 5.91608  tail(epr, 1) #> Period-over-period price index for 1 levels over 2 time periods  #>          1        2 #> b 2.828427 6.928203"},{"path":"https://marberts/github.io/piar/reference/impute_prices.html","id":null,"dir":"Reference","previous_headings":"","what":"Impute missing prices — impute_prices","title":"Impute missing prices — impute_prices","text":"Impute missing prices using carry forward shadow price method.","code":""},{"path":"https://marberts/github.io/piar/reference/impute_prices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Impute missing prices — impute_prices","text":"","code":"shadow_price(   x,   period,   product,   ea,   pias = NULL,   weights = NULL,   r1 = 0,   r2 = 1 )  carry_forward(x, period, product)  carry_backwards(x, period, product)"},{"path":"https://marberts/github.io/piar/reference/impute_prices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Impute missing prices — impute_prices","text":"x numeric vector prices. period factor, something can coerced one, giving time period associated price x. ordering time periods follows levels period, agree cut(). product factor, something can coerced one, giving product associated price x. ea factor, something can coerced one, giving elemental aggregate associated price x. pias price index aggregation structure, something can coerced one, made aggregation_structure(). default imputes elemental indexes (.e., recursively). weights numeric vector weights prices x (.e., product weights). default give price equal weight. r1 Order generalized-mean price index used calculate elemental price indexes: 0 geometric index (default), 1 arithmetic index, -1 harmonic index. values possible; see gpindex::generalized_mean() details. r2 Order generalized-mean price index used aggregate elemental price indexes: 0 geometric index, 1 arithmetic index (default), -1 harmonic index. values possible; see gpindex::generalized_mean() details.","code":""},{"path":"https://marberts/github.io/piar/reference/impute_prices.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Impute missing prices — impute_prices","text":"copy x missing values replaced (possible).","code":""},{"path":"https://marberts/github.io/piar/reference/impute_prices.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Impute missing prices — impute_prices","text":"carry forward method replaces missing price product price product previous period. tends push index value towards 1, usually avoided; see paragraph 6.61 CPI manual (2020). carry backwards method opposite, rarely used practice. shadow price method recursively imputes missing price value price product previous period multiplied value period--period elemental index elemental aggregate product belongs. requires computing aggregating index (according pias, unless pias supplied) period, imputations can take . index values used imputations returned index needs recalculated get correct percent-change contributions. Shadow price imputation referred self-correcting overall mean imputation chapter 6 CPI manual (2020). identical simply excluding missing price relatives index calculation, except period missing product returns. reason care needed using method. sensitive assumption product change time, cases safer simply omit missing price relatives instead imputing missing prices.","code":""},{"path":"https://marberts/github.io/piar/reference/impute_prices.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Impute missing prices — impute_prices","text":"ILO, IMF, OECD, Eurostat, UN, World Bank. (2020). Consumer Price Index Manual: Theory Practice. International Monetary Fund.","code":""},{"path":[]},{"path":"https://marberts/github.io/piar/reference/impute_prices.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Impute missing prices — impute_prices","text":"","code":"prices <- data.frame(   price = c(1:7, NA),   period = rep(1:2, each = 4),   product = 1:4,   ea = rep(letters[1:2], 4) )  with(prices, carry_forward(price, period, product)) #> [1] 1 2 3 4 5 6 7 4  with(prices, shadow_price(price, period, product, ea)) #> [1]  1  2  3  4  5  6  7 12"},{"path":"https://marberts/github.io/piar/reference/is.na.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Missing values in a price index — is.na.piar_index","title":"Missing values in a price index — is.na.piar_index","text":"Identify replace missing values price index.","code":""},{"path":"https://marberts/github.io/piar/reference/is.na.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Missing values in a price index — is.na.piar_index","text":"","code":"# S3 method for piar_index is.na(x)  # S3 method for piar_index anyNA(x, recursive)  # S3 method for piar_index is.na(x) <- value"},{"path":"https://marberts/github.io/piar/reference/is.na.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Missing values in a price index — is.na.piar_index","text":"x price index, made , e.g., elemental_index(). recursive Ignored. value numeric vector, something can coerced one, replacement values.","code":""},{"path":"https://marberts/github.io/piar/reference/is.na.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Missing values in a price index — is.na.piar_index","text":".na() returns logical matrix, row level x columns time period, indicates index values missing. replacement method replaces values value. anyNA() returns TRUE index values missing.","code":""},{"path":[]},{"path":"https://marberts/github.io/piar/reference/is.na.piar_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Missing values in a price index — is.na.piar_index","text":"","code":"index <- as_index(matrix(c(1, 2, 3, NA, 5, NA), 2))  anyNA(index) #> [1] TRUE is.na(index) #>       1     2     3 #> 1 FALSE FALSE FALSE #> 2 FALSE  TRUE  TRUE  # Carry forward imputation  is.na(index) <- 1 index #> Period-over-period price index for 2 levels over 3 time periods  #>   1 2 3 #> 1 1 3 5 #> 2 2 1 1"},{"path":"https://marberts/github.io/piar/reference/is_aggregation_structure.html","id":null,"dir":"Reference","previous_headings":"","what":"Test if an object is a price index aggregation structure — is_aggregation_structure","title":"Test if an object is a price index aggregation structure — is_aggregation_structure","text":"Test object price index aggregation structure.","code":""},{"path":"https://marberts/github.io/piar/reference/is_aggregation_structure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test if an object is a price index aggregation structure — is_aggregation_structure","text":"","code":"is_aggregation_structure(x)"},{"path":"https://marberts/github.io/piar/reference/is_aggregation_structure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test if an object is a price index aggregation structure — is_aggregation_structure","text":"x object test.","code":""},{"path":"https://marberts/github.io/piar/reference/is_aggregation_structure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test if an object is a price index aggregation structure — is_aggregation_structure","text":"Returns TRUE x inherits piar_aggregation_structure","code":""},{"path":"https://marberts/github.io/piar/reference/is_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Test if an object is a price index — is_index","title":"Test if an object is a price index — is_index","text":"Test object index object, subclass index object.","code":""},{"path":"https://marberts/github.io/piar/reference/is_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test if an object is a price index — is_index","text":"","code":"is_index(x)  is_aggregate_index(x)  is_chainable_index(x)  is_direct_index(x)"},{"path":"https://marberts/github.io/piar/reference/is_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test if an object is a price index — is_index","text":"x object test.","code":""},{"path":"https://marberts/github.io/piar/reference/is_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test if an object is a price index — is_index","text":"is_index() returns TRUE x inherits piar_index. is_chainable_index() returns TRUE x inherits chainable_piar_index. is_direct_index() returns TRUE x inherits direct_piar_index. is_aggregate_index() returns TRUE x inherits aggregate_piar_index.","code":""},{"path":"https://marberts/github.io/piar/reference/levels.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the levels for a price index — levels.piar_index","title":"Get the levels for a price index — levels.piar_index","text":"Methods get set levels price index.","code":""},{"path":"https://marberts/github.io/piar/reference/levels.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the levels for a price index — levels.piar_index","text":"","code":"# S3 method for piar_index levels(x)  # S3 method for piar_index levels(x) <- value"},{"path":"https://marberts/github.io/piar/reference/levels.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the levels for a price index — levels.piar_index","text":"x price index, made , e.g., elemental_index(). value character vector, something can coerced one, giving replacement levels x.","code":""},{"path":"https://marberts/github.io/piar/reference/levels.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the levels for a price index — levels.piar_index","text":"levels() returns character vector levels price index. replacement method returns copy x levels value. generally possible change levels aggregate price index, case replacing levels return aggregate index.","code":""},{"path":[]},{"path":"https://marberts/github.io/piar/reference/mean.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregate a price index over subperiods — mean.piar_index","title":"Aggregate a price index over subperiods — mean.piar_index","text":"Aggregate index subperiods taking (usually arithmetic) mean index values consecutive windows subperiods.","code":""},{"path":"https://marberts/github.io/piar/reference/mean.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregate a price index over subperiods — mean.piar_index","text":"","code":"# S3 method for piar_index mean(x, weights = NULL, window = 3L, na.rm = FALSE, r = 1, contrib = TRUE, ...)"},{"path":"https://marberts/github.io/piar/reference/mean.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregate a price index over subperiods — mean.piar_index","text":"x price index, made , e.g., elemental_index(). weights numeric vector weights index values x. default equal weights. usually easiest specify weights matrix row index value x column time period. window positive integer giving size window used average index values across subperiods. default (3) turns monthly index quarterly one. Non-integers truncated towards 0. na.rm missing values removed? default, missing values removed. Setting na.rm = TRUE equivalent overall mean imputation. r Order generalized mean aggregate index values. 0 geometric index (default making elemental indexes), 1 arithmetic index (default aggregating elemental indexes averaging indexes subperiods), -1 harmonic index (usually Paasche index). values possible; see gpindex::generalized_mean() details. contrib Aggregate percent-change contributions x ()? ... arguments passed used methods.","code":""},{"path":"https://marberts/github.io/piar/reference/mean.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregate a price index over subperiods — mean.piar_index","text":"price index class x. x aggregate index r different used aggregate x, result aggregate index (longer consistent aggregation).","code":""},{"path":"https://marberts/github.io/piar/reference/mean.piar_index.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Aggregate a price index over subperiods — mean.piar_index","text":"mean() method constructs set non-overlapping windows length window, starting first period index, takes mean index value windows level index. last window discarded incomplete, index values always averaged window periods. names first time period window form new names aggregated time periods. Percent-change contributions aggregated contrib = TRUE treating product-subperiod pair unique product, following approach aggregate(). number subperiod appended product names make unique across subperiods. optional vector weights can specified aggregating index values subperiods, often useful aggregating Paasche index; see section 4.3 Balk (2008) details.","code":""},{"path":"https://marberts/github.io/piar/reference/mean.piar_index.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Aggregate a price index over subperiods — mean.piar_index","text":"Balk, B. M. (2008). Price Quantity Index Numbers. Cambridge University Press.","code":""},{"path":[]},{"path":"https://marberts/github.io/piar/reference/mean.piar_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregate a price index over subperiods — mean.piar_index","text":"","code":"prices <- data.frame(   rel = 1:8,   period = rep(1:2, each = 4),   ea = rep(letters[1:2], 4) )  epr <- with(prices, elemental_index(rel, period, ea))  mean(epr, window = 2) #> Period-over-period price index for 2 levels over 1 time periods  #>          1 #> a 3.824065 #> b 4.878315"},{"path":"https://marberts/github.io/piar/reference/merge.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge price indexes — merge.piar_index","title":"Merge price indexes — merge.piar_index","text":"Combine two price indexes common time periods, merging together index values percent-change contributions time period. useful building index different elemental aggregates come different sources data, use different index-number formulas.","code":""},{"path":"https://marberts/github.io/piar/reference/merge.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge price indexes — merge.piar_index","text":"","code":"# S3 method for piar_index merge(x, y, ...)"},{"path":"https://marberts/github.io/piar/reference/merge.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge price indexes — merge.piar_index","text":"x price index, made , e.g., elemental_index(). y price index, something can coerced one. x period--period index y coerce chainable index; otherwise, y coerced direct index. ... arguments passed used methods.","code":""},{"path":"https://marberts/github.io/piar/reference/merge.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge price indexes — merge.piar_index","text":"price index inherits chainable_piar_index x period--period index, direct_piar_index x fixed-base index. generally possible merge aggregated indexes, change aggregation structure, merging return aggregated index.","code":""},{"path":[]},{"path":"https://marberts/github.io/piar/reference/merge.piar_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Merge price indexes — merge.piar_index","text":"","code":"prices <- data.frame(   rel = 1:8,   period = rep(1:2, each = 4),   ea = rep(letters[1:2], 4) )  prices2 <- data.frame(   rel = 1:8,   period = rep(1:2, each = 4),   ea = rep(letters[3:4], 4) )  epr <- with(prices, elemental_index(rel, period, ea))  epr2 <- with(prices2, elemental_index(rel, period, ea))  merge(epr, epr2) #> Period-over-period price index for 4 levels over 2 time periods  #>          1        2 #> a 1.732051 5.916080 #> b 2.828427 6.928203 #> c 1.732051 5.916080 #> d 2.828427 6.928203"},{"path":"https://marberts/github.io/piar/reference/piar-package.html","id":null,"dir":"Reference","previous_headings":"","what":"piar: Price Index Aggregation — piar-package","title":"piar: Price Index Aggregation — piar-package","text":"price indexes made two-step procedure, period--period elemental indexes first calculated collection elemental aggregates point time, aggregated according price index aggregation structure. indexes can chained together form time series gives evolution prices respect fixed base period. package contains collections functions revolve around work flow, making easy build standard price indexes, implement methods described Balk (2008, ISBN:978-1-107-40496-0), von der Lippe (2001, ISBN:3-8246-0638-0), CPI manual (2020, ISBN:978-1-51354-298-0) bilateral price indexes.","code":""},{"path":[]},{"path":"https://marberts/github.io/piar/reference/piar-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"piar: Price Index Aggregation — piar-package","text":"Maintainer: Steve Martin marberts@protonmail.com (ORCID) [copyright holder]","code":""},{"path":"https://marberts/github.io/piar/reference/piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Price index objects — piar_index","title":"Price index objects — piar_index","text":"several classes represent price indexes. indexes inherit piar_index virtual class. Period--period indexes can chained time inherit chainable_piar_index. Fixed-base indexes inherit direct_piar_index. Aggregate price indexes result aggregating elemental indexes aggregation structure inherit aggregate_piar_index.","code":""},{"path":"https://marberts/github.io/piar/reference/piar_index.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Price index objects — piar_index","text":"piar_index object list-S3 class following components: index list entry period time gives vector index values level levels. contrib list entry period time, contains list entry level levels named vector gives additive contribution price relative. levels character vector giving levels index. time character vector giving time periods index. chainable_piar_index direct_piar_index subclasses structure piar_index class, differ methods used manipulate indexes. aggregate_piar_index class subclasses either chainable_piar_index direct_piar_index, adds following components: r order generalized mean used aggregated index (usually 1). pias list containing child, parent, eas, height components aggregation structured used aggregate index.","code":""},{"path":"https://marberts/github.io/piar/reference/price_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Price data — price_data","title":"Price data — price_data","text":"Sample price weight data match sample fixed sample type index.","code":""},{"path":"https://marberts/github.io/piar/reference/price_relative.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate period-over-period price relatives — price_relative","title":"Calculate period-over-period price relatives — price_relative","text":"Construct period--period price relatives information prices products time.","code":""},{"path":"https://marberts/github.io/piar/reference/price_relative.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate period-over-period price relatives — price_relative","text":"","code":"price_relative(x, period, product)"},{"path":"https://marberts/github.io/piar/reference/price_relative.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate period-over-period price relatives — price_relative","text":"x numeric vector prices. period factor, something can coerced one, gives corresponding time period element x. ordering time periods follows levels period agree cut(). product factor, something can coerced one, gives corresponding product identifier element x.","code":""},{"path":"https://marberts/github.io/piar/reference/price_relative.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate period-over-period price relatives — price_relative","text":"numeric vector price relatives, product names.","code":""},{"path":[]},{"path":"https://marberts/github.io/piar/reference/price_relative.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate period-over-period price relatives — price_relative","text":"","code":"price_relative(1:6, rep(1:2, each = 3), rep(letters[1:3], 2)) #>   a   b   c   a   b   c  #> 1.0 1.0 1.0 4.0 2.5 2.0"},{"path":"https://marberts/github.io/piar/reference/stack.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Stack price indexes — stack.piar_index","title":"Stack price indexes — stack.piar_index","text":"stack() combines two price indexes common levels, stacking index values percent-change contributions one index . unstack() breaks price index list indexes time period. methods can used map-reduce make index multiple aggregation structures (like Paasche index).","code":""},{"path":"https://marberts/github.io/piar/reference/stack.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stack price indexes — stack.piar_index","text":"","code":"# S3 method for piar_index stack(x, y, ...)  # S3 method for piar_index unstack(x, ...)"},{"path":"https://marberts/github.io/piar/reference/stack.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stack price indexes — stack.piar_index","text":"x price index, made , e.g., elemental_index(). y price index, something can coerced one. x period--period index y coerce chainable index; otherwise, y coerced direct index. ... arguments passed used methods.","code":""},{"path":"https://marberts/github.io/piar/reference/stack.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stack price indexes — stack.piar_index","text":"price index inherits chainable_piar_index x period--period index, direct_piar_index x fixed-base index. x y aggregate indexes result also inherit aggregate_piar_index. unstack() returns list price indexes class x.","code":""},{"path":[]},{"path":"https://marberts/github.io/piar/reference/stack.piar_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stack price indexes — stack.piar_index","text":"","code":"prices <- data.frame(   rel = 1:8,   period = rep(1:2, each = 4),   ea = rep(letters[1:2], 4) )  prices2 <- data.frame(   rel = 1:8,   period = rep(3:4, each = 4),   ea = rep(letters[1:2], 4) )  epr <- with(prices, elemental_index(rel, period, ea))  epr2 <- with(prices2, elemental_index(rel, period, ea))  stack(epr, epr2) #> Period-over-period price index for 2 levels over 4 time periods  #>          1        2        3        4 #> a 1.732051 5.916080 1.732051 5.916080 #> b 2.828427 6.928203 2.828427 6.928203  # Unstack does the reverse  all.equal(   c(unstack(epr), unstack(epr2)),   unstack(stack(epr, epr2)) ) #> [1] TRUE"},{"path":"https://marberts/github.io/piar/reference/sub-.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract and replace index values — [.piar_index","title":"Extract and replace index values — [.piar_index","text":"Methods extract replace index values like matrix.","code":""},{"path":"https://marberts/github.io/piar/reference/sub-.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract and replace index values — [.piar_index","text":"","code":"# S3 method for piar_index [(x, i, j, ...)  # S3 method for piar_index [(x, i, j, ...) <- value"},{"path":"https://marberts/github.io/piar/reference/sub-.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract and replace index values — [.piar_index","text":"x price index, made , e.g., elemental_index(). , j Indices levels time periods price index. See details. ... Ignored. value numeric vector price index. See details.","code":""},{"path":"https://marberts/github.io/piar/reference/sub-.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract and replace index values — [.piar_index","text":"price index inherits chainable_piar_index x period--period index, direct_piar_index x fixed-base index. x inherits aggregate_piar_index [ returns aggregate index levels unchanged.","code":""},{"path":"https://marberts/github.io/piar/reference/sub-.piar_index.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract and replace index values — [.piar_index","text":"extraction methods treat x like matrix index values (named) rows level columns period x. Unlike matrix, dimensions never dropped subscripting x always returns index object. means subscripting matrix possible, \"submatrix\" can extracted. x atomic vector, subscripting single index like x[1] extracts time periods level. replacement method similarly treat x like matrix. value index object number time periods x[, j] inherits class x, index values percent-change contributions x[, j] replaced corresponding levels value. value index, coerced numeric vector behaves replacing values matrix. Note replacing values index remove corresponding percent-change contributions (). Subscripting aggregate index generally preserve aggregation structure levels removed rearranged, case resulting index aggregate index. Similarly, replacing values aggregate index generally breaks consistency aggregation, therefore result aggregate index.","code":""},{"path":[]},{"path":"https://marberts/github.io/piar/reference/sub-.piar_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract and replace index values — [.piar_index","text":"","code":"prices <- data.frame(   rel = 1:8,   period = rep(1:2, each = 4),   ea = rep(letters[1:2], 4) )  # Calculate Jevons elemental indexes  epr <- with(prices, elemental_index(rel, period, ea))  # Extract the indexes like a matrix  epr[\"a\", ] #> Period-over-period price index for 1 levels over 2 time periods  #>          1       2 #> a 1.732051 5.91608  epr[, 2] #> Period-over-period price index for 2 levels over 1 time periods  #>          2 #> a 5.916080 #> b 6.928203  epr[1, ] <- 1 # can be useful for doing specific imputations epr #> Period-over-period price index for 2 levels over 2 time periods  #>          1        2 #> a 1.000000 1.000000 #> b 2.828427 6.928203"},{"path":"https://marberts/github.io/piar/reference/summary.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize a price index — summary.piar_index","title":"Summarize a price index — summary.piar_index","text":"Summarize index matrix index values (.e., five-number summary period). percent-change contributions, also summarized matrix.","code":""},{"path":"https://marberts/github.io/piar/reference/summary.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize a price index — summary.piar_index","text":"","code":"# S3 method for piar_index summary(object, ...)"},{"path":"https://marberts/github.io/piar/reference/summary.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize a price index — summary.piar_index","text":"object price index, made , e.g., elemental_index(). ... arguments passed used methods.","code":""},{"path":"https://marberts/github.io/piar/reference/summary.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize a price index — summary.piar_index","text":"list five-number summaries.","code":""},{"path":"https://marberts/github.io/piar/reference/summary.piar_index.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Summarize a price index — summary.piar_index","text":"function still experimental may change future.","code":""},{"path":"https://marberts/github.io/piar/reference/summary.piar_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize a price index — summary.piar_index","text":"","code":"prices <- data.frame(   rel = 1:8,   period = rep(1:2, each = 4),   ea = rep(letters[1:2], 4) )  epr <- with(prices, elemental_index(rel, period, ea))  summary(epr) #> Indexes #>        1               2         #>  Min.   :1.732   Min.   :5.916   #>  1st Qu.:2.006   1st Qu.:6.169   #>  Median :2.280   Median :6.422   #>  Mean   :2.280   Mean   :6.422   #>  3rd Qu.:2.554   3rd Qu.:6.675   #>  Max.   :2.828   Max.   :6.928"},{"path":"https://marberts/github.io/piar/reference/time.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the time periods for a price index — time.piar_index","title":"Get the time periods for a price index — time.piar_index","text":"Methods get set time periods price index.","code":""},{"path":"https://marberts/github.io/piar/reference/time.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the time periods for a price index — time.piar_index","text":"","code":"# S3 method for piar_index time(x, ...)  time(x) <- value  # S3 method for piar_index time(x) <- value  # S3 method for piar_index start(x, ...)  # S3 method for piar_index end(x, ...)"},{"path":"https://marberts/github.io/piar/reference/time.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the time periods for a price index — time.piar_index","text":"x price index, made , e.g., elemental_index(). ... arguments passed used methods. value character vector, something can coerced one, giving replacement time periods x.","code":""},{"path":"https://marberts/github.io/piar/reference/time.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the time periods for a price index — time.piar_index","text":"time() return character vector time periods price index. start() end() return first last time period. replacement method returns copy x time periods value.","code":""},{"path":[]},{"path":"https://marberts/github.io/piar/reference/update.piar_aggregation_structure.html","id":null,"dir":"Reference","previous_headings":"","what":"Update a price index aggregation structure — update.piar_aggregation_structure","title":"Update a price index aggregation structure — update.piar_aggregation_structure","text":"Price update weights price index aggregation structure.","code":""},{"path":"https://marberts/github.io/piar/reference/update.piar_aggregation_structure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update a price index aggregation structure — update.piar_aggregation_structure","text":"","code":"# S3 method for piar_aggregation_structure update(object, index, period = end(index), r = NULL, ...)"},{"path":"https://marberts/github.io/piar/reference/update.piar_aggregation_structure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update a price index aggregation structure — update.piar_aggregation_structure","text":"object price index aggregation structure, made aggregation_structure(). index price index, something can coerced one. Usually aggregate price index made aggregate(). period time period used price update weights. default uses last period index. r Order generalized mean update weights. default uses order used aggregate index aggregate index; otherwise, default 1 arithmetic index. ... arguments passed used methods.","code":""},{"path":"https://marberts/github.io/piar/reference/update.piar_aggregation_structure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update a price index aggregation structure — update.piar_aggregation_structure","text":"copy object price-updated weights using index values index.","code":""},{"path":[]},{"path":"https://marberts/github.io/piar/reference/update.piar_aggregation_structure.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Update a price index aggregation structure — update.piar_aggregation_structure","text":"","code":"# A simple aggregation structure #            1 #      |-----+-----| #      11          12 #  |---+---|       | #  111     112     121 #  (1)     (3)     (4)  aggregation_weights <- data.frame(   level1 = c(\"1\", \"1\", \"1\"),   level2 = c(\"11\", \"11\", \"12\"),   ea     = c(\"111\", \"112\", \"121\"),   weight = c(1, 3, 4) )  pias <- as_aggregation_structure(aggregation_weights)  index <- as_index(   matrix(1:9, 3, dimnames = list(c(\"111\", \"112\", \"121\"), NULL)) )  weights(pias, ea_only = FALSE) #> [[1]] #> 1  #> 8  #>  #> [[2]] #> 11 12  #>  4  4  #>  #> [[3]] #> 111 112 121  #>   1   3   4  #>   weights(update(pias, index), ea_only = FALSE) #> [[1]] #>   1  #> 916  #>  #> [[2]] #>  11  12  #> 268 648  #>  #> [[3]] #> 111 112 121  #>  28 240 648  #>"},{"path":"https://marberts/github.io/piar/reference/vcov.aggregate_piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Bootstrap variance for a price index with replicate weights — vcov.aggregate_piar_index","title":"Bootstrap variance for a price index with replicate weights — vcov.aggregate_piar_index","text":"Estimate sampling variance aggregate price index using sample elemental aggregates.","code":""},{"path":"https://marberts/github.io/piar/reference/vcov.aggregate_piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bootstrap variance for a price index with replicate weights — vcov.aggregate_piar_index","text":"","code":"# S3 method for aggregate_piar_index vcov(object, repweights, mse = TRUE, sparse = FALSE, ...)"},{"path":"https://marberts/github.io/piar/reference/vcov.aggregate_piar_index.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Bootstrap variance for a price index with replicate weights — vcov.aggregate_piar_index","text":"vcov() method influenced SAS routine Justin Francis first ported R Ambuj Dewan, subsequently rewritten Steve Martin.","code":""},{"path":"https://marberts/github.io/piar/reference/vcov.aggregate_piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bootstrap variance for a price index with replicate weights — vcov.aggregate_piar_index","text":"object aggregate price index, made aggregate(). repweights matrix, something can coerced one, bootstrap replicate weights row elemental aggregate column replicate. mse variance centered value index object (default), mean replicates? sparse Use sparse matrices Matrix aggregating index. Faster indexes large aggregation structures. default uses regular dense matrices. ... arguments passed used methods.","code":""},{"path":"https://marberts/github.io/piar/reference/vcov.aggregate_piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bootstrap variance for a price index with replicate weights — vcov.aggregate_piar_index","text":"matrix variances row upper-level index column time period.","code":""},{"path":"https://marberts/github.io/piar/reference/vcov.aggregate_piar_index.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bootstrap variance for a price index with replicate weights — vcov.aggregate_piar_index","text":"function simple wrapper reaggregates elemental indexes object using bootstrap replicate weights repweights get collection aggregate indexes variance calculated. approach usually applicable elemental aggregates sampled stratified design follows aggregation structure, correlation index values different levels index. ignores variation elemental indexes (often use judgmental sampling), ultimately depends method generating replicate weights. (Chapters 3 4 Selvanathan Rao (1994), especially section 4.7, provide analytic variance estimators common price indexes applicable simple random sampling.) Note missing elemental indexes need explicitly imputed prior using method, otherwise propagate throughout variance calculation.","code":""},{"path":"https://marberts/github.io/piar/reference/vcov.aggregate_piar_index.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Bootstrap variance for a price index with replicate weights — vcov.aggregate_piar_index","text":"Selvanathan, E. ., Rao, D. S. P. (1994). Index Numbers: Stochastic Approach. MacMillan.","code":""},{"path":[]},{"path":"https://marberts/github.io/piar/reference/vcov.aggregate_piar_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bootstrap variance for a price index with replicate weights — vcov.aggregate_piar_index","text":"","code":"prices <- data.frame(   rel = 1:8,   period = rep(1:2, each = 4),   ea = rep(letters[1:2], 4) )  # A two-level aggregation structure  pias <- aggregation_structure(   list(c(\"top\", \"top\", \"top\"), c(\"a\", \"b\", \"c\")), 1:3 )  repweights <- matrix(c(0, 2, 3, 1, 2, 4, 2, 3, 3), 3)  # Calculate Jevons elemental indexes  epr <- with(prices, elemental_index(rel, period, ea))  # Aggregate  index <- aggregate(epr, pias, na.rm = TRUE)  # Calculate variance  vcov(index, repweights) #>               1           2 #> top 0.007818832 0.003929299"},{"path":"https://marberts/github.io/piar/reference/weights.piar_aggregation_structure.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the weights for a price index aggregation structure — weights.piar_aggregation_structure","title":"Get the weights for a price index aggregation structure — weights.piar_aggregation_structure","text":"Get set weights price index aggregation structure.","code":""},{"path":"https://marberts/github.io/piar/reference/weights.piar_aggregation_structure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the weights for a price index aggregation structure — weights.piar_aggregation_structure","text":"","code":"# S3 method for piar_aggregation_structure weights(object, ea_only = TRUE, na.rm = FALSE, ...)  weights(object) <- value  # S3 method for piar_aggregation_structure weights(object) <- value"},{"path":"https://marberts/github.io/piar/reference/weights.piar_aggregation_structure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the weights for a price index aggregation structure — weights.piar_aggregation_structure","text":"object price index aggregation structure, made aggregation_structure(). ea_only weights returned elemental aggregates (default)? Setting FALSE gives weights entire aggregation structure. na.rm missing values removed aggregating weights (.e., ea_only = FALSE)? default, missing values removed. ... arguments passed used methods. value numeric vector weights elemental aggregates object.","code":""},{"path":"https://marberts/github.io/piar/reference/weights.piar_aggregation_structure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the weights for a price index aggregation structure — weights.piar_aggregation_structure","text":"weights() returns named vector weights elemental aggregates. replacement method replaces values without changing aggregation structure. ea_only = TRUE return value list named vector weights level aggregation structure.","code":""},{"path":[]},{"path":"https://marberts/github.io/piar/reference/weights.piar_aggregation_structure.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the weights for a price index aggregation structure — weights.piar_aggregation_structure","text":"","code":"# A simple aggregation structure #            1 #      |-----+-----| #      11          12 #  |---+---|       | #  111     112     121 #  (1)     (3)     (4)  aggregation_weights <- data.frame(   level1 = c(\"1\", \"1\", \"1\"),   level2 = c(\"11\", \"11\", \"12\"),   ea     = c(\"111\", \"112\", \"121\"),   weight = c(1, 3, 4) )  pias <- as_aggregation_structure(aggregation_weights)  # Extract the weights  weights(pias) #> 111 112 121  #>   1   3   4   # ... or update them  weights(pias) <- 1:3 weights(pias) #> 111 112 121  #>   1   2   3"},{"path":"https://marberts/github.io/piar/news/index.html","id":"version-061","dir":"Changelog","previous_headings":"","what":"Version 0.6.1","title":"Version 0.6.1","text":"several bug fixed version make non-backwards compatible changes.","code":""},{"path":"https://marberts/github.io/piar/news/index.html","id":"improvements-0-6-1","dir":"Changelog","previous_headings":"","what":"Improvements","title":"Version 0.6.1","text":"Added examples finding imputed index values vignette. contrib() gets new argument period control time periods get included contributions matrix (documented). contrib() gets new argument pad control contribution matrix padded products differ time. Added .na(), .na<-(), anyNA() methods find replace missing values index object. mean() gets new argument contrib control product contributions aggregated subperiods.","code":""},{"path":"https://marberts/github.io/piar/news/index.html","id":"bug-fixes-0-6-1","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"Version 0.6.1","text":"default ea_only changed TRUE calling weights(aggregation_structure) fix bug replacement method. Replacing index value index[] <- value value also index object now works correctly value recycled. Setting stringsAsFactors = TRUE .data.frame(index) now keeps correct ordering factor levels. mean(index) longer returns aggregate index r differs used make index.","code":""},{"path":"https://marberts/github.io/piar/news/index.html","id":"deprecations-0-6-1","dir":"Changelog","previous_headings":"","what":"Deprecations","title":"Version 0.6.1","text":"cols argument as_index() deprecated removed future version.","code":""},{"path":"https://marberts/github.io/piar/news/index.html","id":"version-060","dir":"Changelog","previous_headings":"","what":"Version 0.6.0","title":"Version 0.6.0","text":"CRAN release: 2023-11-19","code":""},{"path":"https://marberts/github.io/piar/news/index.html","id":"significant-changes-0-6-0","dir":"Changelog","previous_headings":"","what":"Significant changes","title":"Version 0.6.0","text":"[[ method index objects removed created unexpected problems little gain. .matrix(index)[[1, 1]] explicit flexible way get behavior index[[1, 1]]. aggregation_structure() now orders levels aggregation according order appear data. Previously levels ordered lexicographically, except elemental aggregates. can affect order index values appear aggregate index. number changes way product names handled making index extracting percent-change contributions. Names price relatives now need unique within time period elemental_index(). previous (undocumented) behavior require names unique within time period elemental aggregate. implies two non-backward compatible changes. default product names elemental_index() now include name elemental aggregate conform requirement. Percent-change contributions contrib() simplified row names, now need include index-level names make product names unique. contrib() now always returns matrix. Previously return NULL contributions level index. Rows contributions matrix ordered according product names consistent ordering.","code":""},{"path":"https://marberts/github.io/piar/news/index.html","id":"improvements-0-6-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"Version 0.6.0","text":"Printing index gives textual description addition matrix index values. Printing aggregation structure now gives description tabular representation instead list. now methods set levels time periods index. Methods index objects now faster larger indexes. aggregate() gains new argument contrib controls percent-change contributions elemental indexes aggregated. default maintains current behavior aggregating contributions . class names index objects changed fix name conflict Matrix. means ’s now possible use rsmatrix piar. .matrix() method aggregation structures gains new argument sparse. sparse = TRUE aggregation matrix sparse, rather dense, matrix. option can also used vcov() method aggregate price indexes improve performance large indexes. Added carry_backwards() function carry backwards (opposed carry forwards) imputation.","code":""},{"path":"https://marberts/github.io/piar/news/index.html","id":"bug-fixes-0-6-0","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"Version 0.6.0","text":"Viewing index objects RStudio viewer longer gives error. is_direct_index() now exported. Replacing index values aggregate index longer returns aggregate index, may consistent aggregation. Stacking two indexes now returns aggregate index indexes aggregate indexes. Previously possible stack aggregate index non-aggregate index produce aggregate index consistent aggregation.","code":""},{"path":"https://marberts/github.io/piar/news/index.html","id":"version-050","dir":"Changelog","previous_headings":"","what":"Version 0.5.0","title":"Version 0.5.0","text":"CRAN release: 2023-08-10","code":""},{"path":"https://marberts/github.io/piar/news/index.html","id":"significant-changes-0-5-0","dir":"Changelog","previous_headings":"","what":"Significant changes","title":"Version 0.5.0","text":"piar now requires R >= 4.0. is_chain_index() removed; use is_chainable_index() instead. first argument elemental_index() now x, rel, consistent rest functions. Similarly, first argument expand_classification() now x, class.","code":""},{"path":"https://marberts/github.io/piar/news/index.html","id":"new-features-0-5-0","dir":"Changelog","previous_headings":"","what":"New features","title":"Version 0.5.0","text":"New functions as_aggregation_structure() is_aggregation_structure() coerce (usually) tabular data aggregation weights aggregation structure, test object aggregation structure. method [[ index objects extract replace single index value. weights aggregation structure can replace weights(pias) <- vector.","code":""},{"path":"https://marberts/github.io/piar/news/index.html","id":"improvements-0-5-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"Version 0.5.0","text":"levels() replacement function now gives error indexes aggregation structures, rather adding levels attribute nothing. width argument expand_classification() now recycles single value. Major overhaul documentation make easier use. object structure used represent index object refined. Subscripting index object now much faster. now possible update aggregation structure non-aggregated index. Functions accept price index aggregation structure argument now attempt coerce arguments index object aggregation structure object instead throwing error.","code":""},{"path":"https://marberts/github.io/piar/news/index.html","id":"bug-fixes-0-5-0","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"Version 0.5.0","text":"Fixed bug creating elemental indexes missing product names produce contributions matrix wrong number products. now possible chain index one level. Subscripting index NAs duplicate indices longer allowed.","code":""},{"path":"https://marberts/github.io/piar/news/index.html","id":"version-040","dir":"Changelog","previous_headings":"","what":"Version 0.4.0","title":"Version 0.4.0","text":"CRAN release: 2022-04-30","code":""},{"path":"https://marberts/github.io/piar/news/index.html","id":"significant-changes-0-4-0","dir":"Changelog","previous_headings":"","what":"Significant changes","title":"Version 0.4.0","text":"vcov() method aggregate indexes now returns matrix variances instead array covariances, covariances usually misleading unnecessary. cases elemental aggregates sampled independently, case covariances 0. backwards compatible. vcov() method aggregate indexes now much faster. options parallel computing removed, ’re unlikely useful even large indexes. head() tail() methods index objects now return index object instead matrix, documented.","code":""},{"path":"https://marberts/github.io/piar/news/index.html","id":"new-features-0-4-0","dir":"Changelog","previous_headings":"","what":"New features","title":"Version 0.4.0","text":"Added .matrix() method pias objects. makes easy aggregate price index matrix operation; just matrix multiply aggregation matrix elemental indexes. Added .data.frame() method pias objects. useful writing price-updated weights , e.g., write.csv(). Added as_index() method data frames. faster simpler turning data frame index elemental_index(df$value, df$period, df$level).","code":""},{"path":"https://marberts/github.io/piar/news/index.html","id":"improvements-0-4-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"Version 0.4.0","text":"chain argument found methods elemental_index() as_index() mark index chainable replaced descriptive chainable argument. Partial matching argument names means backwards compatible. price_relative() function longer uses gpindex::back_price(), function deprecated. change remove harmless deprecation warning using older version piar newer version gpindex.","code":""},{"path":"https://marberts/github.io/piar/news/index.html","id":"deprecated-functions-0-4-0","dir":"Changelog","previous_headings":"","what":"Deprecated functions","title":"Version 0.4.0","text":"is_chain_index() function now deprecated, replaced is_chainable_index() function.","code":""}]
