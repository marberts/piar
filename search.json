[{"path":"https://marberts.github.io/piar/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing","title":"Contributing","text":"Contributions piar welcome appreciated. ways can contribute.","code":""},{"path":"https://marberts.github.io/piar/CONTRIBUTING.html","id":"reporting-bugs","dir":"","previous_headings":"","what":"Reporting bugs","title":"Contributing","text":"Open issue small reproducible example bug. Feel free include PR patch.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/CONTRIBUTING.html","id":"typos-and-corrections","dir":"","previous_headings":"Improving documentation","what":"Typos and corrections","title":"Contributing","text":"can fix typos, spelling mistakes, make small corrections documentation editing roxygen2 comments corresponding .R (.Rd) file.","code":""},{"path":"https://marberts.github.io/piar/CONTRIBUTING.html","id":"adding-documentation","dir":"","previous_headings":"Improving documentation","what":"Adding documentation","title":"Contributing","text":"Please open issue feel documentation unclear certain functions don’t enough documentation.","code":""},{"path":"https://marberts.github.io/piar/CONTRIBUTING.html","id":"suggestions-for-improvement","dir":"","previous_headings":"","what":"Suggestions for improvement","title":"Contributing","text":"Open issue suggestions improvements (e.g., feature requests).","code":""},{"path":"https://marberts.github.io/piar/CONTRIBUTING.html","id":"seeking-support","dir":"","previous_headings":"","what":"Seeking support","title":"Contributing","text":"Open issue (send email) ’re stuck able find answer documentation. (may bug problem documentation.)","code":""},{"path":"https://marberts.github.io/piar/CONTRIBUTING.html","id":"making-a-pull-request","dir":"","previous_headings":"","what":"Making a pull request","title":"Contributing","text":"making pull request, please: Fork repository github make new branch forked copy; Follow tidyverse style guide; Use roxygen2 documentation; Use testthat unit tests; Ensure changes pass R CMD check.","code":""},{"path":"https://marberts.github.io/piar/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 Steve Martin Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://marberts.github.io/piar/articles/piar.html","id":"matched-sample-index","dir":"Articles","previous_headings":"","what":"Matched-sample index","title":"Making price indexes","text":"first example covers calculating matched-sample index, fixed set businesses provide prices collection products time. products reported businesses can change time, set businesses fixed duration sample. businesses weight established sample drawn, represents particular segment economy. usual approach calculating matched-sample index starts computing elemental index business equally-weighted geometric mean price relatives (.e., Jevons index). , index values different segments economy calculated arithmetic mean elemental indexes, using businesses-level weights (either Young Lowe index, depending weights constructed). ms_prices dataset price data five businesses four quarters, ms_weights dataset weight data. Note data fairly realistic patterns missing data. elemental_index() function makes, well, elemental indexes, using information price relatives, elemental aggregates (businesses), time periods (quarters). default makes Jevons index, bilateral generalized-mean index possible. wrinkle price data levels, relatives, price_relative() function can make necessary conversion. (Homogeneous elemental aggregates often leads unit-value elemental indexes based price relatives. cases can dealt first aggregating prices elemental aggregate, aggregate(price ~ period + product, ms_prices, mean), point time arithmetic mean, forming price relatives feed elemental_index().) functions R, missing values contagious default piar. Setting na.rm = TRUE elemental_index() means missing price relatives ignored, equivalent imputing missing relatives value elemental index respective businesses (.e., parental overall mean imputation). types imputation possible, topic subsequent example. elemental_index() function returns special index object, number methods working objects. Probably useful methods allows resulting elemental indexes extracted like matrix, even though ’s matrix. (Note indexes four businesses, five, fifth business never reports prices; seen another example, elemental index can made business small change call elemental_index().) elemental indexes way, ’s time make price-index aggregation structure maps business position aggregation hierarchy. hiccup unpacking digit-wise classification businesses defines hierarchy. ’s job expand_classification() function. now simple aggregate elemental indexes according aggregation structure aggregate() function. elemental indexes, missing values ignored setting na.rm = TRUE, equivalent parentally imputing missing values. Note , unlike elemental indexes, missing values filled ensure index can chained time. Although simple, example covers core functionality piar. remaining examples vignette build one adding complexities often arise practice.","code":"library(piar)  head(ms_prices) #>   period business product price #> 1 202001       B1       1  1.14 #> 2 202001       B1       2    NA #> 3 202001       B1       3  6.09 #> 4 202001       B2       4  6.23 #> 5 202001       B2       5  8.61 #> 6 202001       B2       6  6.40  ms_weights #>   business classification weight #> 1       B1             11    553 #> 2       B2             11    646 #> 3       B3             11    312 #> 4       B4             12    622 #> 5       B5             12    330 relatives <- with(   ms_prices,   price_relative(price, period = period, product = product) )  ms_elemental <- with(   ms_prices,   elemental_index(relatives, period = period, ea = business, na.rm = TRUE) )  ms_elemental #> Period-over-period price index for 4 levels over 4 time periods  #>    202001    202002    202003   202004 #> B1      1 0.8949097 0.3342939      NaN #> B2      1       NaN       NaN 2.770456 #> B3      1 2.0200036 1.6353355 0.537996 #> B4    NaN       NaN       NaN 4.576286 ms_elemental[, \"202004\"] #> Period-over-period price index for 4 levels over 1 time periods  #>      202004 #> B1      NaN #> B2 2.770456 #> B3 0.537996 #> B4 4.576286  ms_elemental[\"B1\", ] #> Period-over-period price index for 1 levels over 4 time periods  #>    202001    202002    202003 202004 #> B1      1 0.8949097 0.3342939    NaN hierarchy <- with(   ms_weights,    c(expand_classification(classification), list(business)) )  pias <- aggregation_structure(hierarchy, weights = ms_weights$weight) ms_index <- aggregate(ms_elemental, pias, na.rm = TRUE)  ms_index #> Period-over-period price index for 8 levels over 4 time periods  #>    202001    202002    202003   202004 #> 1       1 1.3007239 1.0630743 2.734761 #> 11      1 1.3007239 1.0630743 1.574515 #> 12      1 1.3007239 1.0630743 4.576286 #> B1      1 0.8949097 0.3342939 1.574515 #> B2      1 1.3007239 1.0630743 2.770456 #> B3      1 2.0200036 1.6353355 0.537996 #> B4      1 1.3007239 1.0630743 4.576286 #> B5      1 1.3007239 1.0630743 4.576286"},{"path":"https://marberts.github.io/piar/articles/piar.html","id":"chaining","dir":"Articles","previous_headings":"","what":"Chaining","title":"Making price indexes","text":"elemental_index() function makes period--period elemental indexes default, can aggregated make period--period index. Chaining index process taking cumulative product period--period indexes make time series compares prices fixed base period. chain() function can used chain values index object. gives almost result directly manipulating index matrix, except former returns index object (matrix). Chained indexes often need rebased, can done rebase() function. example, rebasing index 202004 base period just requires dividing chained index slice 202004. cases base period average several periods; setting base period second half 2020 just requires averaging index subperiods rebasing.","code":"ms_index_chained <- chain(ms_index)  ms_index_chained #> Fixed-base price index for 8 levels over 4 time periods  #>    202001    202002    202003    202004 #> 1       1 1.3007239 1.3827662 3.7815355 #> 11      1 1.3007239 1.3827662 2.1771866 #> 12      1 1.3007239 1.3827662 6.3279338 #> B1      1 0.8949097 0.2991629 0.4710366 #> B2      1 1.3007239 1.3827662 3.8308934 #> B3      1 2.0200036 3.3033836 1.7772072 #> B4      1 1.3007239 1.3827662 6.3279338 #> B5      1 1.3007239 1.3827662 6.3279338 t(apply(as.matrix(ms_index), 1, cumprod)) #>    202001    202002    202003    202004 #> 1       1 1.3007239 1.3827662 3.7815355 #> 11      1 1.3007239 1.3827662 2.1771866 #> 12      1 1.3007239 1.3827662 6.3279338 #> B1      1 0.8949097 0.2991629 0.4710366 #> B2      1 1.3007239 1.3827662 3.8308934 #> B3      1 2.0200036 3.3033836 1.7772072 #> B4      1 1.3007239 1.3827662 6.3279338 #> B5      1 1.3007239 1.3827662 6.3279338 rebase(ms_index_chained, ms_index_chained[, \"202004\"]) #> Fixed-base price index for 8 levels over 4 time periods  #>       202001    202002    202003 202004 #> 1  0.2644428 0.3439671 0.3656626      1 #> 11 0.4593084 0.5974334 0.6351161      1 #> 12 0.1580295 0.2055527 0.2185178      1 #> B1 2.1229774 1.8998731 0.6351161      1 #> B2 0.2610357 0.3395354 0.3609514      1 #> B3 0.5626806 1.1366169 1.8587499      1 #> B4 0.1580295 0.2055527 0.2185178      1 #> B5 0.1580295 0.2055527 0.2185178      1 rebase(   ms_index_chained,   mean(window(ms_index_chained, \"202003\")) ) #> Fixed-base price index for 8 levels over 4 time periods  #>       202001    202002    202003    202004 #> 1  0.3872740 0.5037366 0.5355095 1.4644905 #> 11 0.5618052 0.7307535 0.7768452 1.2231548 #> 12 0.2593798 0.3373815 0.3586616 1.6413384 #> B1 2.5967299 2.3238388 0.7768452 1.2231548 #> B2 0.3836077 0.4989677 0.5304398 1.4695602 #> B3 0.3936550 0.7951845 1.3003935 0.6996065 #> B4 0.2593798 0.3373815 0.3586616 1.6413384 #> B5 0.2593798 0.3373815 0.3586616 1.6413384"},{"path":"https://marberts.github.io/piar/articles/piar.html","id":"multi-dimensional-aggregation-structures","dir":"Articles","previous_headings":"","what":"Multi-dimensional aggregation structures","title":"Making price indexes","text":"Price indexes often aggregated multiple dimensions. Matched sample indexes use sequential Poisson sampling good example, usually take-take-strata addition , say, industry classification. easiest way deal multiple digit-wise classifications turn one classification. example “stratum” dimension comes “classification” dimension purposes parental imputation. classification can expanded expand_classification() function , just extra instruction say last “digit” classification two characters wide, one. elemental indexes can now aggregated according new aggregation structure. price index many dimensions (e.g., industry, sampling stratum, region), can useful interact classifications different dimensions get possible aggregation structures. aggregated index can re-aggregated get index values dimensions. Continuing example, industry strata structures can interacted get two aggregation structures can used re-aggregate index_sps. resulting indexes can merged together give index includes combinations industry sampling stratum.","code":"ms_weights$stratum <- c(\"TS\", \"TA\", \"TS\", \"TS\", \"TS\")  ms_weights #>   business classification weight stratum #> 1       B1             11    553      TS #> 2       B2             11    646      TA #> 3       B3             11    312      TS #> 4       B4             12    622      TS #> 5       B5             12    330      TS classification_sps <- with(ms_weights, paste0(classification, stratum))  classification_sps #> [1] \"11TS\" \"11TA\" \"11TS\" \"12TS\" \"12TS\" classification_sps <- expand_classification(   classification_sps,   width = c(1, 1, 2) )  pias_sps <- with(   ms_weights,    aggregation_structure(c(classification_sps, list(business)), weight) ) index_sps <- aggregate(ms_elemental, pias_sps, na.rm = TRUE) index_sps #> Period-over-period price index for 11 levels over 4 time periods  #>      202001    202002    202003   202004 #> 1         1 1.3007239 1.0630743 2.684412 #> 11        1 1.3007239 1.0630743 1.492443 #> 12        1 1.3007239 1.0630743 4.576286 #> 11TS      1 1.3007239 1.0630743 0.537996 #> 11TA      1 1.3007239 1.0630743 2.770456 #> 12TS      1 1.3007239 1.0630743 4.576286 #> B1        1 0.8949097 0.3342939 0.537996 #> B2        1 1.3007239 1.0630743 2.770456 #> B3        1 2.0200036 1.6353355 0.537996 #> B4        1 1.3007239 1.0630743 4.576286 #> B5        1 1.3007239 1.0630743 4.576286 interacted_hierarchy <- with(   ms_weights,   interact_classifications(     expand_classification(classification),     expand_classification(stratum)   ) )  pias_sps2 <- lapply(   interacted_hierarchy,   \\(x) aggregation_structure(c(x, ms_weights[\"business\"]), ms_weights$weight) )  index_sps2 <- lapply(pias_sps2, \\(x) aggregate(index_sps, x, include_ea = FALSE)) Reduce(merge, index_sps2) #> Period-over-period price index for 8 levels over 4 time periods  #>       202001   202002   202003   202004 #> 1:T        1 1.300724 1.063074 2.684412 #> 1:TS       1 1.300724 1.063074 2.653820 #> 1:TA       1 1.300724 1.063074 2.770456 #> 11:T       1 1.300724 1.063074 1.492443 #> 12:T       1 1.300724 1.063074 4.576286 #> 11:TS      1 1.300724 1.063074 0.537996 #> 11:TA      1 1.300724 1.063074 2.770456 #> 12:TS      1 1.300724 1.063074 4.576286"},{"path":"https://marberts.github.io/piar/articles/piar.html","id":"matrix-aggregation","dir":"Articles","previous_headings":"","what":"Matrix aggregation","title":"Making price indexes","text":"Aggregating price index can done matrix operation. Although approach less flexible aggregate() method, can considerably faster larger indexes. key turn aggregation structure aggregation matrix. Multiplying matrix matrix fixed-base elemental indexes now computes aggregate index time period.","code":"pias_matrix <- as.matrix(pias) pias_matrix #>           B1        B2        B3        B4        B5 #> 1  0.2245229 0.2622818 0.1266748 0.2525376 0.1339829 #> 11 0.3659828 0.4275314 0.2064858 0.0000000 0.0000000 #> 12 0.0000000 0.0000000 0.0000000 0.6533613 0.3466387 pias_matrix %*% as.matrix(chain(ms_index[ms_weights$business])) #>    202001   202002   202003   202004 #> 1       1 1.300724 1.382766 3.781536 #> 11      1 1.300724 1.382766 2.177187 #> 12      1 1.300724 1.382766 6.327934"},{"path":"https://marberts.github.io/piar/articles/piar.html","id":"computing-the-shadow-of-an-index","dir":"Articles","previous_headings":"","what":"Computing the shadow of an index","title":"Making price indexes","text":"’s often useful determine higher-level index values missing, subsequently get imputed aggregation (.e., compute shadow index). simple ’s elemental index elemental aggregate aggregation structure. idea simply aggregate indicator missingness get matrix gives share missing elemental indexes higher-level index. value 1 means non-missing elemental indexes, value level index imputed parent aggregation structure. value 1 zero means elemental indexes missing, index value level based non-missing elemental indexes. value zero means ’s imputation level index.","code":"ms_elemental2 <- elemental_index(   ms_prices,   relatives ~ period + factor(business, ms_weights$business),   na.rm = TRUE ) pias_matrix <- as.matrix(pias) > 0  pias_matrix %*% is.na(ms_elemental2) / rowSums(pias_matrix) #>    202001    202002    202003    202004 #> 1     0.4 0.6000000 0.6000000 0.4000000 #> 11    0.0 0.3333333 0.3333333 0.3333333 #> 12    1.0 1.0000000 1.0000000 0.5000000"},{"path":"https://marberts.github.io/piar/articles/piar.html","id":"non-parental-imputation-during-aggregation","dir":"Articles","previous_headings":"","what":"Non-parental imputation during aggregation","title":"Making price indexes","text":"Parental imputation usual way impute missing index values aggregation, simple aggregate(). cases, however, business-level index may get imputed value , say, another business, rather entire group businesses. simplest way sort imputation alter elemental indexes prior aggregation. also possible augment aggregation structure imputation layer, complex. Suppose missing index values business B2 imputed 1, rather value group 11. replacement can done index matrix. index can now aggregated usual.","code":"ms_elemental2 <- ms_elemental ms_elemental2[\"B2\", 2:3] <- 1 ms_elemental2 #> Period-over-period price index for 4 levels over 4 time periods  #>    202001    202002    202003   202004 #> B1      1 0.8949097 0.3342939      NaN #> B2      1 1.0000000 1.0000000 2.770456 #> B3      1 2.0200036 1.6353355 0.537996 #> B4    NaN       NaN       NaN 4.576286 aggregate(ms_elemental2, pias, na.rm = TRUE) #> Period-over-period price index for 8 levels over 4 time periods  #>    202001    202002    202003   202004 #> 1       1 1.1721550 1.0400686 2.626560 #> 11      1 1.1721550 1.0400686 1.398142 #> 12      1 1.1721550 1.0400686 4.576286 #> B1      1 0.8949097 0.3342939 1.398142 #> B2      1 1.0000000 1.0000000 2.770456 #> B3      1 2.0200036 1.6353355 0.537996 #> B4      1 1.1721550 1.0400686 4.576286 #> B5      1 1.1721550 1.0400686 4.576286"},{"path":"https://marberts.github.io/piar/articles/piar.html","id":"alternate-index-number-formulas","dir":"Articles","previous_headings":"","what":"Alternate index-number formulas","title":"Making price indexes","text":"default, elemental_index() function calculates Jevons index. Although standard index-number formula making elemental indexes, many types index-numbers possible. Carli index (equally-weighted arithmetic mean price relatives) main competitor Jevons, requires specifying order index r calling elemental_index(). order 1 corresponds arithmetic mean. Coggeshall index (equally-weighted harmonic mean price relatives) another competitor Jevons, seldom used practice. Despite exotic, just easy make specifying order r -1. type mean used aggregate elemental indexes can controlled way call aggregate(). default makes arithmetic index, type generalized-mean index possible. Many superlative indexes can made supplying unequal (usually) time-varying weights making elemental indexes. weights often come information quantities. Tornqvist index popular superlative index-number formula, using average period--period value shares weights geometric mean. tricky part making weights data prices quantities. elemental_index() makes geometric index default, needed make Tornqvist index provide weights.","code":"elemental_index(ms_prices, relatives ~ period + business, na.rm = TRUE, r = 1) #> Period-over-period price index for 4 levels over 4 time periods  #>    202001     202002    202003   202004 #> B1      1  0.8949097 0.3342939      NaN #> B2      1        NaN       NaN 5.155942 #> B3      1 23.7480455 2.4900997 0.607197 #> B4    NaN        NaN       NaN 9.368610 elemental_index(ms_prices, relatives ~ period + business, na.rm = TRUE, r = -1) #> Period-over-period price index for 4 levels over 4 time periods  #>    202001    202002    202003    202004 #> B1      1 0.8949097 0.3342939       NaN #> B2      1       NaN       NaN 1.7205750 #> B3      1 0.6591433 0.8185743 0.4746769 #> B4    NaN       NaN       NaN 2.2353790 ms_prices2 <- transform(ms_prices, quantity = 10 - price) library(gpindex)  tw <- grouped(index_weights(\"Tornqvist\"))  ms_prices2[c(\"back_price\", \"back_quantity\")] <-    ms_prices2[back_period(ms_prices2$period, ms_prices2$product),              c(\"price\", \"quantity\")]  ms_prices2 <- na.omit(ms_prices2) # can't have NAs for Tornqvist weights  ms_prices2$weight <- with(   ms_prices2,   tw(     price, back_price, quantity, back_quantity,     group = interaction(period, business)   ) ) elemental_index(   ms_prices2,   price / back_price ~ period + business,   weights = weight ) #> Period-over-period price index for 4 levels over 4 time periods  #>    202001    202002    202003   202004 #> B1      1 0.8949097 0.3342939      NaN #> B2      1       NaN       NaN 2.165152 #> B3      1 0.9520982 1.5913929 0.542372 #> B4    NaN       NaN       NaN 5.904237"},{"path":"https://marberts.github.io/piar/articles/piar.html","id":"percent-change-contributions","dir":"Articles","previous_headings":"","what":"Percent-change contributions","title":"Making price indexes","text":"’s often convenient decompose index (additive) contribution price relative, also known percent-change contributions. can done work flow previous examples, specifying contrib = TRUE calling elemental_index(). index values, percent-change contributions given level index can extracted matrix. Aggregating elemental indexes automatically aggregates percent-change contributions, extra steps needed elemental indexes made.","code":"ms_elemental <- elemental_index(   ms_prices,   relatives ~ period + business,   contrib = TRUE, na.rm = TRUE ) contrib(ms_elemental) #>   202001     202002     202003 202004 #> 1      0  0.0000000  0.0000000      0 #> 2     NA         NA -0.6657061      0 #> 3      0 -0.1050903         NA     NA contrib(aggregate(ms_elemental, pias, na.rm = TRUE)) #>    202001      202002     202003       202004 #> 1       0  0.00000000  0.0000000  0.000000000 #> 10      0 -0.08782076  0.2731949 -0.078173579 #> 11      0  0.00000000         NA  0.059392635 #> 12      0  0.00000000         NA  1.322915301 #> 2      NA          NA -0.2928098  0.000000000 #> 3       0 -0.06718490         NA           NA #> 4       0          NA         NA -0.018209690 #> 5       0          NA         NA  0.094562963 #> 6       0          NA         NA  0.427935081 #> 7       0  0.51646606 -0.2054665 -0.011177530 #> 8       0  0.01906845  0.1755868 -0.003784845 #> 9       0 -0.07980493  0.1125689 -0.058699008"},{"path":"https://marberts.github.io/piar/articles/piar.html","id":"updating-a-basket","dir":"Articles","previous_headings":"","what":"Updating a basket","title":"Making price indexes","text":"functions piar designed work within “basket”, fancy way saying within given aggregation structure. time, however, aggregation structures change weights used aggregate index get updated, new samples businesses drawn. general approach keep time series going “chain” index across baskets. easier see chain index time simple example just splits ms_prices data two. index first basket can calculate usual. Nothing special needs done make elemental indexes new basket, ’s easier remove index values 1 quarter 3 2020. Aggregating elemental indexes, however, requires aggregation structure. results first example can reproduced simply “price updating” original weights, building aggregation structure usual. produces two sets period--period indexes can stacked together chained.","code":"ms_prices1 <- subset(ms_prices, period <= \"202003\") ms_prices2 <- subset(ms_prices, period >= \"202003\") ms_elemental1 <- elemental_index(   ms_prices1,    price_relative(price, period = period, product = product) ~ period + business,   na.rm = TRUE )  ms_index1 <- aggregate(ms_elemental1, pias, na.rm = TRUE)  ms_index1 #> Period-over-period price index for 8 levels over 3 time periods  #>    202001    202002    202003 #> 1       1 1.3007239 1.0630743 #> 11      1 1.3007239 1.0630743 #> 12      1 1.3007239 1.0630743 #> B1      1 0.8949097 0.3342939 #> B2      1 1.3007239 1.0630743 #> B3      1 2.0200036 1.6353355 #> B4      1 1.3007239 1.0630743 #> B5      1 1.3007239 1.0630743 ms_elemental2 <- ms_prices2 |>   transform(rel = price_relative(price, period = period, product = product)) |>   subset(period > \"202003\") |>   elemental_index(rel ~ period + business, na.rm = TRUE) ms_index2 <- aggregate(ms_elemental2, update(pias, ms_index1), na.rm = TRUE)  ms_index2 #> Period-over-period price index for 8 levels over 1 time periods  #>      202004 #> 1  2.734761 #> 11 1.574515 #> 12 4.576286 #> B1 1.574515 #> B2 2.770456 #> B3 0.537996 #> B4 4.576286 #> B5 4.576286 chain(stack(ms_index1, ms_index2)) #> Fixed-base price index for 8 levels over 4 time periods  #>    202001    202002    202003    202004 #> 1       1 1.3007239 1.3827662 3.7815355 #> 11      1 1.3007239 1.3827662 2.1771866 #> 12      1 1.3007239 1.3827662 6.3279338 #> B1      1 0.8949097 0.2991629 0.4710366 #> B2      1 1.3007239 1.3827662 3.8308934 #> B3      1 2.0200036 3.3033836 1.7772072 #> B4      1 1.3007239 1.3827662 6.3279338 #> B5      1 1.3007239 1.3827662 6.3279338"},{"path":"https://marberts.github.io/piar/articles/piar.html","id":"carry-forward-imputation","dir":"Articles","previous_headings":"","what":"Carry-forward imputation","title":"Making price indexes","text":"previous examples used parental imputation impute missing price relatives calculating elemental indexes, impute missing elemental indexes aggregation. Another common imputation strategy making elemental indexes carry forward previous price impute missing prices, parentally impute missing elemental indexes aggregation. elemental_index() function accepts price relatives input, types imputations can done prior passing price relatives function. Aggregation follows steps previous examples, missing values set ignored order parentally impute missing elemental indexes.","code":"ms_elemental2 <- ms_prices |>   transform(imputed_price = carry_forward(price, period = period, product = product)) |>   elemental_index(     price_relative(imputed_price, period = period, product = product) ~       period + business,     na.rm = TRUE   )  ms_elemental2 #> Period-over-period price index for 4 levels over 4 time periods  #>    202001    202002    202003   202004 #> B1      1 0.8949097 0.5781816 1.000000 #> B2      1 1.0000000 0.1777227 2.770456 #> B3      1 2.0200036 1.6353355 0.537996 #> B4    NaN       NaN       NaN 4.576286 ms_index <- aggregate(ms_elemental2, pias, na.rm = TRUE)   ms_index #> Period-over-period price index for 8 levels over 4 time periods  #>    202001    202002    202003    202004 #> 1       1 1.1721550 0.8082981 2.2653614 #> 11      1 1.1721550 0.8082981 0.8093718 #> 12      1 1.1721550 0.8082981 4.5762862 #> B1      1 0.8949097 0.5781816 1.0000000 #> B2      1 1.0000000 0.1777227 2.7704563 #> B3      1 2.0200036 1.6353355 0.5379960 #> B4      1 1.1721550 0.8082981 4.5762862 #> B5      1 1.1721550 0.8082981 4.5762862"},{"path":"https://marberts.github.io/piar/articles/piar.html","id":"calculating-an-index-from-multiple-sources","dir":"Articles","previous_headings":"","what":"Calculating an index from multiple sources","title":"Making price indexes","text":"examples far built index single source price data. many cases elemental indexes built multiple sources data, either single source data necessary coverage, different index-number formulas employed different elemental aggregates. straightforward merge index objects together, provided ’re time periods. keep example simple, suppose ms_prices split two. Elemental indexes can made groups separately usual recipe. Note data business B4 first two periods, time periods need made explicit. elemental indexes made, can merged together aggregated. slightly complex case input data already price index. example, suppose index values businesses B4 B5 come outside process, taken inputs. required pass pre-existing indexes as_index() cast correct form. won’t affect values, allow merged elemental indexes, aggregated.","code":"ms_prices1 <- subset(ms_prices, business %in% c(\"B1\", \"B2\", \"B3\")) ms_prices2 <- subset(ms_prices, business == \"B4\") ms_elemental1 <- elemental_index(   ms_prices1,   price_relative(price, period = period, product = product) ~ period + business,   na.rm = TRUE )  ms_elemental1 #> Period-over-period price index for 3 levels over 4 time periods  #>    202001    202002    202003   202004 #> B1      1 0.8949097 0.3342939      NaN #> B2      1       NaN       NaN 2.770456 #> B3      1 2.0200036 1.6353355 0.537996  ms_elemental2 <- ms_prices2 |>   transform(period = factor(period, levels = time(ms_elemental1))) |>   elemental_index(     price_relative(price, period = period, product = product) ~ period + business,     na.rm = TRUE   )  ms_elemental2 #> Period-over-period price index for 1 levels over 4 time periods  #>    202001 202002 202003   202004 #> B4    NaN    NaN    NaN 4.576286 aggregate(merge(ms_elemental1, ms_elemental2), pias, na.rm = TRUE) #> Period-over-period price index for 8 levels over 4 time periods  #>    202001    202002    202003   202004 #> 1       1 1.3007239 1.0630743 2.734761 #> 11      1 1.3007239 1.0630743 1.574515 #> 12      1 1.3007239 1.0630743 4.576286 #> B1      1 0.8949097 0.3342939 1.574515 #> B2      1 1.3007239 1.0630743 2.770456 #> B3      1 2.0200036 1.6353355 0.537996 #> B4      1 1.3007239 1.0630743 4.576286 #> B5      1 1.3007239 1.0630743 4.576286 ms_prices2 <- subset(   as.data.frame(aggregate(ms_elemental, pias, na.rm = TRUE)),   level %in% c(\"B4\", \"B5\") )  ms_prices2 #>    period level    value #> 7  202001    B4 1.000000 #> 8  202001    B5 1.000000 #> 15 202002    B4 1.300724 #> 16 202002    B5 1.300724 #> 23 202003    B4 1.063074 #> 24 202003    B5 1.063074 #> 31 202004    B4 4.576286 #> 32 202004    B5 4.576286 ms_elemental2 <- as_index(ms_prices2)  aggregate(merge(ms_elemental1, ms_elemental2), pias, na.rm = TRUE) #> Period-over-period price index for 8 levels over 4 time periods  #>    202001    202002    202003   202004 #> 1       1 1.3007239 1.0630743 2.734761 #> 11      1 1.3007239 1.0630743 1.574515 #> 12      1 1.3007239 1.0630743 4.576286 #> B1      1 0.8949097 0.3342939 1.574515 #> B2      1 1.3007239 1.0630743 2.770456 #> B3      1 2.0200036 1.6353355 0.537996 #> B4      1 1.3007239 1.0630743 4.576286 #> B5      1 1.3007239 1.0630743 4.576286"},{"path":"https://marberts.github.io/piar/articles/piar.html","id":"aggregating-a-paasche-index","dir":"Articles","previous_headings":"","what":"Aggregating a Paasche index","title":"Making price indexes","text":"examples far used single set weights aggregate index. Although far common case, situations aggregation weights change every period. Paasche index notable example, weights aggregation current-period revenue shares period. new tools needed deal time-varying weights stack() unstack() functions. stack() appends later index series onto earlier one levels, whereas unstack() pulls apart index series many periods collection one-period indexes. first step making Paasche index unstack elemental indexes list elemental indexes period. (Trying make elemental indexes period--period can dangerous missing values.) second step make sequence aggregation structures set weights. Making Paasche index period now just case mapping aggregate() function elemental index aggregation structure, reducing result stack() function.","code":"weights <- data.frame(   period = rep(c(\"202001\", \"202002\", \"202003\", \"202004\"), each = 5),   classification = ms_weights$classification,   weight = 1:20 )  head(weights) #>   period classification weight #> 1 202001             11      1 #> 2 202001             11      2 #> 3 202001             11      3 #> 4 202001             12      4 #> 5 202001             12      5 #> 6 202002             11      6 ms_elemental <- unstack(ms_elemental)  ms_elemental #> $`202001` #> Period-over-period price index for 4 levels over 1 time periods  #>    202001 #> B1      1 #> B2      1 #> B3      1 #> B4    NaN #>  #> $`202002` #> Period-over-period price index for 4 levels over 1 time periods  #>       202002 #> B1 0.8949097 #> B2       NaN #> B3 2.0200036 #> B4       NaN #>  #> $`202003` #> Period-over-period price index for 4 levels over 1 time periods  #>       202003 #> B1 0.3342939 #> B2       NaN #> B3 1.6353355 #> B4       NaN #>  #> $`202004` #> Period-over-period price index for 4 levels over 1 time periods  #>      202004 #> B1      NaN #> B2 2.770456 #> B3 0.537996 #> B4 4.576286 pias <- with(   weights,    Map(aggregation_structure, list(hierarchy), split(weight, period)) ) paasche <- Reduce(   stack,   Map(aggregate, ms_elemental, pias, na.rm = TRUE, r = -1) )  paasche #> Period-over-period price index for 8 levels over 4 time periods  #>    202001    202002    202003    202004 #> 1       1 1.3127080 0.5874490 1.3591916 #> 11      1 1.3127080 0.5874490 0.8839797 #> 12      1 1.3127080 0.5874490 4.5762862 #> B1      1 0.8949097 0.3342939 0.8839797 #> B2      1 1.3127080 0.5874490 2.7704563 #> B3      1 2.0200036 1.6353355 0.5379960 #> B4      1 1.3127080 0.5874490 4.5762862 #> B5      1 1.3127080 0.5874490 4.5762862"},{"path":"https://marberts.github.io/piar/articles/piar.html","id":"making-a-fisher-index","dir":"Articles","previous_headings":"","what":"Making a Fisher index","title":"Making price indexes","text":"Paasche index hand, now trivial make Fisher index first making period--period Laspeyres index, simple matrix operation. Percent-change contributions can similarly computed matrix operation. Despite matrix, resulting Fisher index can chained just like index. chained Fisher index can also made first chaining Laspeyres Paasche indexes, taking geometric mean.","code":"laspeyres <- Reduce(   stack,   Map(aggregate, ms_elemental, pias[c(1, 1, 2, 3)], na.rm = TRUE) )  fisher <- sqrt(as.matrix(laspeyres) * as.matrix(paasche))  fisher #>    202001    202002    202003   202004 #> 1       1 1.5107763 0.7956890 1.996688 #> 11      1 1.5107763 0.7956890 1.192826 #> 12      1 1.5107763 0.7956890 4.576286 #> B1      1 0.8949097 0.3342939 1.192826 #> B2      1 1.5107763 0.7956890 2.770456 #> B3      1 2.0200036 1.6353355 0.537996 #> B4      1 1.5107763 0.7956890 4.576286 #> B5      1 1.5107763 0.7956890 4.576286 geometric_weights <- transmute_weights(0, 1)  w <- mapply(   \\(x, y) scale_weights(geometric_weights(c(x, y))),   as.numeric(laspeyres[1]),   as.numeric(paasche[1]) )  laspeyres_contrib <- contrib(laspeyres) paasche_contrib <- contrib(paasche)  fisher_contrib <- w[1, col(laspeyres_contrib)] * laspeyres_contrib +   w[2, col(paasche_contrib)] * paasche_contrib  fisher_contrib #>    202001      202002      202003       202004 #> 1       0  0.00000000  0.00000000  0.000000000 #> 10      0 -0.13327742  0.17296129 -0.131946938 #> 11      0  0.00000000          NA  0.039533034 #> 12      0  0.00000000          NA  0.880561300 #> 2      NA          NA -0.42962331  0.000000000 #> 3       0 -0.04756479          NA           NA #> 4       0          NA          NA -0.012019870 #> 5       0          NA          NA  0.062419211 #> 6       0          NA          NA  0.282471798 #> 7       0  0.78379264 -0.13008203 -0.018866231 #> 8       0  0.02893842  0.11116498 -0.006388331 #> 9       0 -0.12111255  0.07126804 -0.099076370 chain(fisher) #> Fixed-base price index for 8 levels over 4 time periods  #>    202001    202002    202003    202004 #> 1       1 1.5107763 1.2021080 2.4002342 #> 11      1 1.5107763 1.2021080 1.4339054 #> 12      1 1.5107763 1.2021080 5.5011904 #> B1      1 0.8949097 0.2991629 0.3568492 #> B2      1 1.5107763 1.2021080 3.3303878 #> B3      1 2.0200036 3.3033836 1.7772072 #> B4      1 1.5107763 1.2021080 5.5011904 #> B5      1 1.5107763 1.2021080 5.5011904 sqrt(as.matrix(chain(laspeyres)) * as.matrix(chain(paasche))) #>    202001    202002    202003    202004 #> 1       1 1.5107763 1.2021080 2.4002342 #> 11      1 1.5107763 1.2021080 1.4339054 #> 12      1 1.5107763 1.2021080 5.5011904 #> B1      1 0.8949097 0.2991629 0.3568492 #> B2      1 1.5107763 1.2021080 3.3303878 #> B3      1 2.0200036 3.3033836 1.7772072 #> B4      1 1.5107763 1.2021080 5.5011904 #> B5      1 1.5107763 1.2021080 5.5011904"},{"path":"https://marberts.github.io/piar/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Steve Martin. Author, maintainer, copyright holder.","code":""},{"path":"https://marberts.github.io/piar/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Martin S (2024). “piar: Price Index Aggregation R.” Journal Open Source Software, 9(101), 6781. doi:10.21105/joss.06781. Martin S (2024). piar: Price Index Aggregation. doi:10.5281/zenodo.10110046, R package version 0.8.1.9002, https://cran.r-project.org/package=piar.","code":"@Article{,   title = {{piar}: Price Index Aggregation R},   author = {Steve Martin},   year = {2024},   doi = {10.21105/joss.06781},   journal = {Journal of Open Source Software},   volume = {9},   number = {101},   pages = {6781}, } @Manual{,   title = {{piar}: Price Index Aggregation},   author = {Steve Martin},   year = {2024},   doi = {10.5281/zenodo.10110046},   url = {https://cran.r-project.org/package=piar},   note = {R package version 0.8.1.9002}, }"},{"path":"https://marberts.github.io/piar/index.html","id":"price-index-aggregation-in-r-","dir":"","previous_headings":"","what":"Price Index Aggregation","title":"Price Index Aggregation","text":"price indexes made two-step procedure, period--period elemental indexes first calculated collection elemental aggregates point time, aggregated according price index aggregation structure. indexes can chained together form time series gives evolution prices respect fixed base period. package contains collection functions revolve around work flow, making easy build standard price indexes, implement methods described Balk (2008), von der Lippe (2007), CPI manual (2020) bilateral price indexes. tools package designed useful researching new sources data methods construct price indexes, regular production price statistics. targeted towards economists, statisticians, data scientists working national statistical agencies, central banks, financial institutions, academia want measure study evolution prices time.","code":""},{"path":"https://marberts.github.io/piar/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Price Index Aggregation","text":"Get stable version CRAN. development version can installed R-Universe directly Github.","code":"install.packages(\"piar\") install.packages(\"piar\", repos = c(\"https://marberts.r-universe.dev\", \"https://cloud.r-project.org\")) pak::pak(\"marberts/piar\")"},{"path":"https://marberts.github.io/piar/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Price Index Aggregation","text":"detailed vignette showing use piar: browseVignettes(\"piar\"). basic work flow fairly simple. starting point make period--period elemental price indexes elemental_index() function. aggregation structure. aggregate() method can used aggregate elemental indexes according aggregation structure (first three rows ) fill missing elemental indexes maintaining consistency aggregation. variety methods work index objects, chaining time.","code":"library(piar)  # Make Jevons business-level elemental indexes  head(ms_prices) #>   period business product price #> 1 202001       B1       1  1.14 #> 2 202001       B1       2    NA #> 3 202001       B1       3  6.09 #> 4 202001       B2       4  6.23 #> 5 202001       B2       5  8.61 #> 6 202001       B2       6  6.40  elementals <- ms_prices |>   transform(     relative = price_relative(price, period = period, product = product)   ) |>   elemental_index(relative ~ period + business, na.rm = TRUE)  elementals #> Period-over-period price index for 4 levels over 4 time periods  #>    202001    202002    202003   202004 #> B1      1 0.8949097 0.3342939      NaN #> B2      1       NaN       NaN 2.770456 #> B3      1 2.0200036 1.6353355 0.537996 #> B4    NaN       NaN       NaN 4.576286 # Make an aggregation structure from businesses to higher-level # industrial classifications  ms_weights #>   business classification weight #> 1       B1             11    553 #> 2       B2             11    646 #> 3       B3             11    312 #> 4       B4             12    622 #> 5       B5             12    330  ms_weights[c(\"level1\", \"level2\")] <-   expand_classification(ms_weights$classification)  pias <- ms_weights[c(\"level1\", \"level2\", \"business\", \"weight\")]  pias #>   level1 level2 business weight #> 1      1     11       B1    553 #> 2      1     11       B2    646 #> 3      1     11       B3    312 #> 4      1     12       B4    622 #> 5      1     12       B5    330 # Aggregate elemental indexes with an arithmetic index  index <- aggregate(elementals, pias, na.rm = TRUE)  # Chain them to get a time series  chain(index) #> Fixed-base price index for 8 levels over 4 time periods  #>    202001    202002    202003    202004 #> 1       1 1.3007239 1.3827662 3.7815355 #> 11      1 1.3007239 1.3827662 2.1771866 #> 12      1 1.3007239 1.3827662 6.3279338 #> B1      1 0.8949097 0.2991629 0.4710366 #> B2      1 1.3007239 1.3827662 3.8308934 #> B3      1 2.0200036 3.3033836 1.7772072 #> B4      1 1.3007239 1.3827662 6.3279338 #> B5      1 1.3007239 1.3827662 6.3279338"},{"path":"https://marberts.github.io/piar/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Price Index Aggregation","text":"contributions welcome. Please start opening issue GitHub report bugs suggest improvements new features. See contribution guidelines project information.","code":""},{"path":"https://marberts.github.io/piar/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Price Index Aggregation","text":"Balk, B. M. (2008). Price Quantity Index Numbers. Cambridge University Press. Chiru, R., Huang, N., Lequain, M. Smith, P., Wright, . (2015). Canadian Consumer Price Index Reference Paper, Statistics Canada catalogue 62-553-X. Statistics Canada. IMF, ILO, Eurostat, UNECE, OECD, World Bank. (2020). Consumer Price Index Manual: Concepts Methods. International Monetary Fund. von der Lippe, P. (2007). Index Theory Price Statistics. Peter Lang.","code":""},{"path":"https://marberts.github.io/piar/reference/aggregate.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregate elemental price indexes — aggregate.piar_index","title":"Aggregate elemental price indexes — aggregate.piar_index","text":"Aggregate elemental price indexes price index aggregation structure.","code":""},{"path":"https://marberts.github.io/piar/reference/aggregate.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregate elemental price indexes — aggregate.piar_index","text":"","code":"# S3 method for class 'chainable_piar_index' aggregate(   x,   pias,   ...,   na.rm = FALSE,   contrib = TRUE,   r = 1,   include_ea = TRUE )  # S3 method for class 'direct_piar_index' aggregate(   x,   pias,   ...,   na.rm = FALSE,   contrib = TRUE,   r = 1,   include_ea = TRUE )"},{"path":"https://marberts.github.io/piar/reference/aggregate.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregate elemental price indexes — aggregate.piar_index","text":"x price index, usually made elemental_index(). pias price index aggregation structure something can coerced one. can made aggregation_structure(). ... currently used. na.rm missing values removed? default, missing values removed. Setting na.rm = TRUE equivalent overall mean imputation. contrib Aggregate percent-change contributions x ()? r Order generalized mean aggregate index values. 0 geometric index (default making elemental indexes), 1 arithmetic index (default aggregating elemental indexes averaging indexes subperiods), -1 harmonic index (usually Paasche index). values possible; see gpindex::generalized_mean() details. include_ea indexes elemental aggregates included along aggregated indexes? default, index values returned.","code":""},{"path":"https://marberts.github.io/piar/reference/aggregate.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregate elemental price indexes — aggregate.piar_index","text":"aggregate price index inherits class x.","code":""},{"path":"https://marberts.github.io/piar/reference/aggregate.piar_index.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Aggregate elemental price indexes — aggregate.piar_index","text":"aggregate() method loops time period x aggregates elemental indexes gpindex::generalized_mean(r)() level pias; aggregates percent-change contributions level pias (contrib = TRUE); price updates weights pias gpindex::factor_weights(r)() (period--period elemental indexes). result collection aggregated period--period indexes can chained together get fixed-base index x period--period elemental indexes. Otherwise, x fixed-base elemental indexes, result collection aggregated fixed-base (direct) indexes. default, missing elemental indexes propagate aggregating index. Missing elemental indexes can due missingness values x, presence elemental aggregates pias part x. Setting na.rm = TRUE ignores missing values, equivalent parental (overall mean) imputation. aggregated price index generally missing values (otherwise chained time weights price updated), missing values level pias removed recursively replaced value immediate parent. cases aggregation done arithmetic mean (default), detailed chapter 8 (pp. 190–198) CPI manual (2020). Aggregating non-arithmetic mean follows steps, except elemental indexes aggregated mean different order (e.g., harmonic Paasche index), method price updating weights slightly different. Note , aggregation done generalized mean, resulting index consistent--aggregation point time. Aggregating percent-change contributions uses method chapter 9 CPI manual (equations 9.26 9.28) aggregating arithmetic mean. non-arithmetic mean, arithmetic weights constructed using gpindex::transmute_weights(r, 1)() order apply method. may contributions prices relatives elemental aggregate elemental indexes built several sources (merge()). case contribution price relative aggregated index correct, sum contributions equal change value index. can also happen aggregating already aggregated index missing index values imputed (.e., na.rm = TRUE contrib = FALSE).","code":""},{"path":"https://marberts.github.io/piar/reference/aggregate.piar_index.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Aggregate elemental price indexes — aggregate.piar_index","text":"large indexes can much faster turn aggregation structure aggregation matrix .matrix(), aggregate elemental indexes matrix operation missing values. See examples details.","code":""},{"path":"https://marberts.github.io/piar/reference/aggregate.piar_index.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Aggregate elemental price indexes — aggregate.piar_index","text":"Balk, B. M. (2008). Price Quantity Index Numbers. Cambridge University Press. IMF, ILO, OECD, Eurostat, UNECE, World Bank. (2020). Consumer Price Index Manual: Concepts Methods. International Monetary Fund. von der Lippe, P. (2007). Index Theory Price Statistics. Peter Lang.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/aggregate.piar_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregate elemental price indexes — aggregate.piar_index","text":"","code":"prices <- data.frame(   rel = 1:8,   period = rep(1:2, each = 4),   ea = rep(letters[1:2], 4) )  # A two-level aggregation structure  pias <- aggregation_structure(   list(c(\"top\", \"top\", \"top\"), c(\"a\", \"b\", \"c\")), weights = 1:3 )  # Calculate Jevons elemental indexes  (elemental <- elemental_index(prices, rel ~ period + ea)) #> Period-over-period price index for 2 levels over 2 time periods  #>          1        2 #> a 1.732051 5.916080 #> b 2.828427 6.928203  # Aggregate (note the imputation for elemental index 'c')  (index <- aggregate(elemental, pias, na.rm = TRUE)) #> Period-over-period price index for 4 levels over 2 time periods  #>            1        2 #> top 2.462968 6.690949 #> a   1.732051 5.916080 #> b   2.828427 6.928203 #> c   2.462968 6.690949  # Aggregation can equivalently be done as matrix multiplication  as.matrix(pias) %*% as.matrix(chain(index[letters[1:3]])) #>            1       2 #> top 2.462968 16.4796"},{"path":"https://marberts.github.io/piar/reference/aggregation_structure.html","id":null,"dir":"Reference","previous_headings":"","what":"Make a price index aggregation structure — aggregation_structure","title":"Make a price index aggregation structure — aggregation_structure","text":"Create price index aggregation structure hierarchical classification aggregation weights can used aggregate elemental indexes.","code":""},{"path":"https://marberts.github.io/piar/reference/aggregation_structure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make a price index aggregation structure — aggregation_structure","text":"","code":"aggregation_structure(x, weights = NULL)"},{"path":"https://marberts.github.io/piar/reference/aggregation_structure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make a price index aggregation structure — aggregation_structure","text":"x list character vectors give codes/labels level classification, ordered moving list goes hierarchy. last vector gives elemental aggregates, duplicates. vectors length, without NAs, duplicates across different levels x. weights numeric vector aggregation weights elemental aggregates (.e., last vector x), something can coerced one. default give elemental aggregate weight.","code":""},{"path":"https://marberts.github.io/piar/reference/aggregation_structure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make a price index aggregation structure — aggregation_structure","text":"price index aggregation structure class piar_aggregation_structure. list-S3 class following components. child nested list gives positions immediate children node level aggregation structure terminal nodes. parent list gives position immediate parent node aggregation structure initial nodes. levels list character vectors give levels x. weights vector giving weight elemental aggregate.","code":""},{"path":"https://marberts.github.io/piar/reference/aggregation_structure.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"Make a price index aggregation structure — aggregation_structure","text":"aggregation_structure() function best check arguments, expectation result aggregation_structure() make sense x represent nested hierarchy.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/aggregation_structure.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make a price index aggregation structure — aggregation_structure","text":"","code":"# A simple aggregation structure #            1 #      |-----+-----| #      11          12 #  |---+---|       | #  111     112     121 #  (1)     (3)     (4)  aggregation_weights <- data.frame(   level1 = c(\"1\", \"1\", \"1\"),   level2 = c(\"11\", \"11\", \"12\"),   ea     = c(\"111\", \"112\", \"121\"),   weight = c(1, 3, 4) )  aggregation_structure(   aggregation_weights[1:3],   weights = aggregation_weights[[4]] ) #> Aggregation structure for 3 elemental aggregates with 2 levels above the elemental aggregates  #>   level1 level2  ea weight #> 1      1     11 111      1 #> 2      1     11 112      3 #> 3      1     12 121      4  # The aggregation structure can also be made by expanding the # elemental aggregates  with(   aggregation_weights,   aggregation_structure(expand_classification(ea), weight) ) #> Aggregation structure for 3 elemental aggregates with 2 levels above the elemental aggregates  #>   level1 level2  ea weight #> 1      1     11 111      1 #> 2      1     11 112      3 #> 3      1     12 121      4"},{"path":"https://marberts.github.io/piar/reference/as.data.frame.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce an index into a tabular form — as.data.frame.piar_index","title":"Coerce an index into a tabular form — as.data.frame.piar_index","text":"Turn index data frame matrix.","code":""},{"path":"https://marberts.github.io/piar/reference/as.data.frame.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce an index into a tabular form — as.data.frame.piar_index","text":"","code":"# S3 method for class 'piar_index' as.data.frame(x, ..., stringsAsFactors = FALSE)  # S3 method for class 'piar_index' as.matrix(x, ...)"},{"path":"https://marberts.github.io/piar/reference/as.data.frame.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce an index into a tabular form — as.data.frame.piar_index","text":"x price index, made , e.g., elemental_index(). ... currently used. stringsAsFactors See .data.frame().","code":""},{"path":"https://marberts.github.io/piar/reference/as.data.frame.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce an index into a tabular form — as.data.frame.piar_index","text":".data.frame() returns index values x data frame three columns: period, level, value. .matrix() returns index values x matrix row level column time period x.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/as.data.frame.piar_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce an index into a tabular form — as.data.frame.piar_index","text":"","code":"index <- as_index(matrix(1:6, 2))  as.data.frame(index) #>   period level value #> 1      1     1     1 #> 2      1     2     2 #> 3      2     1     3 #> 4      2     2     4 #> 5      3     1     5 #> 6      3     2     6  as.matrix(index) #>   1 2 3 #> 1 1 3 5 #> 2 2 4 6"},{"path":"https://marberts.github.io/piar/reference/as.matrix.piar_aggregation_structure.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce an aggregation structure into a tabular form — as.matrix.piar_aggregation_structure","title":"Coerce an aggregation structure into a tabular form — as.matrix.piar_aggregation_structure","text":"Coerce price index aggregation structure aggregation matrix, data frame.","code":""},{"path":"https://marberts.github.io/piar/reference/as.matrix.piar_aggregation_structure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce an aggregation structure into a tabular form — as.matrix.piar_aggregation_structure","text":"","code":"# S3 method for class 'piar_aggregation_structure' as.matrix(x, ..., sparse = FALSE)  # S3 method for class 'piar_aggregation_structure' as.data.frame(x, ..., stringsAsFactors = FALSE)"},{"path":"https://marberts.github.io/piar/reference/as.matrix.piar_aggregation_structure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce an aggregation structure into a tabular form — as.matrix.piar_aggregation_structure","text":"x price index aggregation structure, made aggregation_structure(). ... currently used. sparse result sparse matrix Matrix? faster large aggregation structures. default returns ordinary dense matrix. stringsAsFactors See .data.frame().","code":""},{"path":"https://marberts.github.io/piar/reference/as.matrix.piar_aggregation_structure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce an aggregation structure into a tabular form — as.matrix.piar_aggregation_structure","text":".matrix() represents aggregation structure matrix, multiplying (column) vector elemental indexes gives aggregated index. .data.frame() takes aggregation structure returns data frame generated , columns level1, level2, ..., ea, weight.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/as.matrix.piar_aggregation_structure.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce an aggregation structure into a tabular form — as.matrix.piar_aggregation_structure","text":"","code":"# A simple aggregation structure #            1 #      |-----+-----| #      11          12 #  |---+---|       | #  111     112     121 #  (1)     (3)     (4)  aggregation_weights <- data.frame(   level1 = c(\"1\", \"1\", \"1\"),   level2 = c(\"11\", \"11\", \"12\"),   ea     = c(\"111\", \"112\", \"121\"),   weight = c(1, 3, 4) )  pias <- as_aggregation_structure(aggregation_weights)  as.matrix(pias) #>      111   112 121 #> 1  0.125 0.375 0.5 #> 11 0.250 0.750 0.0 #> 12 0.000 0.000 1.0  all.equal(as.data.frame(pias), aggregation_weights) #> [1] TRUE"},{"path":"https://marberts.github.io/piar/reference/as_aggregation_structure.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to an aggregation structure — as_aggregation_structure","title":"Coerce to an aggregation structure — as_aggregation_structure","text":"Coerce object aggregation structure object.","code":""},{"path":"https://marberts.github.io/piar/reference/as_aggregation_structure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to an aggregation structure — as_aggregation_structure","text":"","code":"as_aggregation_structure(x, ...)  # Default S3 method as_aggregation_structure(x, ..., weights = NULL)  # S3 method for class 'data.frame' as_aggregation_structure(x, ...)  # S3 method for class 'matrix' as_aggregation_structure(x, ...)"},{"path":"https://marberts.github.io/piar/reference/as_aggregation_structure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to an aggregation structure — as_aggregation_structure","text":"x object coerce aggregation structure. ... arguments passed used methods. weights numeric vector aggregation weights elemental aggregates. default give elemental aggregate weight.","code":""},{"path":"https://marberts.github.io/piar/reference/as_aggregation_structure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to an aggregation structure — as_aggregation_structure","text":"price index aggregation structure inherits piar_aggregation_structure.","code":""},{"path":"https://marberts.github.io/piar/reference/as_aggregation_structure.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Coerce to an aggregation structure — as_aggregation_structure","text":"default method attempts coerce x list prior calling aggregation_structure(). data frame matrix methods treat x table row elemental aggregate, column labels level aggregation structure, column weights elemental aggregates.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/as_aggregation_structure.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce to an aggregation structure — as_aggregation_structure","text":"","code":"# A simple aggregation structure #            1 #      |-----+-----| #      11          12 #  |---+---|       | #  111     112     121 #  (1)     (3)     (4)  aggregation_weights <- data.frame(   level1 = c(\"1\", \"1\", \"1\"),   level2 = c(\"11\", \"11\", \"12\"),   ea     = c(\"111\", \"112\", \"121\"),   weight = c(1, 3, 4) )  pias <- aggregation_structure(   aggregation_weights[1:3],   weights = aggregation_weights[[4]] )  all.equal(   pias,   as_aggregation_structure(aggregation_weights) ) #> [1] TRUE  all.equal(   pias,   as_aggregation_structure(as.matrix(aggregation_weights)) ) #> [1] TRUE"},{"path":"https://marberts.github.io/piar/reference/as_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to a price index — as_index","title":"Coerce to a price index — as_index","text":"Coerce pre-computed index values index object.","code":""},{"path":"https://marberts.github.io/piar/reference/as_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to a price index — as_index","text":"","code":"as_index(x, ...)  # Default S3 method as_index(x, ...)  # S3 method for class 'matrix' as_index(x, ..., chainable = TRUE, contrib = FALSE)  # S3 method for class 'data.frame' as_index(x, ...)  # S3 method for class 'chainable_piar_index' as_index(x, ..., chainable = TRUE)  # S3 method for class 'direct_piar_index' as_index(x, ..., chainable = FALSE)"},{"path":"https://marberts.github.io/piar/reference/as_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to a price index — as_index","text":"x object coerce price index. ... arguments passed used methods. chainable index values x period--period indexes, suitable chained calculation (default)? FALSE x fixed-base (direct) index. contrib index values x used construct percent-change contributions? default make contributions.","code":""},{"path":"https://marberts.github.io/piar/reference/as_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to a price index — as_index","text":"price index inherits piar_index. chainable = TRUE period--period price index also inherits chainable_piar_index; otherwise, fixed-base index inherits direct_piar_index.","code":""},{"path":"https://marberts.github.io/piar/reference/as_index.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Coerce to a price index — as_index","text":"Numeric matrices coerced index object treating column separate time period, row separate level index (e.g., elemental aggregate). Column names used denote time periods, row names used denote levels (must unique). essentially reverses calling .matrix() index object. dimension unnamed, given sequential label 1 size dimension. default method coerces x matrix prior using matrix method. data frame method as_index() best understood reversing effect .data.frame() index object. constructs matrix taking levels x[[1]] columns levels x[[2]] rows (coercing factor necessary). populates matrix corresponding values x[[3]], uses matrix method as_index(). x period--period index returned unchanged chainable = TRUE chained otherwise. Similarly, x fixed-base index returned unchanged chainable = FALSE unchain otherwise.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/as_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce to a price index — as_index","text":"","code":"prices <- data.frame(   rel = 1:8,   period = rep(1:2, each = 4),   ea = rep(letters[1:2], 4) )  index <- elemental_index(prices, rel ~ period + ea)  all.equal(as_index(as.data.frame(index)), index) #> [1] TRUE all.equal(as_index(as.matrix(index)), index) #> [1] TRUE"},{"path":"https://marberts.github.io/piar/reference/chain.html","id":null,"dir":"Reference","previous_headings":"","what":"Chain and rebase a price index — chain","title":"Chain and rebase a price index — chain","text":"Chain period--period index taking cumulative product values turn fixed-base (direct) index. Unchain fixed-base index dividing values successive periods get period--period index. Rebase fixed-base index dividing values value index new base period.","code":""},{"path":"https://marberts.github.io/piar/reference/chain.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chain and rebase a price index — chain","text":"","code":"chain(x, ...)  # Default S3 method chain(x, ...)  # S3 method for class 'chainable_piar_index' chain(x, link = rep(1, nlevels(x)), ...)  unchain(x, ...)  # Default S3 method unchain(x, ...)  # S3 method for class 'direct_piar_index' unchain(x, base = rep(1, nlevels(x)), ...)  rebase(x, ...)  # Default S3 method rebase(x, ...)  # S3 method for class 'direct_piar_index' rebase(x, base = rep(1, nlevels(x)), ...)"},{"path":"https://marberts.github.io/piar/reference/chain.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chain and rebase a price index — chain","text":"x price index, made , e.g., elemental_index(). ... arguments passed used methods. link numeric vector, something can coerced one, link values level x. default vector 1s linking done. base numeric vector, something can coerced one, base-period index values level x. default vector 1s base period remains . base length-one character vector giving time period x index values time period used base-period values.","code":""},{"path":"https://marberts.github.io/piar/reference/chain.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chain and rebase a price index — chain","text":"chain() rebase() return fixed-base index inherits direct_piar_index. unchain() returns period--period index inherits chainable_piar_index.","code":""},{"path":"https://marberts.github.io/piar/reference/chain.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chain and rebase a price index — chain","text":"default methods attempt coerce x index as_index() prior chaining/unchaining/rebasing. Chaining index takes cumulative product index values level; roughly t(apply(.matrix(x), 1, cumprod)) * link. Unchaining opposite, inverse operations. Note unchaining period--period index nothing, chaining fixed-base index. Rebasing fixed-base index divides values level index corresponding values level new base period. roughly .matrix(x) / base. Like unchaining, rebasing period--period index nothing. Percent-change contributions removed chaining/unchaining/rebasing index usually possible update correctly.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/chain.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chain and rebase a price index — chain","text":"","code":"index <- as_index(matrix(1:9, 3))  # Make period 0 the fixed base period  chain(index) #> Fixed-base price index for 3 levels over 3 time periods  #>   1  2   3 #> 1 1  4  28 #> 2 2 10  80 #> 3 3 18 162  # Chaining and unchaining reverse each other  all.equal(index, unchain(chain(index))) #> [1] TRUE  # Change the base period to period 2 (note the # loss of information for period 0)  index <- chain(index) rebase(index, index[, 2]) #> Fixed-base price index for 3 levels over 3 time periods  #>           1 2 3 #> 1 0.2500000 1 7 #> 2 0.2000000 1 8 #> 3 0.1666667 1 9"},{"path":"https://marberts.github.io/piar/reference/contrib.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract percent-change contributions — contrib","title":"Extract percent-change contributions — contrib","text":"Extract matrix data frame percent-change contributions price index.","code":""},{"path":"https://marberts.github.io/piar/reference/contrib.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract percent-change contributions — contrib","text":"","code":"contrib(x, ...)  # S3 method for class 'piar_index' contrib(x, level = levels(x)[1L], period = time(x), ..., pad = 0)  contrib2DF(x, ...)  # S3 method for class 'piar_index' contrib2DF(x, level = levels(x)[1L], period = time(x), ...)  contrib(x, ...) <- value  # S3 method for class 'piar_index' contrib(x, level = levels(x)[1L], period = time(x), ...) <- value"},{"path":"https://marberts.github.io/piar/reference/contrib.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract percent-change contributions — contrib","text":"x price index, made , e.g., elemental_index(). ... arguments passed used methods. level level index percent-change contributions desired, defaulting first level (usually top-level aggregate index). contrib2DF() can accept multiple levels. period time periods percent-change contributions desired, defaulting time periods. pad numeric value pad contributions fit rectangular array products differ time. default 0. value numeric matrix replacement contributions row product column time period. Recycling occurs along time periods.","code":""},{"path":"https://marberts.github.io/piar/reference/contrib.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract percent-change contributions — contrib","text":"contrib() returns matrix percent-change contributions column period row product (sorted) contributions level. Contributions padded pad fit rectangular array products differ time. replacement methods returns copy x contributions given matrix value. contrib2DF() returns data frame contributions four columns: period, level, product, value.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/contrib.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract percent-change contributions — contrib","text":"","code":"prices <- data.frame(   rel = 1:8,   period = rep(1:2, each = 4),   ea = rep(letters[1:2], 4) )  index <- elemental_index(prices, rel ~ period + ea, contrib = TRUE)  pias <- aggregation_structure(   list(c(\"top\", \"top\", \"top\"), c(\"a\", \"b\", \"c\")), weights = 1:3 )  index <- aggregate(index, pias, na.rm = TRUE)  # Percent-change contributions for the top-level index  contrib(index) #>             1         2 #> a.1 0.0000000 0.5081686 #> a.2 0.2440169 0.6442213 #> b.1 0.3905243 2.0513858 #> b.2 0.8284271 2.4871732  contrib2DF(index) #>   period level product     value #> 1      1   top     a.1 0.0000000 #> 2      1   top     a.2 0.2440169 #> 3      1   top     b.1 0.3905243 #> 4      1   top     b.2 0.8284271 #> 5      2   top     a.1 0.5081686 #> 6      2   top     a.2 0.6442213 #> 7      2   top     b.1 2.0513858 #> 8      2   top     b.2 2.4871732  # Calculate EA contributions for the chained index  library(gpindex)  arithmetic_contributions(   as.matrix(chain(index))[c(\"a\", \"b\", \"c\"), 2],   weights(pias) ) #>        a        b        c  #> 1.541158 6.198639 7.739798"},{"path":"https://marberts.github.io/piar/reference/elemental_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Make elemental/elementary price indexes — elemental_index","title":"Make elemental/elementary price indexes — elemental_index","text":"Compute period--period (chainable) fixed-base (direct) elemental price indexes, optional percent-change contributions product.","code":""},{"path":"https://marberts.github.io/piar/reference/elemental_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make elemental/elementary price indexes — elemental_index","text":"","code":"elemental_index(x, ...)  # Default S3 method elemental_index(x, ...)  # S3 method for class 'numeric' elemental_index(   x,   ...,   period = gl(1, length(x)),   ea = gl(1, length(x)),   weights = NULL,   product = NULL,   chainable = TRUE,   na.rm = FALSE,   contrib = FALSE,   r = 0 )  # S3 method for class 'data.frame' elemental_index(x, formula, ..., weights = NULL, product = NULL)  elementary_index(x, ...)"},{"path":"https://marberts.github.io/piar/reference/elemental_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make elemental/elementary price indexes — elemental_index","text":"x Period--period fixed-base price relatives. Currently methods numeric vectors (can made price_relative()) data frames. ... arguments passed used methods. period factor, something can coerced one, giving time period associated price relative x. ordering time periods follows levels period, agree cut(). default makes index one time period. ea factor, something can coerced one, giving elemental aggregate associated price relative x. default makes index one elemental aggregate. weights numeric vector weights price relatives x, something can coerced one. default equal weights. evaluated x data frame method. product character vector product names, something can coerced one, price relative x making percent-change contributions. default uses names x, ; otherwise, elements x given sequential names within elemental aggregate. evaluated x data frame method. chainable price relatives x period--period relatives suitable chained calculation (default)? FALSE x contains fixed-base relatives. na.rm missing values removed? default, missing values removed. Setting na.rm = TRUE equivalent overall mean imputation. contrib percent-change contributions calculated? default calculate contributions. r Order generalized mean aggregate price relatives. 0 geometric index (default making elemental indexes), 1 arithmetic index (default aggregating elemental indexes averaging indexes subperiods), -1 harmonic index (usually Paasche index). values possible; see gpindex::generalized_mean() details. formula two-sided formula price relatives left-hand side, time periods elemental aggregates (order) right-hand side.","code":""},{"path":"https://marberts.github.io/piar/reference/elemental_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make elemental/elementary price indexes — elemental_index","text":"price index inherits piar_index. chainable = TRUE period--period index also inherits chainable_piar_index; otherwise, fixed-based index inherits direct_piar_index.","code":""},{"path":"https://marberts.github.io/piar/reference/elemental_index.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Make elemental/elementary price indexes — elemental_index","text":"supplied numeric vector, elemental_index() simple wrapper applies gpindex::generalized_mean(r)() gpindex::contributions(r)() (contrib = TRUE) x weights grouped ea period. , every combination elemental aggregate time period, elemental_index() calculates index based generalized mean order r , optionally, percent-change contributions. Product names unique within time period making contributions, , , passed make.unique() warning. default (r = 0 weights) makes Jevons elemental indexes. See chapter 8 (pp. 175–190) CPI manual (2020) detail making elemental indexes, chapter 5 Balk (2008). default method simply coerces x numeric vector prior calling method . data frame method provides formula interface specify columns price relatives, time periods, elemental aggregates call method . interpretation index depends price relatives x made. period--period relatives, result collection period--period (chainable) elemental indexes; fixed-base relatives, result collection fixed-base (direct) elemental indexes. latter, chainable set FALSE subsequent methods assume chained calculation used. default, missing price relatives x propagate throughout index calculation. Ignoring missing values na.rm = TRUE overall mean (parental) imputation, needs explicitly set call elemental_index(). Explicit imputation missing relatives, especially imputation missing prices, done prior calling elemental_index(). Indexes based nested generalized means, like Fisher index (superlative quadratic mean indexes generally), can calculated supplying appropriate weights gpindex::nested_transmute(); see example . important note several ways make weights, affects percent-change contributions calculated. elementary_index() alias elemental_index() common literature.","code":""},{"path":"https://marberts.github.io/piar/reference/elemental_index.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Make elemental/elementary price indexes — elemental_index","text":"Balk, B. M. (2008). Price Quantity Index Numbers. Cambridge University Press. IMF, ILO, OECD, Eurostat, UNECE, World Bank. (2020). Consumer Price Index Manual: Concepts Methods. International Monetary Fund. von der Lippe, P. (2007). Index Theory Price Statistics. Peter Lang.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/elemental_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make elemental/elementary price indexes — elemental_index","text":"","code":"library(gpindex)  prices <- data.frame(   rel = 1:8,   period = rep(1:2, each = 4),   ea = rep(letters[1:2], 4) )  # Calculate Jevons elemental indexes  elemental_index(prices, rel ~ period + ea) #> Period-over-period price index for 2 levels over 2 time periods  #>          1        2 #> a 1.732051 5.916080 #> b 2.828427 6.928203  # Same as using lm() or tapply()  exp(coef(lm(log(rel) ~ ea:factor(period) - 1, prices))) #> eaa:factor(period)1 eab:factor(period)1 eaa:factor(period)2 eab:factor(period)2  #>            1.732051            2.828427            5.916080            6.928203   with(   prices,   t(tapply(rel, list(period, ea), geometric_mean, na.rm = TRUE)) ) #>          1        2 #> a 1.732051 5.916080 #> b 2.828427 6.928203  # A general function to calculate weights to turn the geometric # mean of the arithmetic and harmonic mean (i.e., Fisher mean) # into an arithmetic mean  fw <- grouped(nested_transmute(0, c(1, -1), 1))  # Calculate a CSWD index (same as the Jevons in this example) # as an arithmetic index by using the appropriate weights  elemental_index(   prices,   rel ~ period + ea,   weights = fw(rel, group = interaction(period, ea)),   r = 1 ) #> Period-over-period price index for 2 levels over 2 time periods  #>          1        2 #> a 1.732051 5.916080 #> b 2.828427 6.928203"},{"path":"https://marberts.github.io/piar/reference/expand_classification.html","id":null,"dir":"Reference","previous_headings":"","what":"Expand a hierarchical classification — expand_classification","title":"Expand a hierarchical classification — expand_classification","text":"Expand character representation hierarchical classification make price index aggregation structure. Expanded classifications interacted together get combinations aggregation structures.","code":""},{"path":"https://marberts.github.io/piar/reference/expand_classification.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expand a hierarchical classification — expand_classification","text":"","code":"expand_classification(x, width = 1L)  interact_classifications(..., sep = \":\")"},{"path":"https://marberts.github.io/piar/reference/expand_classification.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expand a hierarchical classification — expand_classification","text":"x character vector, something can coerced one, codes/labels specific level classification (e.g., 5-digit COICOP, 5-digit NAICS, 4-digit SIC). width integer vector gives width digit x. single value recycled span longest element x. contain NAs. default assumes digit width 1, NAICS, NAPCS, SIC classifications. ... Lists character vectors give codes/labels level classification, ordered moving list goes hierarchy (made expand_classification()). sep character used combine codes/labels across elements .... default uses \":\".","code":""},{"path":"https://marberts.github.io/piar/reference/expand_classification.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expand a hierarchical classification — expand_classification","text":"expand_classification() returns list entry level x giving \"digits\" represent level hierarchy. interact_classfications() returns list lists structure expand_classification().","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/expand_classification.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Expand a hierarchical classification — expand_classification","text":"","code":"# A simple classification structure #            1 #      |-----+-----| #      11          12 #  |---+---|       | #  111     112     121  expand_classification(c(\"111\", \"112\", \"121\")) #> [[1]] #> [1] \"1\" \"1\" \"1\" #>  #> [[2]] #> [1] \"11\" \"11\" \"12\" #>  #> [[3]] #> [1] \"111\" \"112\" \"121\" #>   # Expanding more complex classifications # ... if last 'digit' is either TA or TS  expand_classification(   c(\"111TA\", \"112TA\", \"121TS\"),   width = c(1, 1, 1, 2) ) #> [[1]] #> [1] \"1\" \"1\" \"1\" #>  #> [[2]] #> [1] \"11\" \"11\" \"12\" #>  #> [[3]] #> [1] \"111\" \"112\" \"121\" #>  #> [[4]] #> [1] \"111TA\" \"112TA\" \"121TS\" #>   # ... if first 'digit' is either 11 or 12  expand_classification(c(\"111\", \"112\", \"121\"), width = c(2, 1)) #> [[1]] #> [1] \"11\" \"11\" \"12\" #>  #> [[2]] #> [1] \"111\" \"112\" \"121\" #>   # ...if there are delimiters in the classification (like COICOP)  expand_classification(c(\"01.1.1\", \"01.1.2\", \"01.2.1\"), width = 2) #> [[1]] #> [1] \"01\" \"01\" \"01\" #>  #> [[2]] #> [1] \"01.1\" \"01.1\" \"01.2\" #>  #> [[3]] #> [1] \"01.1.1\" \"01.1.2\" \"01.2.1\" #>"},{"path":"https://marberts.github.io/piar/reference/head.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Return the first/last parts of an index — head.piar_index","title":"Return the first/last parts of an index — head.piar_index","text":"Extract first/last parts index matrix.","code":""},{"path":"https://marberts.github.io/piar/reference/head.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return the first/last parts of an index — head.piar_index","text":"","code":"# S3 method for class 'piar_index' head(x, n = 6L, ...)  # S3 method for class 'piar_index' tail(x, n = 6L, ...)"},{"path":"https://marberts.github.io/piar/reference/head.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return the first/last parts of an index — head.piar_index","text":"x price index, made , e.g., elemental_index(). n See head()/tail(). default takes first/last 6 levels x. ... currently used.","code":""},{"path":"https://marberts.github.io/piar/reference/head.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return the first/last parts of an index — head.piar_index","text":"price index inherits class x.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/head.piar_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Return the first/last parts of an index — head.piar_index","text":"","code":"index <- as_index(matrix(1:9, 3))  head(index, 1) #> Period-over-period price index for 1 levels over 3 time periods  #>   1 2 3 #> 1 1 4 7  tail(index, 1) #> Period-over-period price index for 1 levels over 3 time periods  #>   1 2 3 #> 3 3 6 9"},{"path":"https://marberts.github.io/piar/reference/impute_prices.html","id":null,"dir":"Reference","previous_headings":"","what":"Impute missing prices — impute_prices","title":"Impute missing prices — impute_prices","text":"Impute missing prices using carry forward shadow price method.","code":""},{"path":"https://marberts.github.io/piar/reference/impute_prices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Impute missing prices — impute_prices","text":"","code":"shadow_price(x, ...)  # Default S3 method shadow_price(   x,   ...,   period,   product,   ea,   pias = NULL,   weights = NULL,   r1 = 0,   r2 = 1 )  # S3 method for class 'data.frame' shadow_price(x, formula, ..., weights = NULL)  carry_forward(x, ...)  # Default S3 method carry_forward(x, ..., period, product)  # S3 method for class 'data.frame' carry_forward(x, formula, ...)  carry_backward(x, ...)  # Default S3 method carry_backward(x, ..., period, product)  # S3 method for class 'data.frame' carry_backward(x, formula, ...)"},{"path":"https://marberts.github.io/piar/reference/impute_prices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Impute missing prices — impute_prices","text":"x Either numeric vector (something can coerced one) data frame prices. ... arguments passed used methods. period factor, something can coerced one, giving time period associated price x. ordering time periods follows levels period, agree cut(). product factor, something can coerced one, giving product associated price x. ea factor, something can coerced one, giving elemental aggregate associated price x. pias price index aggregation structure, something can coerced one, made aggregation_structure(). default imputes elemental indexes (.e., recursively). weights numeric vector weights prices x (.e., product weights), something can coerced one. default give price equal weight. evaluated x data frame method. r1 Order generalized-mean price index used calculate elemental price indexes: 0 geometric index (default), 1 arithmetic index, -1 harmonic index. values possible; see gpindex::generalized_mean() details. r2 Order generalized-mean price index used aggregate elemental price indexes: 0 geometric index, 1 arithmetic index (default), -1 harmonic index. values possible; see gpindex::generalized_mean() details. formula two-sided formula prices left-hand side. carry_forward() carry_backward(), right-hand side time periods products (order); shadow_price(), right-hand side time period, products, elemental aggregates (order).","code":""},{"path":"https://marberts.github.io/piar/reference/impute_prices.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Impute missing prices — impute_prices","text":"numeric vector prices missing values replaced (possible).","code":""},{"path":"https://marberts.github.io/piar/reference/impute_prices.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Impute missing prices — impute_prices","text":"carry forward method replaces missing price product price product previous period. tends push index value towards 1, usually avoided; see paragraph 6.61 CPI manual (2020). carry backwards method opposite, rarely used practice. shadow price method recursively imputes missing price value price product previous period multiplied value period--period elemental index elemental aggregate product belongs. requires computing aggregating index (according pias, unless pias supplied) period, imputations can take . index values used imputations returned index needs recalculated get correct percent-change contributions. Shadow price imputation referred self-correcting overall mean imputation chapter 6 CPI manual (2020). identical simply excluding missing price relatives index calculation, except period missing product returns. reason care needed using method. sensitive assumption product change time, cases safer simply omit missing price relatives instead imputing missing prices.","code":""},{"path":"https://marberts.github.io/piar/reference/impute_prices.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Impute missing prices — impute_prices","text":"IMF, ILO, OECD, Eurostat, UNECE, World Bank. (2020). Consumer Price Index Manual: Concepts Methods. International Monetary Fund.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/impute_prices.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Impute missing prices — impute_prices","text":"","code":"prices <- data.frame(   price = c(1:7, NA),   period = rep(1:2, each = 4),   product = 1:4,   ea = rep(letters[1:2], 4) )  carry_forward(prices, price ~ period + product) #> [1] 1 2 3 4 5 6 7 4  shadow_price(prices, price ~ period + product + ea) #> [1]  1  2  3  4  5  6  7 12"},{"path":"https://marberts.github.io/piar/reference/is.na.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Missing values in a price index — is.na.piar_index","title":"Missing values in a price index — is.na.piar_index","text":"Identify missing values price index.","code":""},{"path":"https://marberts.github.io/piar/reference/is.na.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Missing values in a price index — is.na.piar_index","text":"","code":"# S3 method for class 'piar_index' is.na(x)  # S3 method for class 'piar_index' anyNA(x, recursive = FALSE)"},{"path":"https://marberts.github.io/piar/reference/is.na.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Missing values in a price index — is.na.piar_index","text":"x price index, made , e.g., elemental_index(). recursive Check x also missing percent-change contributions. default index values checked missingness.","code":""},{"path":"https://marberts.github.io/piar/reference/is.na.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Missing values in a price index — is.na.piar_index","text":".na() returns logical matrix, row level x columns time period, indicates index values missing. anyNA() returns TRUE index values missing, percent-change contributions (recursive = TRUE).","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/is.na.piar_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Missing values in a price index — is.na.piar_index","text":"","code":"index <- as_index(matrix(c(1, 2, 3, NA, 5, NA), 2))  anyNA(index) #> [1] TRUE is.na(index) #>       1     2     3 #> 1 FALSE FALSE FALSE #> 2 FALSE  TRUE  TRUE  # Carry forward imputation  index[is.na(index)] <- 1 index #> Period-over-period price index for 2 levels over 3 time periods  #>   1 2 3 #> 1 1 3 5 #> 2 2 1 1"},{"path":"https://marberts.github.io/piar/reference/is_aggregation_structure.html","id":null,"dir":"Reference","previous_headings":"","what":"Test if an object is an aggregation structure — is_aggregation_structure","title":"Test if an object is an aggregation structure — is_aggregation_structure","text":"Test object price index aggregation structure.","code":""},{"path":"https://marberts.github.io/piar/reference/is_aggregation_structure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test if an object is an aggregation structure — is_aggregation_structure","text":"","code":"is_aggregation_structure(x)"},{"path":"https://marberts.github.io/piar/reference/is_aggregation_structure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test if an object is an aggregation structure — is_aggregation_structure","text":"x object test.","code":""},{"path":"https://marberts.github.io/piar/reference/is_aggregation_structure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test if an object is an aggregation structure — is_aggregation_structure","text":"Returns TRUE x inherits piar_aggregation_structure.","code":""},{"path":"https://marberts.github.io/piar/reference/is_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Test if an object is a price index — is_index","title":"Test if an object is a price index — is_index","text":"Test object index object subclass index object.","code":""},{"path":"https://marberts.github.io/piar/reference/is_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test if an object is a price index — is_index","text":"","code":"is_index(x)  is_chainable_index(x)  is_direct_index(x)"},{"path":"https://marberts.github.io/piar/reference/is_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test if an object is a price index — is_index","text":"x object test.","code":""},{"path":"https://marberts.github.io/piar/reference/is_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test if an object is a price index — is_index","text":"is_index() returns TRUE x inherits piar_index. is_chainable_index() returns TRUE x inherits chainable_piar_index. is_direct_index() returns TRUE x inherits direct_piar_index.","code":""},{"path":"https://marberts.github.io/piar/reference/levels.piar_aggregation_structure.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the levels for an aggregation structure — levels.piar_aggregation_structure","title":"Get the levels for an aggregation structure — levels.piar_aggregation_structure","text":"Get hierarchical list levels aggregation structure. error try replace values.","code":""},{"path":"https://marberts.github.io/piar/reference/levels.piar_aggregation_structure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the levels for an aggregation structure — levels.piar_aggregation_structure","text":"","code":"# S3 method for class 'piar_aggregation_structure' levels(x)"},{"path":"https://marberts.github.io/piar/reference/levels.piar_aggregation_structure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the levels for an aggregation structure — levels.piar_aggregation_structure","text":"x price index aggregation structure, made aggregation_structure().","code":""},{"path":"https://marberts.github.io/piar/reference/levels.piar_aggregation_structure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the levels for an aggregation structure — levels.piar_aggregation_structure","text":"list character vectors giving levels position aggregation structure.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/levels.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the levels for a price index — levels.piar_index","title":"Get the levels for a price index — levels.piar_index","text":"Methods get set levels price index.","code":""},{"path":"https://marberts.github.io/piar/reference/levels.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the levels for a price index — levels.piar_index","text":"","code":"# S3 method for class 'piar_index' levels(x)  # S3 method for class 'piar_index' levels(x) <- value  set_levels()"},{"path":"https://marberts.github.io/piar/reference/levels.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the levels for a price index — levels.piar_index","text":"x price index, made , e.g., elemental_index(). value character vector, something can coerced one, giving replacement levels x.","code":""},{"path":"https://marberts.github.io/piar/reference/levels.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the levels for a price index — levels.piar_index","text":"levels() returns character vector levels price index. replacement method returns copy x levels value.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/mean.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregate a price index over subperiods — mean.piar_index","title":"Aggregate a price index over subperiods — mean.piar_index","text":"Aggregate index subperiods taking (usually arithmetic) mean index values consecutive windows subperiods.","code":""},{"path":"https://marberts.github.io/piar/reference/mean.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregate a price index over subperiods — mean.piar_index","text":"","code":"# S3 method for class 'chainable_piar_index' mean(   x,   ...,   weights = NULL,   window = ntime(x),   na.rm = FALSE,   contrib = TRUE,   r = 1 )  # S3 method for class 'direct_piar_index' mean(   x,   ...,   weights = NULL,   window = ntime(x),   na.rm = FALSE,   contrib = TRUE,   r = 1 )"},{"path":"https://marberts.github.io/piar/reference/mean.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregate a price index over subperiods — mean.piar_index","text":"x price index, made , e.g., elemental_index(). ... currently used. weights numeric vector weights index values x, something can coerced one. default equal weights. usually easiest specify weights matrix row index value x column time period. window positive integer giving size window used average index values across subperiods. default averages periods x. Non-integers truncated towards 0. na.rm missing values removed? default, missing values removed. Setting na.rm = TRUE equivalent overall mean imputation. contrib Aggregate percent-change contributions x ()? r Order generalized mean aggregate index values. 0 geometric index (default making elemental indexes), 1 arithmetic index (default aggregating elemental indexes averaging indexes subperiods), -1 harmonic index (usually Paasche index). values possible; see gpindex::generalized_mean() details.","code":""},{"path":"https://marberts.github.io/piar/reference/mean.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregate a price index over subperiods — mean.piar_index","text":"price index, averaged subperiods, inherits class x.","code":""},{"path":"https://marberts.github.io/piar/reference/mean.piar_index.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Aggregate a price index over subperiods — mean.piar_index","text":"mean() method constructs set non-overlapping windows length window, starting first period index, takes mean index value windows level index. last window discarded incomplete (warning), index values always averaged window periods. names first time period window form new names aggregated time periods. Percent-change contributions aggregated contrib = TRUE treating product-subperiod pair unique product, following approach aggregate(). number subperiod appended product names make unique across subperiods. optional vector weights can specified aggregating index values subperiods, often useful aggregating Paasche index; see section 4.3 Balk (2008) details.","code":""},{"path":"https://marberts.github.io/piar/reference/mean.piar_index.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Aggregate a price index over subperiods — mean.piar_index","text":"Balk, B. M. (2008). Price Quantity Index Numbers. Cambridge University Press.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/mean.piar_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregate a price index over subperiods — mean.piar_index","text":"","code":"index <- as_index(matrix(c(1:12, 12:1), 2, byrow = TRUE))  # Turn a monthly index into a quarterly index mean(index, window = 3) #> Period-over-period price index for 2 levels over 4 time periods  #>    1 4 7 10 #> 1  2 5 8 11 #> 2 11 8 5  2"},{"path":"https://marberts.github.io/piar/reference/merge.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge price indexes — merge.piar_index","title":"Merge price indexes — merge.piar_index","text":"Combine two price indexes common time periods, merging together index values percent-change contributions time period. useful building index different elemental aggregates come different sources data, use different index-number formulas.","code":""},{"path":"https://marberts.github.io/piar/reference/merge.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge price indexes — merge.piar_index","text":"","code":"# S3 method for class 'chainable_piar_index' merge(x, y, ...)  # S3 method for class 'direct_piar_index' merge(x, y, ...)"},{"path":"https://marberts.github.io/piar/reference/merge.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge price indexes — merge.piar_index","text":"x price index, made , e.g., elemental_index(). y price index, something can coerced one. x period--period index y coerced chainable index; otherwise, y coerced direct index. ... currently used.","code":""},{"path":"https://marberts.github.io/piar/reference/merge.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge price indexes — merge.piar_index","text":"combined price index inherits class x.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/merge.piar_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Merge price indexes — merge.piar_index","text":"","code":"index1 <- as_index(matrix(1:6, 2))  index2 <- index1 levels(index2) <- 3:4  merge(index1, index2) #> Period-over-period price index for 4 levels over 3 time periods  #>   1 2 3 #> 1 1 3 5 #> 2 2 4 6 #> 3 1 3 5 #> 4 2 4 6"},{"path":"https://marberts.github.io/piar/reference/piar-package.html","id":null,"dir":"Reference","previous_headings":"","what":"piar: Price Index Aggregation — piar-package","title":"piar: Price Index Aggregation — piar-package","text":"price indexes made two-step procedure, period--period elemental indexes first calculated collection elemental aggregates point time, aggregated according price index aggregation structure. indexes can chained together form time series gives evolution prices respect fixed base period. package contains collection functions revolve around work flow, making easy build standard price indexes, implement methods described Balk (2008, doi:10.1017/CBO9780511720758 ), von der Lippe (2007, doi:10.3726/978-3-653-01120-3 ), CPI manual (2020, doi:10.5089/9781484354841.069 ) bilateral price indexes.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/piar-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"piar: Price Index Aggregation — piar-package","text":"Maintainer: Steve Martin marberts@protonmail.com (ORCID) [copyright holder]","code":""},{"path":"https://marberts.github.io/piar/reference/piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Price index objects — piar_index","title":"Price index objects — piar_index","text":"several classes represent price indexes. indexes inherit piar_index virtual class. Period--period indexes can chained time inherit chainable_piar_index. Fixed-base indexes inherit direct_piar_index.","code":""},{"path":"https://marberts.github.io/piar/reference/piar_index.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Price index objects — piar_index","text":"piar_index object list-S3 class following components: index list entry period time gives vector index values level levels. contrib list entry period time, contains list entry level levels named vector gives percent-change contribution price relative. levels character vector giving levels index. time character vector giving time periods index. chainable_piar_index direct_piar_index subclasses structure piar_index class, differ methods used manipulate indexes.","code":""},{"path":"https://marberts.github.io/piar/reference/price_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Price data — price_data","title":"Price data — price_data","text":"Sample price weight data match sample fixed sample type index.","code":""},{"path":"https://marberts.github.io/piar/reference/price_relative.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate period-over-period price relatives — price_relative","title":"Calculate period-over-period price relatives — price_relative","text":"Construct period--period price relatives information prices products time.","code":""},{"path":"https://marberts.github.io/piar/reference/price_relative.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate period-over-period price relatives — price_relative","text":"","code":"price_relative(x, ...)  # Default S3 method price_relative(x, ..., period, product)  # S3 method for class 'data.frame' price_relative(x, formula, ...)"},{"path":"https://marberts.github.io/piar/reference/price_relative.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate period-over-period price relatives — price_relative","text":"x Either numeric vector (something can coerced one) data frame prices. ... arguments passed used methods. period factor, something can coerced one, gives corresponding time period element x. ordering time periods follows levels period agree cut(). product factor, something can coerced one, gives corresponding product identifier element x. formula two-sided formula prices left-hand side, time periods products (order) right-hand side.","code":""},{"path":"https://marberts.github.io/piar/reference/price_relative.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate period-over-period price relatives — price_relative","text":"numeric vector price relatives, product names.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/price_relative.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate period-over-period price relatives — price_relative","text":"","code":"price_relative(   1:6,   period = rep(1:2, each = 3),   product = rep(letters[1:3], 2) ) #>   a   b   c   a   b   c  #> 1.0 1.0 1.0 4.0 2.5 2.0"},{"path":"https://marberts.github.io/piar/reference/split.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Split an index into groups — split.piar_index","title":"Split an index into groups — split.piar_index","text":"Split index groups indexes according factor, along either levels time periods index.","code":""},{"path":"https://marberts.github.io/piar/reference/split.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Split an index into groups — split.piar_index","text":"","code":"# S3 method for class 'piar_index' split(x, f, drop = FALSE, ..., margin = c(\"levels\", \"time\"))  # S3 method for class 'piar_index' split(x, f, drop = FALSE, ..., margin = c(\"levels\", \"time\")) <- value"},{"path":"https://marberts.github.io/piar/reference/split.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Split an index into groups — split.piar_index","text":"x price index, made , e.g., elemental_index(). f factor list factors group elements x. drop levels occur f dropped? default levels kept. ... arguments passed split.default(). margin Either 'levels' split levels x (default), 'time' split time periods x. value list values compatible splitting x, something can coerced one, recycled necessary.","code":""},{"path":"https://marberts.github.io/piar/reference/split.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Split an index into groups — split.piar_index","text":"split() returns list index objects level f. replacement method replaces values corresponding element value.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/split.piar_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Split an index into groups — split.piar_index","text":"","code":"index <- as_index(matrix(1:6, 2))  split(index, 1:2) #> $`1` #> Period-over-period price index for 1 levels over 3 time periods  #>   1 2 3 #> 1 1 3 5 #>  #> $`2` #> Period-over-period price index for 1 levels over 3 time periods  #>   1 2 3 #> 2 2 4 6 #>   split(index, c(1, 1, 2), margin = \"time\") #> $`1` #> Period-over-period price index for 2 levels over 2 time periods  #>   1 2 #> 1 1 3 #> 2 2 4 #>  #> $`2` #> Period-over-period price index for 2 levels over 1 time periods  #>   3 #> 1 5 #> 2 6 #>"},{"path":"https://marberts.github.io/piar/reference/stack.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Stack price indexes — stack.piar_index","title":"Stack price indexes — stack.piar_index","text":"stack() combines two price indexes common levels, stacking index values percent-change contributions one index . unstack() breaks price index list indexes time period. methods can used map-reduce make index multiple aggregation structures (like Paasche index).","code":""},{"path":"https://marberts.github.io/piar/reference/stack.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stack price indexes — stack.piar_index","text":"","code":"# S3 method for class 'chainable_piar_index' stack(x, y, ...)  # S3 method for class 'direct_piar_index' stack(x, y, ...)  # S3 method for class 'chainable_piar_index' unstack(x, ...)  # S3 method for class 'direct_piar_index' unstack(x, ...)"},{"path":"https://marberts.github.io/piar/reference/stack.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stack price indexes — stack.piar_index","text":"x price index, made , e.g., elemental_index(). y price index, something can coerced one. x period--period index y coerced chainable index; otherwise, y coerced direct index. ... currently used.","code":""},{"path":"https://marberts.github.io/piar/reference/stack.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stack price indexes — stack.piar_index","text":"stack() returns combined price index inherits class x. unstack() returns list price indexes class x.","code":""},{"path":"https://marberts.github.io/piar/reference/stack.piar_index.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Stack price indexes — stack.piar_index","text":"may necessary use rebase() prior stacking fixed-based price indexes ensure base period.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/stack.piar_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stack price indexes — stack.piar_index","text":"","code":"index1 <- as_index(matrix(1:6, 2))  index2 <- index1 time(index2) <- 4:6  stack(index1, index2) #> Period-over-period price index for 2 levels over 6 time periods  #>   1 2 3 4 5 6 #> 1 1 3 5 1 3 5 #> 2 2 4 6 2 4 6  # Unstack does the reverse  all.equal(   c(unstack(index1), unstack(index2)),   unstack(stack(index1, index2)) ) #> [1] TRUE"},{"path":"https://marberts.github.io/piar/reference/sub-.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract and replace index values — [.piar_index","title":"Extract and replace index values — [.piar_index","text":"Methods extract replace index values like matrix.","code":""},{"path":"https://marberts.github.io/piar/reference/sub-.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract and replace index values — [.piar_index","text":"","code":"# S3 method for class 'piar_index' x[i, j, ...]  # S3 method for class 'piar_index' x[i, j, ...] <- value"},{"path":"https://marberts.github.io/piar/reference/sub-.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract and replace index values — [.piar_index","text":"x price index, made , e.g., elemental_index(). , j Indices levels time periods price index. See details. ... currently used. value numeric vector price index. See details.","code":""},{"path":"https://marberts.github.io/piar/reference/sub-.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract and replace index values — [.piar_index","text":"price index inherits class x.","code":""},{"path":"https://marberts.github.io/piar/reference/sub-.piar_index.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract and replace index values — [.piar_index","text":"extraction method treats x like matrix index values (named) rows level columns time period x. Unlike matrix, dimensions never dropped subscripting x always returns index object. means subscripting matrix possible, \"submatrix\" can extracted. x atomic vector, subscripting single index like x[1] extracts time periods level. replacement method similarly treat x like matrix. value index object number time periods x[, j] inherits class x, index values percent-change contributions x[, j] replaced corresponding levels value. value index, coerced numeric vector behaves replacing values matrix. Note replacing values index remove corresponding percent-change contributions (). Unlike extraction, possible replace value x using logical matrix two-column matrix indices.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/sub-.piar_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract and replace index values — [.piar_index","text":"","code":"index <- as_index(matrix(1:6, 2))  index[\"1\", ] #> Period-over-period price index for 1 levels over 3 time periods  #>   1 2 3 #> 1 1 3 5  index[, 2] #> Period-over-period price index for 2 levels over 1 time periods  #>   2 #> 1 3 #> 2 4  index[1, ] <- 1 # can be useful for doing specific imputations  index #> Period-over-period price index for 2 levels over 3 time periods  #>   1 2 3 #> 1 1 1 1 #> 2 2 4 6"},{"path":"https://marberts.github.io/piar/reference/time.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the time periods for a price index — time.piar_index","title":"Get the time periods for a price index — time.piar_index","text":"Methods get set time periods price index.","code":""},{"path":"https://marberts.github.io/piar/reference/time.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the time periods for a price index — time.piar_index","text":"","code":"# S3 method for class 'piar_index' time(x, ...)  time(x) <- value  # S3 method for class 'piar_index' time(x) <- value  set_time(x, value)  # S3 method for class 'piar_index' start(x, ...)  # S3 method for class 'piar_index' end(x, ...)  ntime(x)"},{"path":"https://marberts.github.io/piar/reference/time.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the time periods for a price index — time.piar_index","text":"x price index, made , e.g., elemental_index(). ... currently used. value character vector, something can coerced one, giving replacement time periods x.","code":""},{"path":"https://marberts.github.io/piar/reference/time.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the time periods for a price index — time.piar_index","text":"time() returns character vector time periods price index. start() end() return first last time period. ntime() returns number time periods, analogous nlevels(). replacement method returns copy x time periods value.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/update.piar_aggregation_structure.html","id":null,"dir":"Reference","previous_headings":"","what":"Update an aggregation structure — update.piar_aggregation_structure","title":"Update an aggregation structure — update.piar_aggregation_structure","text":"Price update weights price index aggregation structure.","code":""},{"path":"https://marberts.github.io/piar/reference/update.piar_aggregation_structure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update an aggregation structure — update.piar_aggregation_structure","text":"","code":"# S3 method for class 'piar_aggregation_structure' update(object, index, period = end(index), ..., r = 1)"},{"path":"https://marberts.github.io/piar/reference/update.piar_aggregation_structure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update an aggregation structure — update.piar_aggregation_structure","text":"object price index aggregation structure, made aggregation_structure(). index price index, something can coerced one. Usually aggregate price index made aggregate(). period time period used price update weights. default uses last period index. ... currently used. r Order generalized mean update weights. default 1 arithmetic index.","code":""},{"path":"https://marberts.github.io/piar/reference/update.piar_aggregation_structure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update an aggregation structure — update.piar_aggregation_structure","text":"copy object price-updated weights using index values index.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/update.piar_aggregation_structure.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Update an aggregation structure — update.piar_aggregation_structure","text":"","code":"# A simple aggregation structure #            1 #      |-----+-----| #      11          12 #  |---+---|       | #  111     112     121 #  (1)     (3)     (4)  aggregation_weights <- data.frame(   level1 = c(\"1\", \"1\", \"1\"),   level2 = c(\"11\", \"11\", \"12\"),   ea     = c(\"111\", \"112\", \"121\"),   weight = c(1, 3, 4) )  pias <- as_aggregation_structure(aggregation_weights)  index <- as_index(   matrix(1:9, 3, dimnames = list(c(\"111\", \"112\", \"121\"), NULL)) )  weights(pias, ea_only = FALSE) #> [[1]] #> 1  #> 8  #>  #> [[2]] #> 11 12  #>  4  4  #>  #> [[3]] #> 111 112 121  #>   1   3   4  #>   weights(update(pias, index), ea_only = FALSE) #> [[1]] #>   1  #> 916  #>  #> [[2]] #>  11  12  #> 268 648  #>  #> [[3]] #> 111 112 121  #>  28 240 648  #>"},{"path":"https://marberts.github.io/piar/reference/weights.piar_aggregation_structure.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the weights for an aggregation structure — weights.piar_aggregation_structure","title":"Get the weights for an aggregation structure — weights.piar_aggregation_structure","text":"Get set weights price index aggregation structure.","code":""},{"path":"https://marberts.github.io/piar/reference/weights.piar_aggregation_structure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the weights for an aggregation structure — weights.piar_aggregation_structure","text":"","code":"# S3 method for class 'piar_aggregation_structure' weights(object, ..., ea_only = TRUE, na.rm = FALSE)  weights(object) <- value  # S3 method for class 'piar_aggregation_structure' weights(object) <- value  set_weights(object, value)"},{"path":"https://marberts.github.io/piar/reference/weights.piar_aggregation_structure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the weights for an aggregation structure — weights.piar_aggregation_structure","text":"object price index aggregation structure, made aggregation_structure(). ... currently used. ea_only weights returned elemental aggregates (default)? Setting FALSE gives weights entire aggregation structure. na.rm missing values removed aggregating weights (.e., ea_only = FALSE)? default, missing values removed. value numeric vector weights elemental aggregates object.","code":""},{"path":"https://marberts.github.io/piar/reference/weights.piar_aggregation_structure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the weights for an aggregation structure — weights.piar_aggregation_structure","text":"weights() returns named vector weights elemental aggregates. replacement method replaces values without changing aggregation structure. ea_only = FALSE return value list named vector weights level aggregation structure.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/weights.piar_aggregation_structure.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the weights for an aggregation structure — weights.piar_aggregation_structure","text":"","code":"# A simple aggregation structure #            1 #      |-----+-----| #      11          12 #  |---+---|       | #  111     112     121 #  (1)     (3)     (4)  aggregation_weights <- data.frame(   level1 = c(\"1\", \"1\", \"1\"),   level2 = c(\"11\", \"11\", \"12\"),   ea     = c(\"111\", \"112\", \"121\"),   weight = c(1, 3, 4) )  pias <- as_aggregation_structure(aggregation_weights)  # Extract the weights  weights(pias) #> 111 112 121  #>   1   3   4   # ... or update them  weights(pias) <- 1:3 weights(pias) #> 111 112 121  #>   1   2   3"},{"path":"https://marberts.github.io/piar/reference/window.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Index window — window.piar_index","title":"Index window — window.piar_index","text":"Extract replace index values window time periods.","code":""},{"path":"https://marberts.github.io/piar/reference/window.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Index window — window.piar_index","text":"","code":"# S3 method for class 'piar_index' window(x, start = NULL, end = NULL, ...)  # S3 method for class 'piar_index' window(x, start = NULL, end = NULL, ...) <- value"},{"path":"https://marberts.github.io/piar/reference/window.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Index window — window.piar_index","text":"x price index, made , e.g., elemental_index(). start time period start window. default first period x. end time period end window. default last period x. ... currently used. value numeric vector price index.","code":""},{"path":"https://marberts.github.io/piar/reference/window.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Index window — window.piar_index","text":"window() extracts price index window time periods inherits class x. replacement method replaces value.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/window.piar_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Index window — window.piar_index","text":"","code":"x <- as_index(matrix(1:9, 3))  window(x, \"2\") #> Period-over-period price index for 3 levels over 2 time periods  #>   2 3 #> 1 4 7 #> 2 5 8 #> 3 6 9  window(x, \"2\") <- 1 x #> Period-over-period price index for 3 levels over 3 time periods  #>   1 2 3 #> 1 1 1 1 #> 2 2 1 1 #> 3 3 1 1"},{"path":[]},{"path":"https://marberts.github.io/piar/news/index.html","id":"improvements-0-8-2","dir":"Changelog","previous_headings":"","what":"Improvements","title":"Version 0.8.2","text":"Added set_levels(), set_time(), set_weights() make easier replace levels, times, weights pipes. contrib(index) <- value can now used replace product contributions. elementary_index() now alias elemental_index() common literature.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"version-081","dir":"Changelog","previous_headings":"","what":"Version 0.8.1","title":"Version 0.8.1","text":"CRAN release: 2024-09-12","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"significant-changes-0-8-1","dir":"Changelog","previous_headings":"","what":"Significant changes","title":"Version 0.8.1","text":"elemental_index(), price_relative(), shadow_price(), carry_forward(), carry_backward() now formula interface select relevant, e.g., price variables data frame instead using (). changes signature functions, may break old code argument named. as_aggregation_structure(list) mean(index) now require weights argument named consistent functions. aggregate_piar_index class removed. class well thought , added unnecessary restrictions complications certain functions. cases little impact existing code, mean functions related aggregate indexes removed. deprecated cols argument as_index(data.frame) removed. default window size mean(index) now covers entire index. makes mean() doesn’t assume index monthly, makes easier use mean() new window() method index object.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"improvements-0-8-1","dir":"Changelog","previous_headings":"","what":"Improvements","title":"Version 0.8.1","text":"as_index() gains new argument contrib add contributions pre-computed indexes. Added contrib2DF() extract percent-change contributions data frame. elemental_index(), price_relative(), shadow_price(), carry_forward(), carry_backward() now require arguments time periods, products, elemental aggregates named avoid accidentally changing order arguments (gh #7). Added interact_classifications() get interaction different dimensions hierarchical classification. unchain() gets new argument base better interaction chain() rebase(). aggregate(index) gets new argument include_ea control whether elemental indexes returned aggregating. summary() method indexes changed simply print summary index, rather try summarized index values. aggregate(index) now imputes percent-change contributions missing index values na.rm = TRUE. previously undocumented behavior simply drop . Added window(index) extract window price indexes window(index) <- value replace . base period rebase() can now time period specifying new base period. makes easier rebase pipes; e.g., index |> mean() |> rebase(\"202001\"). elemental_index() gets new argument product better control product names.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"version-070","dir":"Changelog","previous_headings":"","what":"Version 0.7.0","title":"Version 0.7.0","text":"CRAN release: 2024-03-08","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"significant-changes-0-7-0","dir":"Changelog","previous_headings":"","what":"Significant changes","title":"Version 0.7.0","text":"arguments elemental_index(), as_index(), aggregate(index), mean(index), vcov(index), update(aggregation_structure), weights(aggregation_structure) now need named (e.g., na.rm, contrib). helps unify signatures several functions similar arguments different positions. cases arguments near beginning function probably named anyways. several bug fixes version make non-backwards compatible changes.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"improvements-0-7-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"Version 0.7.0","text":"Added examples finding imputed index values vignette. contrib() gets new argument period control time periods get included contributions matrix (documented). contrib() gets new argument pad control contributions matrix padded products differ time. Added .na() anyNA() methods find missing values index object. index[] <- value now works matrix. mean() gets new argument contrib control product contributions aggregated subperiods. Added split() method index objects. levels(aggregation_structure) now returns list levels denote position level hierarchy. Use unlist() get old behavior.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"bug-fixes-0-7-0","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"Version 0.7.0","text":"default ea_only changed TRUE calling weights(aggregation_structure) fix bug replacement method. Replacing index value index[] <- value value also index object now works correctly value recycled. Setting stringsAsFactors = TRUE .data.frame(index) now keeps correct ordering factor levels. mean(index) longer returns aggregate index r differs used make index.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"deprecations-0-7-0","dir":"Changelog","previous_headings":"","what":"Deprecations","title":"Version 0.7.0","text":"cols argument as_index() deprecated removed future version.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"version-060","dir":"Changelog","previous_headings":"","what":"Version 0.6.0","title":"Version 0.6.0","text":"CRAN release: 2023-11-19","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"significant-changes-0-6-0","dir":"Changelog","previous_headings":"","what":"Significant changes","title":"Version 0.6.0","text":"[[ method index objects removed created unexpected problems little gain. .matrix(index)[[1, 1]] explicit flexible way get behavior index[[1, 1]]. aggregation_structure() now orders levels aggregation according order appear data. Previously levels ordered lexicographically, except elemental aggregates. can affect order index values appear aggregate index. number changes way product names handled making index extracting percent-change contributions. Names price relatives now need unique within time period elemental_index(). previous (undocumented) behavior require names unique within time period elemental aggregate. implies two non-backward compatible changes. default product names elemental_index() now include name elemental aggregate conform requirement. Percent-change contributions contrib() simplified row names, now need include index-level names make product names unique. contrib() now always returns matrix. Previously return NULL contributions level index. Rows contributions matrix ordered according product names consistent ordering.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"improvements-0-6-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"Version 0.6.0","text":"Printing index gives textual description addition matrix index values. Printing aggregation structure now gives description tabular representation instead list. now methods set levels time periods index. Methods index objects now faster larger indexes. aggregate() gains new argument contrib controls percent-change contributions elemental indexes aggregated. default maintains current behavior aggregating contributions . class names index objects changed fix name conflict Matrix. means ’s now possible use rsmatrix piar. .matrix() method aggregation structures gains new argument sparse. sparse = TRUE aggregation matrix sparse, rather dense, matrix. option can also used vcov() method aggregate price indexes improve performance large indexes. Added carry_backwards() function carry backwards (opposed carry forwards) imputation.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"bug-fixes-0-6-0","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"Version 0.6.0","text":"Viewing index objects RStudio viewer longer gives error. is_direct_index() now exported. Replacing index values aggregate index longer returns aggregate index, may consistent aggregation. Stacking two indexes now returns aggregate index indexes aggregate indexes. Previously possible stack aggregate index non-aggregate index produce aggregate index consistent aggregation.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"version-050","dir":"Changelog","previous_headings":"","what":"Version 0.5.0","title":"Version 0.5.0","text":"CRAN release: 2023-08-10","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"significant-changes-0-5-0","dir":"Changelog","previous_headings":"","what":"Significant changes","title":"Version 0.5.0","text":"piar now requires R >= 4.0. is_chain_index() removed; use is_chainable_index() instead. first argument elemental_index() now x, rel, consistent rest functions. Similarly, first argument expand_classification() now x, class.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"new-features-0-5-0","dir":"Changelog","previous_headings":"","what":"New features","title":"Version 0.5.0","text":"New functions as_aggregation_structure() is_aggregation_structure() coerce (usually) tabular data aggregation weights aggregation structure, test object aggregation structure. method [[ index objects extract replace single index value. weights aggregation structure can replace weights(pias) <- vector.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"improvements-0-5-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"Version 0.5.0","text":"levels() replacement function now gives error indexes aggregation structures, rather adding levels attribute nothing. width argument expand_classification() now recycles single value. Major overhaul documentation make easier use. object structure used represent index object refined. Subscripting index object now much faster. now possible update aggregation structure non-aggregated index. Functions accept price index aggregation structure argument now attempt coerce arguments index object aggregation structure object instead throwing error.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"bug-fixes-0-5-0","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"Version 0.5.0","text":"Fixed bug creating elemental indexes missing product names produce contributions matrix wrong number products. now possible chain index one level. Subscripting index NAs duplicate indices longer allowed.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"version-040","dir":"Changelog","previous_headings":"","what":"Version 0.4.0","title":"Version 0.4.0","text":"CRAN release: 2022-04-30","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"significant-changes-0-4-0","dir":"Changelog","previous_headings":"","what":"Significant changes","title":"Version 0.4.0","text":"vcov() method aggregate indexes now returns matrix variances instead array covariances, covariances usually misleading unnecessary. cases elemental aggregates sampled independently, case covariances 0. backwards compatible. vcov() method aggregate indexes now much faster. options parallel computing removed, ’re unlikely useful even large indexes. head() tail() methods index objects now return index object instead matrix, documented.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"new-features-0-4-0","dir":"Changelog","previous_headings":"","what":"New features","title":"Version 0.4.0","text":"Added .matrix() method pias objects. makes easy aggregate price index matrix operation; just matrix multiply aggregation matrix elemental indexes. Added .data.frame() method pias objects. useful writing price-updated weights , e.g., write.csv(). Added as_index() method data frames. faster simpler turning data frame index elemental_index(df$value, df$period, df$level).","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"improvements-0-4-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"Version 0.4.0","text":"chain argument found methods elemental_index() as_index() mark index chainable replaced descriptive chainable argument. Partial matching argument names means backwards compatible. price_relative() function longer uses gpindex::back_price(), function deprecated. change remove harmless deprecation warning using older version piar newer version gpindex.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"deprecated-functions-0-4-0","dir":"Changelog","previous_headings":"","what":"Deprecated functions","title":"Version 0.4.0","text":"is_chain_index() function now deprecated, replaced is_chainable_index() function.","code":""}]
