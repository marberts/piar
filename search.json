[{"path":"https://marberts.github.io/piar/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing","title":"Contributing","text":"Contributions piar welcome appreciated. ways can contribute.","code":""},{"path":"https://marberts.github.io/piar/CONTRIBUTING.html","id":"reporting-bugs","dir":"","previous_headings":"","what":"Reporting bugs","title":"Contributing","text":"Open issue small reproducible example bug. Feel free include PR patch.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/CONTRIBUTING.html","id":"typos-and-corrections","dir":"","previous_headings":"Improving documentation","what":"Typos and corrections","title":"Contributing","text":"can fix typos, spelling mistakes, make small corrections documentation editing roxygen2 comments corresponding .R (.Rd) file.","code":""},{"path":"https://marberts.github.io/piar/CONTRIBUTING.html","id":"adding-documentation","dir":"","previous_headings":"Improving documentation","what":"Adding documentation","title":"Contributing","text":"Please open issue feel documentation unclear certain functions don’t enough documentation.","code":""},{"path":"https://marberts.github.io/piar/CONTRIBUTING.html","id":"suggestions-for-improvement","dir":"","previous_headings":"","what":"Suggestions for improvement","title":"Contributing","text":"Open issue suggestions improvements (e.g., feature requests).","code":""},{"path":"https://marberts.github.io/piar/CONTRIBUTING.html","id":"seeking-support","dir":"","previous_headings":"","what":"Seeking support","title":"Contributing","text":"Open issue (send email) ’re stuck able find answer documentation. (may bug problem documentation.)","code":""},{"path":"https://marberts.github.io/piar/CONTRIBUTING.html","id":"making-a-pull-request","dir":"","previous_headings":"","what":"Making a pull request","title":"Contributing","text":"making pull request, please: Fork repository github make new branch forked copy; Follow tidyverse style guide; Use roxygen2 documentation; Use testthat unit tests; Ensure changes pass R CMD check.","code":""},{"path":"https://marberts.github.io/piar/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 Steve Martin Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://marberts.github.io/piar/articles/contributions.html","id":"product-contributions","dir":"Articles","previous_headings":"","what":"Product contributions","title":"Contributions","text":"’s often convenient decompose index (additive) contribution price relative, also known percent-change contribution. can done work flow used vignette(\"piar\"), specifying contrib = TRUE calling elemental_index(). index values, percent-change contributions given level index can extracted matrix. data frame. Aggregating elemental indexes automatically aggregates percent-change contributions, extra steps needed elemental indexes made.","code":"library(piar)  # Make an aggregation structure. ms_weights[c(\"level1\", \"level2\")] <-    expand_classification(ms_weights$classification)  pias <- ms_weights[c(\"level1\", \"level2\", \"business\", \"weight\")] |>   as_aggregation_structure()  # Make elemental index with contributions. elementals <- ms_prices |>   transform(     relative = price_relative(price, period = period, product = product)   ) |>   elemental_index(     relative ~ period + business,     product = product,     na.rm = TRUE,     contrib = TRUE   ) contrib(elementals, level = \"B1\") ##   202001     202002     202003 202004 ## 1      0  0.0000000  0.0000000      0 ## 2     NA         NA -0.6657061      0 ## 3      0 -0.1050903         NA     NA contrib2DF(elementals, level = \"B1\") ##   period level product      value ## 1 202001    B1       1  0.0000000 ## 2 202001    B1       2         NA ## 3 202001    B1       3  0.0000000 ## 4 202002    B1       2         NA ## 5 202002    B1       3 -0.1050903 ## 6 202003    B1       2 -0.6657061 ## 7 202003    B1       3         NA ## 8 202004    B1       3         NA index <- aggregate(elementals, pias, na.rm = TRUE)  contrib(index) ##    202001      202002     202003       202004 ## 1       0  0.00000000  0.0000000  0.000000000 ## 10      0 -0.08782076  0.2731949 -0.078173579 ## 11      0  0.00000000         NA  0.059392635 ## 12      0  0.00000000         NA  1.322915301 ## 2      NA          NA -0.2928098  0.000000000 ## 3       0 -0.06718490         NA           NA ## 4       0          NA         NA -0.018209690 ## 5       0          NA         NA  0.094562963 ## 6       0          NA         NA  0.427935081 ## 7       0  0.51646606 -0.2054665 -0.011177530 ## 8       0  0.01906845  0.1755868 -0.003784845 ## 9       0 -0.07980493  0.1125689 -0.058699008"},{"path":"https://marberts.github.io/piar/articles/contributions.html","id":"index-contributions","dir":"Articles","previous_headings":"","what":"Index contributions","title":"Contributions","text":"index calculated, ’s often useful compute contribution higher-level indexes towards total index. easiest way collection pre-computed index values simply coerce index object index values contributions reaggregate restricted aggregation structure. index values already index object, ’s also possible directly replace contributions set_contrib_from_index() function. can now cut aggregation structure keep top two levels reaggregate get contribution second-level indexes top level index. approach works fixed-base index well.","code":"index <- as_index(as.matrix(index), contrib = TRUE) set_contrib_from_index(index) |>   aggregate(cut(pias, 2)) |>   contrib() ##    202001   202002     202003    202004 ## 11      0 0.184488 0.03869481 0.3524534 ## 12      0 0.116236 0.02437952 1.3823079 chain(index) |>   set_contrib_from_index() |>   aggregate(cut(pias, 2)) |>   contrib() ##    202001   202002    202003    202004 ## 11      0 0.184488 0.2348192 0.7221798 ## 12      0 0.116236 0.1479470 2.0593557"},{"path":"https://marberts.github.io/piar/articles/imputation.html","id":"imputing-missing-prices","dir":"Articles","previous_headings":"","what":"Imputing missing prices","title":"Imputation","text":"Instead implicitly imputing missing price relatives ignoring missing values, common explicit (methodologically dubious) imputation strategy making elemental indexes carry forward previous price impute missing prices. elemental_index() function accepts price relatives input, imputations can done prior passing price relatives function. (Missing values still need removed example missing prices can imputed.)","code":"library(piar)  elementals <- ms_prices |>   transform(     imputed_price = carry_forward(price, period = period, product = product)   ) |>   elemental_index(     price_relative(imputed_price, period = period, product = product) ~       period + business,     na.rm = TRUE   )  elementals ## Period-over-period price index for 4 levels over 4 time periods  ##    202001    202002    202003   202004 ## B1      1 0.8949097 0.5781816 1.000000 ## B2      1 1.0000000 0.1777227 2.770456 ## B3      1 2.0200036 1.6353355 0.537996 ## B4    NaN       NaN       NaN 4.576286"},{"path":"https://marberts.github.io/piar/articles/imputation.html","id":"non-parental-imputation-during-aggregation","dir":"Articles","previous_headings":"","what":"Non-parental imputation during aggregation","title":"Imputation","text":"Parental imputation usual way impute missing elemental index values aggregation, simple aggregate(). cases, however, elemental index may get imputed value , say, another elemental aggregate, rather entire group elemental aggregates. simplest way sort imputation alter elemental indexes prior aggregation. example, suppose missing index values business B4 imputed 1, rather value group 12. replacement can done index matrix.","code":"elementals[\"B4\", 1:3] <- 1  elementals ## Period-over-period price index for 4 levels over 4 time periods  ##    202001    202002    202003   202004 ## B1      1 0.8949097 0.5781816 1.000000 ## B2      1 1.0000000 0.1777227 2.770456 ## B3      1 2.0200036 1.6353355 0.537996 ## B4      1 1.0000000 1.0000000 4.576286"},{"path":"https://marberts.github.io/piar/articles/index-number-formulas.html","id":"basic-indexes","dir":"Articles","previous_headings":"","what":"Basic indexes","title":"Index-number formulas","text":"seen vignette(\"piar\"), default elemental_index() function calculates Jevons index (equally-weighted geometric mean price relatives). Although standard index-number formula making elemental indexes, many types index-numbers possible. Among unweighted index-number formulas, Carli index (equally-weighted arithmetic mean price relatives) historical competitor Jevons, requires specifying order generalized mean r calling elemental_index(). order 1 corresponds arithmetic mean. Coggeshall index (equally-weighted harmonic mean price relatives) another competitor Jevons, seldom used practice. Despite exotic, just easy make specifying order r -1. Weights can added make, example, elemental indexes using geometric Laspeyres formula. type mean used aggregate elemental indexes can controlled way call aggregate(). default makes arithmetic index, type generalized-mean index possible.","code":"prices |>   elemental_index(price / back_price ~ period + business, r = 1) ## Period-over-period price index for 2 levels over 3 time periods  ##    1        2        3 ## B1 1 4.666667 1.757937 ## B2 1 2.233333 1.548485 prices |>   elemental_index(price / back_price ~ period + business, r = -1) ## Period-over-period price index for 2 levels over 3 time periods  ##    1        2        3 ## B1 1 4.131148 1.754499 ## B2 1 2.214765 1.547408 prices |>   elemental_index(     price / back_price ~ period + business,     weights = back_price * back_quantity   ) ## Period-over-period price index for 2 levels over 3 time periods  ##    1        2        3 ## B1 1 3.853330 1.754015 ## B2 1 2.202496 1.549081"},{"path":"https://marberts.github.io/piar/articles/index-number-formulas.html","id":"superlative-indexes","dir":"Articles","previous_headings":"","what":"Superlative indexes","title":"Index-number formulas","text":"Many superlative indexes can made supplying unequal time-varying weights making elemental indexes, usually information quantities. Törnqvist index popular superlative index-number formula, using average period--period value shares weights geometric mean. elemental_index() makes geometric index default, needed make Törnqvist index weights. Making Fisher index complex belong generalized-mean family. Despite , possible make weights represent Fisher index generalized mean order. Aggregating superlative index complex, subject vignette(\"superlative-aggregation\").","code":"tw <- grouped(index_weights(\"Tornqvist\"))  prices |>   elemental_index(     price / back_price ~ period + business,     weights = tw(       price, back_price, quantity, back_quantity,       group = interaction(period, business)     )   ) ## Period-over-period price index for 2 levels over 3 time periods  ##    1        2        3 ## B1 1 4.087422 1.759213 ## B2 1 2.215995 1.556014 fw <- grouped(nested_transmute(0, c(1, -1), 0))  prices |>   elemental_index(     price / back_price ~ period + business,     weights = fw(       price / back_price, back_price * back_quantity, price * quantity,       group = interaction(period, business)     )   ) ## Period-over-period price index for 2 levels over 3 time periods  ##    1        2        3 ## B1 1 4.076840 1.759215 ## B2 1 2.215934 1.556046"},{"path":"https://marberts.github.io/piar/articles/index-number-formulas.html","id":"product-contributions","dir":"Articles","previous_headings":"","what":"Product contributions","title":"Index-number formulas","text":"shown vignette(\"contributions\"), supplying contrib = TRUE call elemental_index() makes percent-change product contributions index value. method used package flexible works well variety different index-number formulas, include methods found literature. (See help page elemental_index(), references therein, detail exact methods.) Let’s extend previous example calculating product contributions Fisher index using default method. can change method used make contributions , say, business B1 making function compute contributions according different method using function replace contributions business B1. Aggregating elemental indexes consistently aggregate contributions businesses, even though use different methods.","code":"fisher_index <- prices |>   elemental_index(     price / back_price ~ period + business,     weights = fw(       price / back_price, back_price * back_quantity, price * quantity,       group = interaction(period, business)     ),     contrib = TRUE   )  contrib(fisher_index, \"B1\") ##      1         2         3 ## B1.1 0 1.1024526 0.2899319 ## B1.2 0 1.0256151 0.2530718 ## B1.3 0 0.9487724 0.2162114 diewert_contributions <- function(p1, p0, q1, q0) {   Pf <- fisher_index(p1, p0, q1, q0)   Pl <- laspeyres_index(p1, p0, q0)   wl <- scale_weights(index_weights(\"Laspeyres\")(p0, q0))   wp <- scale_weights(index_weights(\"HybridPaasche\")(p0, q1))      (1 / (1 + Pf) * wl + Pl / (1 + Pf) * wp) * (p1 / p0 - 1) } contrib(fisher_index, \"B1\") <- subset(prices, business == \"B1\") |>   split(~period) |>   sapply(     \\(df) diewert_contributions(       df$price, df$back_price, df$quantity, df$back_quantity     )   )  contrib(fisher_index, \"B1\") ##   1         2         3 ## 1 0 1.1124046 0.2937263 ## 2 0 1.0256134 0.2530717 ## 3 0 0.9388222 0.2124170"},{"path":"https://marberts.github.io/piar/articles/matrix-aggregation.html","id":"computing-the-shadow-of-an-index","dir":"Articles","previous_headings":"","what":"Computing the shadow of an index","title":"Matrix aggregation","text":"’s often useful determine higher-level index values missing, subsequently get imputed aggregation (.e., compute shadow index). simple ’s elemental index elemental aggregate aggregation structure. idea aggregate indicator missingness get matrix gives share missing elemental indexes higher-level index. value 1 means non-missing elemental indexes, value level index imputed parent aggregation structure. value 1 zero means elemental indexes missing, index value level based non-missing elemental indexes. value zero means ’s imputation level index.","code":"pias_matrix <- as.matrix(pias) > 0   pias_matrix %*% is.na(elementals) / rowSums(pias_matrix) ##    202001    202002    202003    202004 ## 1     0.4 0.6000000 0.6000000 0.4000000 ## 11    0.0 0.3333333 0.3333333 0.3333333 ## 12    1.0 1.0000000 1.0000000 0.5000000"},{"path":"https://marberts.github.io/piar/articles/matrix-aggregation.html","id":"sparse-matrices","dir":"Articles","previous_headings":"","what":"Sparse matrices","title":"Matrix aggregation","text":"Aggregation structures naturally sparse. Although using dense aggregation matrix matter small indexes, quickly becomes inefficient large indexes—case better make sparse aggregation matrix.","code":"as.matrix(pias, sparse = TRUE) ## 3 x 5 sparse Matrix of class \"dgCMatrix\" ##           B1        B2        B3        B4        B5 ## 1  0.2245229 0.2622818 0.1266748 0.2525376 0.1339829 ## 11 0.3659828 0.4275314 0.2064858 .         .         ## 12 .         .         .         0.6533613 0.3466387"},{"path":"https://marberts.github.io/piar/articles/piar.html","id":"matched-sample-index","dir":"Articles","previous_headings":"","what":"Matched-sample index","title":"Making price indexes","text":"vignette ’ll calculating matched-sample index fixed set businesses provide prices collection products time. products reported businesses can change time, set businesses fixed duration sample. businesses weight established sample drawn represents particular segment economy. usual approach calculating matched-sample index starts computing elemental index business equally-weighted geometric mean price relatives (.e., Jevons index). , index values different segments economy calculated arithmetic mean elemental indexes using businesses-level weights (either Young Lowe index, depending weights constructed; see vignette(\"adjust-weights\")). ms_prices dataset price data five businesses four quarters, ms_weights dataset weight data. Note data fairly realistic patterns missing data emblematic kinds survey data used make price indexes. elemental_index() function makes, well, elemental indexes, using information price relatives, elemental aggregates (businesses), time periods (quarters). default makes Jevons index, bilateral generalized-mean index possible (see vignette(\"index-number-formulas\") details). wrinkle price data levels, relatives, price_relative() function can make necessary conversion. functions R, missing values contagious default. Setting na.rm = TRUE elemental_index() means missing price relatives ignored, equivalent imputing missing relatives value elemental index respective businesses (.e., parental overall mean imputation). types imputation covered vignette(\"imputation\"). elemental_index() function returns special index object, number methods working objects. example, resulting indexes extracted like matrix even though ’s matrix.1 elemental indexes way, ’s time make price-index aggregation structure maps business position aggregation hierarchy. hiccup unpacking digit-wise classification businesses defines hierarchy. ’s job expand_classification() function. now simple aggregate elemental indexes according aggregation structure aggregate() function. elemental indexes, missing values ignored setting na.rm = TRUE, equivalent parentally imputing missing values. Note , unlike elemental indexes, missing values filled ensure index can chained time.","code":"library(piar)  head(ms_prices) ##   period business product price ## 1 202001       B1       1  1.14 ## 2 202001       B1       2    NA ## 3 202001       B1       3  6.09 ## 4 202001       B2       4  6.23 ## 5 202001       B2       5  8.61 ## 6 202001       B2       6  6.40 ms_weights ##   business classification weight ## 1       B1             11    553 ## 2       B2             11    646 ## 3       B3             11    312 ## 4       B4             12    622 ## 5       B5             12    330 elementals <- ms_prices |>   transform(     relative = price_relative(price, period = period, product = product)   ) |>   elemental_index(relative ~ period + business, na.rm = TRUE)  elementals ## Period-over-period price index for 4 levels over 4 time periods  ##    202001    202002    202003   202004 ## B1      1 0.8949097 0.3342939      NaN ## B2      1       NaN       NaN 2.770456 ## B3      1 2.0200036 1.6353355 0.537996 ## B4    NaN       NaN       NaN 4.576286 elementals[, \"202004\"] ## Period-over-period price index for 4 levels over 1 time periods  ##      202004 ## B1      NaN ## B2 2.770456 ## B3 0.537996 ## B4 4.576286 elementals[c(\"B1\", \"B3\"), ] ## Period-over-period price index for 2 levels over 4 time periods  ##    202001    202002    202003   202004 ## B1      1 0.8949097 0.3342939      NaN ## B3      1 2.0200036 1.6353355 0.537996 ms_weights[c(\"level1\", \"level2\")] <-    expand_classification(ms_weights$classification)  pias <- ms_weights[c(\"level1\", \"level2\", \"business\", \"weight\")] |>   as_aggregation_structure() index <- aggregate(elementals, pias, na.rm = TRUE)  index ## Period-over-period price index for 8 levels over 4 time periods  ##    202001    202002    202003   202004 ## 1       1 1.3007239 1.0630743 2.734761 ## 11      1 1.3007239 1.0630743 1.574515 ## 12      1 1.3007239 1.0630743 4.576286 ## B1      1 0.8949097 0.3342939 1.574515 ## B2      1 1.3007239 1.0630743 2.770456 ## B3      1 2.0200036 1.6353355 0.537996 ## B4      1 1.3007239 1.0630743 4.576286 ## B5      1 1.3007239 1.0630743 4.576286"},{"path":"https://marberts.github.io/piar/articles/piar.html","id":"chaining","dir":"Articles","previous_headings":"","what":"Chaining","title":"Making price indexes","text":"elemental_index() function makes period--period elemental indexes default, aggregated make period--period index. Chaining index process taking cumulative product period--period indexes make time series compares prices fixed base period. chain() function can used chain values index object. gives almost result directly manipulating index matrix, except former returns index object (matrix). Chained indexes often need rebased, can done rebase() function. example, rebasing index 202004 base period just requires dividing chained index slice 202004.","code":"chained_index <- chain(index)  chained_index ## Fixed-base price index for 8 levels over 4 time periods  ##    202001    202002    202003    202004 ## 1       1 1.3007239 1.3827662 3.7815355 ## 11      1 1.3007239 1.3827662 2.1771866 ## 12      1 1.3007239 1.3827662 6.3279338 ## B1      1 0.8949097 0.2991629 0.4710366 ## B2      1 1.3007239 1.3827662 3.8308934 ## B3      1 2.0200036 3.3033836 1.7772072 ## B4      1 1.3007239 1.3827662 6.3279338 ## B5      1 1.3007239 1.3827662 6.3279338 rebase(chained_index, chained_index[, \"202004\"]) ## Fixed-base price index for 8 levels over 4 time periods  ##       202001    202002    202003 202004 ## 1  0.2644428 0.3439671 0.3656626      1 ## 11 0.4593084 0.5974334 0.6351161      1 ## 12 0.1580295 0.2055527 0.2185178      1 ## B1 2.1229774 1.8998731 0.6351161      1 ## B2 0.2610357 0.3395354 0.3609514      1 ## B3 0.5626806 1.1366169 1.8587499      1 ## B4 0.1580295 0.2055527 0.2185178      1 ## B5 0.1580295 0.2055527 0.2185178      1"},{"path":"https://marberts.github.io/piar/articles/piar.html","id":"working-with-indexes","dir":"Articles","previous_headings":"","what":"Working with indexes","title":"Making price indexes","text":"index calculated, usually needs turned table index values. can done either coercing index matrix data frame also sometimes useful get price-updated weights used aggregate index; can calculated first updating aggregation structure aggregated index, made table.","code":"as.matrix(chained_index) ##    202001    202002    202003    202004 ## 1       1 1.3007239 1.3827662 3.7815355 ## 11      1 1.3007239 1.3827662 2.1771866 ## 12      1 1.3007239 1.3827662 6.3279338 ## B1      1 0.8949097 0.2991629 0.4710366 ## B2      1 1.3007239 1.3827662 3.8308934 ## B3      1 2.0200036 3.3033836 1.7772072 ## B4      1 1.3007239 1.3827662 6.3279338 ## B5      1 1.3007239 1.3827662 6.3279338 as.data.frame(chained_index) ##    period level     value ## 1  202001     1 1.0000000 ## 2  202001    11 1.0000000 ## 3  202001    12 1.0000000 ## 4  202001    B1 1.0000000 ## 5  202001    B2 1.0000000 ## 6  202001    B3 1.0000000 ## 7  202001    B4 1.0000000 ## 8  202001    B5 1.0000000 ## 9  202002     1 1.3007239 ## 10 202002    11 1.3007239 ## 11 202002    12 1.3007239 ## 12 202002    B1 0.8949097 ## 13 202002    B2 1.3007239 ## 14 202002    B3 2.0200036 ## 15 202002    B4 1.3007239 ## 16 202002    B5 1.3007239 ## 17 202003     1 1.3827662 ## 18 202003    11 1.3827662 ## 19 202003    12 1.3827662 ## 20 202003    B1 0.2991629 ## 21 202003    B2 1.3827662 ## 22 202003    B3 3.3033836 ## 23 202003    B4 1.3827662 ## 24 202003    B5 1.3827662 ## 25 202004     1 3.7815355 ## 26 202004    11 2.1771866 ## 27 202004    12 6.3279338 ## 28 202004    B1 0.4710366 ## 29 202004    B2 3.8308934 ## 30 202004    B3 1.7772072 ## 31 202004    B4 6.3279338 ## 32 202004    B5 6.3279338 update(pias, index) |>   as.data.frame() ##   level1 level2 business    weight ## 1      1     11       B1  260.4832 ## 2      1     11       B2 2474.7571 ## 3      1     11       B3  554.4886 ## 4      1     12       B4 3935.9748 ## 5      1     12       B5 2088.2182"},{"path":"https://marberts.github.io/piar/articles/superlative-aggregation.html","id":"aggregating-a-paasche-index","dir":"Articles","previous_headings":"","what":"Aggregating a Paasche index","title":"Superlative aggregation","text":"Let’s start making chained Paasche index 6 elemental indexes 4 time periods see deal time-varying aggregation weights. similar example building index across multiple basket vignette(\"multiple-baskets\"), except weights change period. key tools deal time-varying aggregation weights stack() unstack() functions. stack() appends later index series onto earlier one levels, whereas unstack() pulls apart index series many periods collection one-period indexes.1 functions allow aggregation done map-reduce. first step making Paasche index unstack elemental indexes list elemental indexes period. (Trying make elemental indexes period--period can dangerous missing values.) followed making sequence aggregation structures set weights. Computing Paasche index period now just case mapping aggregate() function elemental index aggregation structure, reducing result stack() function.","code":"library(piar)  set.seed(12345)  # Make 6 elemental indexes over 4 time periods. elementals <- matrix(c(rep(1, 6), runif(6 * 3, 0.8, 1.2)), nrow = 6) |>   as_index() |>   set_levels(paste0(\"B\", 1:6))  head(elementals) ## Period-over-period price index for 6 levels over 4 time periods  ##    1         2         3         4 ## B1 1 1.0883616 0.9300382 1.0942740 ## B2 1 1.1503093 1.0036897 0.8004546 ## B3 1 1.1043929 1.0910821 0.9564813 ## B4 1 1.1544498 1.1958948 0.9849979 ## B5 1 0.9825924 0.8138142 0.9552576 ## B6 1 0.8665487 0.8609494 0.9609941 # Make aggregation weights over 4 time periods. #            1 #      |-----+-----| #      11          12 #  |---+---|   |---+---| #  B1  B2  B3  B4  B5  B6  weights <- data.frame(   level1 = 1,   level2 = rep(11:12, each = 3),   ea = levels(elementals),   weights = runif(4 * 6, 100, 200),   period = rep(1:4, each = 6) )  head(weights) ##   level1 level2 ea  weights period ## 1      1     11 B1 117.8964      1 ## 2      1     11 B2 195.1659      1 ## 3      1     11 B3 145.3728      1 ## 4      1     12 B4 132.6752      1 ## 5      1     12 B5 196.5415      1 ## 6      1     12 B6 170.7482      1 elementals <- unstack(elementals) paasche_pias <- split(   weights[c(\"level1\", \"level2\", \"ea\", \"weights\")],   weights[[\"period\"]] ) |>   lapply(as_aggregation_structure) paasche <- Map(   aggregate,   elementals,   paasche_pias,   na.rm = TRUE,   include_ea = FALSE,   r = -1 ) |>   Reduce(stack, x = _)  paasche ## Period-over-period price index for 3 levels over 4 time periods  ##    1         2         3         4 ## 1  1 1.0504784 0.9666398 0.9468934 ## 11 1 1.1117341 0.9920294 0.9329698 ## 12 1 0.9898158 0.9447976 0.9647535"},{"path":"https://marberts.github.io/piar/articles/superlative-aggregation.html","id":"making-a-fisher-index","dir":"Articles","previous_headings":"","what":"Making a Fisher index","title":"Superlative aggregation","text":"Making chained Fisher index requires two sets weights: base-period weights make Laspeyres index current-period weights make Paasche index. Paasche index can done map-reduce, except now passing two aggregation structures aggregate() function instead one. gives result calculating Laspeyres Paasche indexes individually, calculating Fisher index manually.","code":"laspeyres_pias <- paasche_pias[c(1, 1, 2, 3)]  fisher <- Map(   aggregate,   elementals,   pias = laspeyres_pias,   pias2 = paasche_pias,   na.rm = TRUE,   include_ea = FALSE ) |>   Reduce(stack, x = _)  fisher ## Period-over-period price index for 3 levels over 4 time periods  ##    1         2         3         4 ## 1  1 1.0509134 0.9783795 0.9600792 ## 11 1 1.1157686 1.0007074 0.9557479 ## 12 1 0.9891911 0.9567760 0.9665552 laspeyres <- Map(   aggregate,   elementals,   pias = laspeyres_pias,   na.rm = TRUE,   include_ea = FALSE ) |>   Reduce(stack, x = _)  sqrt(as.matrix(laspeyres) * as.matrix(paasche)) ##    1         2         3         4 ## 1  1 1.0509134 0.9783795 0.9600792 ## 11 1 1.1157686 1.0007074 0.9557479 ## 12 1 0.9891911 0.9567760 0.9665552"},{"path":"https://marberts.github.io/piar/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Steve Martin. Author, maintainer, copyright holder.","code":""},{"path":"https://marberts.github.io/piar/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Martin S (2024). “piar: Price Index Aggregation R.” Journal Open Source Software, 9(101), 6781. doi:10.21105/joss.06781. Martin S (2025). piar: Price Index Aggregation. doi:10.5281/zenodo.10110046, R package version 0.8.2, https://cran.r-project.org/package=piar.","code":"@Article{,   title = {{piar}: Price Index Aggregation R},   author = {Steve Martin},   year = {2024},   doi = {10.21105/joss.06781},   journal = {Journal of Open Source Software},   volume = {9},   number = {101},   pages = {6781}, } @Manual{,   title = {{piar}: Price Index Aggregation},   author = {Steve Martin},   year = {2025},   doi = {10.5281/zenodo.10110046},   url = {https://cran.r-project.org/package=piar},   note = {R package version 0.8.2}, }"},{"path":"https://marberts.github.io/piar/index.html","id":"price-index-aggregation-in-r-","dir":"","previous_headings":"","what":"Price Index Aggregation","title":"Price Index Aggregation","text":"price indexes made two-step procedure, period--period elemental indexes first calculated collection elemental aggregates point time, aggregated according price index aggregation structure. indexes can chained together form time series gives evolution prices respect fixed base period. package contains collection functions revolve around work flow, making easy build standard price indexes, implement methods described Balk (2008), von der Lippe (2007), CPI manual (2020) / PPI manual (2004) bilateral price indexes. tools package designed useful researching new sources data methods construct price indexes, regular production price statistics. targeted towards economists, statisticians, data scientists working national statistical agencies, central banks, financial institutions, academia want measure study evolution prices time.","code":""},{"path":"https://marberts.github.io/piar/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Price Index Aggregation","text":"Get stable version CRAN. development version can installed R-Universe directly Github.","code":"install.packages(\"piar\") install.packages(\"piar\", repos = c(\"https://marberts.r-universe.dev\", \"https://cloud.r-project.org\")) pak::pak(\"marberts/piar\")"},{"path":"https://marberts.github.io/piar/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Price Index Aggregation","text":"several detailed vignette showing use piar: browseVignettes(\"piar\"). basic work flow fairly simple. starting point make period--period elemental price indexes elemental_index() function. aggregation structure. aggregate() method can used aggregate elemental indexes according aggregation structure (first three rows ) fill missing elemental indexes maintaining consistency aggregation. variety methods work index objects, chaining time.","code":"library(piar)  # Make Jevons business-level elemental indexes  head(ms_prices) #>   period business product price #> 1 202001       B1       1  1.14 #> 2 202001       B1       2    NA #> 3 202001       B1       3  6.09 #> 4 202001       B2       4  6.23 #> 5 202001       B2       5  8.61 #> 6 202001       B2       6  6.40  elementals <- ms_prices |>   transform(     relative = price_relative(price, period = period, product = product)   ) |>   elemental_index(relative ~ period + business, na.rm = TRUE)  elementals #> Period-over-period price index for 4 levels over 4 time periods  #>    202001    202002    202003   202004 #> B1      1 0.8949097 0.3342939      NaN #> B2      1       NaN       NaN 2.770456 #> B3      1 2.0200036 1.6353355 0.537996 #> B4    NaN       NaN       NaN 4.576286 # Make an aggregation structure from businesses to higher-level # industrial classifications  ms_weights #>   business classification weight #> 1       B1             11    553 #> 2       B2             11    646 #> 3       B3             11    312 #> 4       B4             12    622 #> 5       B5             12    330  ms_weights[c(\"level1\", \"level2\")] <-   expand_classification(ms_weights$classification)  pias <- ms_weights[c(\"level1\", \"level2\", \"business\", \"weight\")]  pias #>   level1 level2 business weight #> 1      1     11       B1    553 #> 2      1     11       B2    646 #> 3      1     11       B3    312 #> 4      1     12       B4    622 #> 5      1     12       B5    330 # Aggregate elemental indexes with an arithmetic index  index <- aggregate(elementals, pias, na.rm = TRUE)  # Chain them to get a time series  chain(index) #> Fixed-base price index for 8 levels over 4 time periods  #>    202001    202002    202003    202004 #> 1       1 1.3007239 1.3827662 3.7815355 #> 11      1 1.3007239 1.3827662 2.1771866 #> 12      1 1.3007239 1.3827662 6.3279338 #> B1      1 0.8949097 0.2991629 0.4710366 #> B2      1 1.3007239 1.3827662 3.8308934 #> B3      1 2.0200036 3.3033836 1.7772072 #> B4      1 1.3007239 1.3827662 6.3279338 #> B5      1 1.3007239 1.3827662 6.3279338"},{"path":"https://marberts.github.io/piar/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Price Index Aggregation","text":"contributions welcome. Please start opening issue GitHub report bugs suggest improvements new features. See contribution guidelines project information.","code":""},{"path":"https://marberts.github.io/piar/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Price Index Aggregation","text":"Balk, B. M. (2008). Price Quantity Index Numbers. Cambridge University Press. Chiru, R., Huang, N., Lequain, M. Smith, P., Wright, . (2015). Canadian Consumer Price Index Reference Paper, Statistics Canada catalogue 62-553-X. Statistics Canada. ILO, IMF, UNECE, OECD, World Bank. (2004). Producer Price Index Manual: Theory Practice. International Monetary Fund. IMF, ILO, Eurostat, UNECE, OECD, World Bank. (2020). Consumer Price Index Manual: Concepts Methods. International Monetary Fund. von der Lippe, P. (2007). Index Theory Price Statistics. Peter Lang.","code":""},{"path":"https://marberts.github.io/piar/reference/aggregate.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregate elemental price indexes — aggregate.piar_index","title":"Aggregate elemental price indexes — aggregate.piar_index","text":"Aggregate elemental price indexes price index aggregation structure.","code":""},{"path":"https://marberts.github.io/piar/reference/aggregate.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregate elemental price indexes — aggregate.piar_index","text":"","code":"# S3 method for class 'chainable_piar_index' aggregate(   x,   pias,   ...,   pias2 = NULL,   na.rm = FALSE,   contrib = TRUE,   r = 1,   include_ea = TRUE )  # S3 method for class 'direct_piar_index' aggregate(   x,   pias,   ...,   pias2 = NULL,   na.rm = FALSE,   contrib = TRUE,   r = 1,   include_ea = TRUE )"},{"path":"https://marberts.github.io/piar/reference/aggregate.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregate elemental price indexes — aggregate.piar_index","text":"x price index, usually made elemental_index(). pias price index aggregation structure something can coerced one. can made aggregation_structure(). ... currently used. pias2 optional secondary aggregation structure, usually current-period weights, make superlative index. See details. na.rm missing values removed? default, missing values removed. Setting na.rm = TRUE equivalent overall mean imputation. contrib Aggregate percent-change contributions x ()? r Order generalized mean aggregate index values. 0 geometric index (default making elemental indexes), 1 arithmetic index (default aggregating elemental indexes averaging indexes subperiods), -1 harmonic index (usually Paasche index). values possible; see gpindex::generalized_mean() details. pias2 given index aggregated quadratic mean order 2*r. include_ea indexes elemental aggregates included along aggregated indexes? default, index values returned.","code":""},{"path":"https://marberts.github.io/piar/reference/aggregate.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregate elemental price indexes — aggregate.piar_index","text":"aggregate price index inherits class x.","code":""},{"path":"https://marberts.github.io/piar/reference/aggregate.piar_index.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Aggregate elemental price indexes — aggregate.piar_index","text":"aggregate() method loops time period x aggregates elemental indexes gpindex::generalized_mean(r)() level pias; aggregates percent-change contributions level pias (contrib = TRUE); price updates weights pias gpindex::factor_weights(r)() (period--period elemental indexes). result collection aggregated period--period indexes can chained together get fixed-base index x period--period elemental indexes. Otherwise, x fixed-base elemental indexes, result collection aggregated fixed-base (direct) indexes. default, missing elemental indexes propagate aggregating index. Missing elemental indexes can due missingness values x, presence elemental aggregates pias part x. Setting na.rm = TRUE ignores missing values, equivalent parental (overall mean) imputation. aggregated price index generally missing values (otherwise chained time weights price updated), missing values level pias removed recursively replaced value immediate parent. cases aggregation done arithmetic mean (default), detailed chapter 8 (pp. 190–198) CPI manual (2020), analogous details chapter 9 PPI manual (2004). Aggregating non-arithmetic mean follows steps, except elemental indexes aggregated mean different order (e.g., harmonic Paasche index), method price updating weights slightly different. Note , aggregation done generalized mean, resulting index consistent--aggregation point time. Aggregating percent-change contributions uses method chapter 9 CPI manual (equations 9.26 9.28) aggregating arithmetic mean. non-arithmetic mean, arithmetic weights constructed using gpindex::transmute_weights(r, 1)() order apply method. may contributions prices relatives elemental aggregate elemental indexes built several sources (merge()). case contribution price relative aggregated index correct, sum contributions equal change value index. can also happen aggregating already aggregated index missing index values imputed (.e., na.rm = TRUE contrib = FALSE). two aggregation structures given steps done aggregation structure, aggregation pias done generalized mean order r aggregation pias2 done generalized mean order -r. resulting indexes combined geometric mean make superlative quadratic mean order 2*r index. Percent-change contributions combined using generalized van IJzeren decomposition; see gpindex::nested_transmute() details.","code":""},{"path":"https://marberts.github.io/piar/reference/aggregate.piar_index.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Aggregate elemental price indexes — aggregate.piar_index","text":"large indexes can much faster turn aggregation structure aggregation matrix .matrix(), aggregate elemental indexes matrix operation missing values. See examples details.","code":""},{"path":"https://marberts.github.io/piar/reference/aggregate.piar_index.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Aggregate elemental price indexes — aggregate.piar_index","text":"Balk, B. M. (2008). Price Quantity Index Numbers. Cambridge University Press. ILO, IMF, UNECE, OECD, World Bank. (2004). Producer Price Index Manual: Theory Practice. International Monetary Fund. IMF, ILO, OECD, Eurostat, UNECE, World Bank. (2020). Consumer Price Index Manual: Concepts Methods. International Monetary Fund. von der Lippe, P. (2007). Index Theory Price Statistics. Peter Lang.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/aggregate.piar_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregate elemental price indexes — aggregate.piar_index","text":"","code":"prices <- data.frame(   rel = 1:8,   period = rep(1:2, each = 4),   ea = rep(letters[1:2], 4) )  # A two-level aggregation structure  pias <- aggregation_structure(   list(c(\"top\", \"top\", \"top\"), c(\"a\", \"b\", \"c\")), weights = 1:3 )  # Calculate Jevons elemental indexes  (elemental <- elemental_index(prices, rel ~ period + ea)) #> Period-over-period price index for 2 levels over 2 time periods  #>          1        2 #> a 1.732051 5.916080 #> b 2.828427 6.928203  # Aggregate (note the imputation for elemental index 'c')  (index <- aggregate(elemental, pias, na.rm = TRUE)) #> Period-over-period price index for 4 levels over 2 time periods  #>            1        2 #> top 2.462968 6.690949 #> a   1.732051 5.916080 #> b   2.828427 6.928203 #> c   2.462968 6.690949  # Aggregation can equivalently be done as matrix multiplication  as.matrix(pias) %*% as.matrix(chain(index[letters[1:3]])) #>            1       2 #> top 2.462968 16.4796"},{"path":"https://marberts.github.io/piar/reference/aggregation_structure.html","id":null,"dir":"Reference","previous_headings":"","what":"Make a price index aggregation structure — aggregation_structure","title":"Make a price index aggregation structure — aggregation_structure","text":"Create price index aggregation structure hierarchical classification aggregation weights can used aggregate elemental indexes.","code":""},{"path":"https://marberts.github.io/piar/reference/aggregation_structure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make a price index aggregation structure — aggregation_structure","text":"","code":"aggregation_structure(x, weights = NULL)"},{"path":"https://marberts.github.io/piar/reference/aggregation_structure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make a price index aggregation structure — aggregation_structure","text":"x list character vectors give codes/labels level classification, ordered moving list goes hierarchy. last vector gives elemental aggregates, duplicates. vectors length, without NAs, duplicates across different levels x. Names x used level names; otherwise, levels named level1, level2, ..., ea. weights numeric vector aggregation weights elemental aggregates (.e., last vector x), something can coerced one. default give elemental aggregate weight.","code":""},{"path":"https://marberts.github.io/piar/reference/aggregation_structure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make a price index aggregation structure — aggregation_structure","text":"price index aggregation structure class piar_aggregation_structure. list-S3 class following components. child nested list gives positions immediate children node level aggregation structure terminal nodes. parent list gives position immediate parent node aggregation structure initial nodes. levels named list character vectors give levels x. weights vector giving weight elemental aggregate.","code":""},{"path":"https://marberts.github.io/piar/reference/aggregation_structure.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"Make a price index aggregation structure — aggregation_structure","text":"aggregation_structure() function best check arguments, expectation result aggregation_structure() make sense x represent nested hierarchy.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/aggregation_structure.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make a price index aggregation structure — aggregation_structure","text":"","code":"# A simple aggregation structure #            1 #      |-----+-----| #      11          12 #  |---+---|       | #  111     112     121 #  (1)     (3)     (4)  aggregation_weights <- data.frame(   level1 = c(\"1\", \"1\", \"1\"),   level2 = c(\"11\", \"11\", \"12\"),   ea     = c(\"111\", \"112\", \"121\"),   weight = c(1, 3, 4) )  aggregation_structure(   aggregation_weights[1:3],   weights = aggregation_weights[[4]] ) #> Aggregation structure for 3 elemental aggregates with 2 levels above the elemental aggregates  #>   level1 level2  ea weight #> 1      1     11 111      1 #> 2      1     11 112      3 #> 3      1     12 121      4  # The aggregation structure can also be made by expanding the # elemental aggregates  with(   aggregation_weights,   aggregation_structure(expand_classification(ea), weight) ) #> Aggregation structure for 3 elemental aggregates with 2 levels above the elemental aggregates  #>   level1 level2  ea weight #> 1      1     11 111      1 #> 2      1     11 112      3 #> 3      1     12 121      4"},{"path":"https://marberts.github.io/piar/reference/as.data.frame.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce an index into a tabular form — as.data.frame.piar_index","title":"Coerce an index into a tabular form — as.data.frame.piar_index","text":"Turn index data frame matrix.","code":""},{"path":"https://marberts.github.io/piar/reference/as.data.frame.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce an index into a tabular form — as.data.frame.piar_index","text":"","code":"# S3 method for class 'piar_index' as.data.frame(   x,   row.names = NULL,   optional = FALSE,   ...,   contrib = FALSE,   stringsAsFactors = FALSE )  # S3 method for class 'piar_index' as.matrix(x, ...)"},{"path":"https://marberts.github.io/piar/reference/as.data.frame.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce an index into a tabular form — as.data.frame.piar_index","text":"x price index, made , e.g., elemental_index(). row.names, stringsAsFactors See .data.frame(). optional currently used. ... currently used. contrib Include percent-change contributions (default include ).","code":""},{"path":"https://marberts.github.io/piar/reference/as.data.frame.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce an index into a tabular form — as.data.frame.piar_index","text":".data.frame() returns index values x data frame three columns: period, level, value. contrib = TRUE fourth (list) column contrib containing percent-change contributions. .matrix() returns index values x matrix row level column time period x.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/as.data.frame.piar_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce an index into a tabular form — as.data.frame.piar_index","text":"","code":"index <- as_index(matrix(1:6, 2))  as.data.frame(index) #>   period level value #> 1      1     1     1 #> 2      1     2     2 #> 3      2     1     3 #> 4      2     2     4 #> 5      3     1     5 #> 6      3     2     6  as.matrix(index) #>   1 2 3 #> 1 1 3 5 #> 2 2 4 6"},{"path":"https://marberts.github.io/piar/reference/as.matrix.piar_aggregation_structure.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce an aggregation structure into a tabular form — as.matrix.piar_aggregation_structure","title":"Coerce an aggregation structure into a tabular form — as.matrix.piar_aggregation_structure","text":"Coerce price index aggregation structure aggregation matrix, data frame.","code":""},{"path":"https://marberts.github.io/piar/reference/as.matrix.piar_aggregation_structure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce an aggregation structure into a tabular form — as.matrix.piar_aggregation_structure","text":"","code":"# S3 method for class 'piar_aggregation_structure' as.matrix(x, ..., sparse = FALSE)  # S3 method for class 'piar_aggregation_structure' as.data.frame(x, row.names = NULL, optional = FALSE, ...)"},{"path":"https://marberts.github.io/piar/reference/as.matrix.piar_aggregation_structure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce an aggregation structure into a tabular form — as.matrix.piar_aggregation_structure","text":"x price index aggregation structure, made aggregation_structure(). ... currently used matrix method. Extra arguments .data.frame.list() data frame method. sparse result sparse matrix Matrix? faster large aggregation structures. default returns ordinary dense matrix. row.names See .data.frame(). optional currently used.","code":""},{"path":"https://marberts.github.io/piar/reference/as.matrix.piar_aggregation_structure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce an aggregation structure into a tabular form — as.matrix.piar_aggregation_structure","text":".matrix() represents aggregation structure matrix, multiplying (column) vector elemental indexes gives aggregated index. .data.frame() takes aggregation structure returns data frame generated .","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/as.matrix.piar_aggregation_structure.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce an aggregation structure into a tabular form — as.matrix.piar_aggregation_structure","text":"","code":"# A simple aggregation structure #            1 #      |-----+-----| #      11          12 #  |---+---|       | #  111     112     121 #  (1)     (3)     (4)  aggregation_weights <- data.frame(   level1 = c(\"1\", \"1\", \"1\"),   level2 = c(\"11\", \"11\", \"12\"),   ea     = c(\"111\", \"112\", \"121\"),   weight = c(1, 3, 4) )  pias <- as_aggregation_structure(aggregation_weights)  as.matrix(pias) #>      111   112 121 #> 1  0.125 0.375 0.5 #> 11 0.250 0.750 0.0 #> 12 0.000 0.000 1.0  all.equal(as.data.frame(pias), aggregation_weights) #> [1] TRUE  if (FALSE) { # \\dontrun{ # Visualize as a treemap. treemap::treemap(   aggregation_weights,   index = names(aggregation_weights)[-4],   vSize = \"weight\",   title = \"aggregation structure\"    )  # Or turn into a more genereal tree object and plot. aggregation_weights$pathString <- do.call(   \\(...) paste(..., sep = \"/\"),   aggregation_weights[-4] ) plot(data.tree::as.Node(aggregation_weights)) } # }"},{"path":"https://marberts.github.io/piar/reference/as.ts.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce an index into a time series — as.ts.piar_index","title":"Coerce an index into a time series — as.ts.piar_index","text":"Turn index regular time series, represented ts object.","code":""},{"path":"https://marberts.github.io/piar/reference/as.ts.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce an index into a time series — as.ts.piar_index","text":"","code":"# S3 method for class 'piar_index' as.ts(x, ...)"},{"path":"https://marberts.github.io/piar/reference/as.ts.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce an index into a time series — as.ts.piar_index","text":"x price index, made , e.g., elemental_index(). ... Additional arguments passed ts().","code":""},{"path":"https://marberts.github.io/piar/reference/as.ts.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce an index into a time series — as.ts.piar_index","text":"time series object.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/as.ts.piar_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce an index into a time series — as.ts.piar_index","text":"","code":"as.ts(as_index(matrix(1:9, 3))) #> Time Series: #> Start = 1  #> End = 3  #> Frequency = 1  #>   1 2 3 #> 1 1 2 3 #> 2 4 5 6 #> 3 7 8 9"},{"path":"https://marberts.github.io/piar/reference/as_aggregation_structure.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to an aggregation structure — as_aggregation_structure","title":"Coerce to an aggregation structure — as_aggregation_structure","text":"Coerce object aggregation structure object.","code":""},{"path":"https://marberts.github.io/piar/reference/as_aggregation_structure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to an aggregation structure — as_aggregation_structure","text":"","code":"as_aggregation_structure(x, ...)  # Default S3 method as_aggregation_structure(x, ..., weights = NULL)  # S3 method for class 'data.frame' as_aggregation_structure(x, ...)  # S3 method for class 'matrix' as_aggregation_structure(x, ...)"},{"path":"https://marberts.github.io/piar/reference/as_aggregation_structure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to an aggregation structure — as_aggregation_structure","text":"x object coerce aggregation structure. ... arguments passed used methods. weights numeric vector aggregation weights elemental aggregates. default give elemental aggregate weight.","code":""},{"path":"https://marberts.github.io/piar/reference/as_aggregation_structure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to an aggregation structure — as_aggregation_structure","text":"price index aggregation structure inherits piar_aggregation_structure.","code":""},{"path":"https://marberts.github.io/piar/reference/as_aggregation_structure.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Coerce to an aggregation structure — as_aggregation_structure","text":"default method attempts coerce x list prior calling aggregation_structure(). data frame matrix methods treat x table row elemental aggregate, column labels level aggregation structure, column weights elemental aggregates.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/as_aggregation_structure.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce to an aggregation structure — as_aggregation_structure","text":"","code":"# A simple aggregation structure #            1 #      |-----+-----| #      11          12 #  |---+---|       | #  111     112     121 #  (1)     (3)     (4)  aggregation_weights <- data.frame(   level1 = c(\"1\", \"1\", \"1\"),   level2 = c(\"11\", \"11\", \"12\"),   ea     = c(\"111\", \"112\", \"121\"),   weight = c(1, 3, 4) )  pias <- aggregation_structure(   aggregation_weights[1:3],   weights = aggregation_weights[[4]] )  all.equal(   pias,   as_aggregation_structure(aggregation_weights) ) #> [1] TRUE  all.equal(   pias,   as_aggregation_structure(as.matrix(aggregation_weights)) ) #> [1] TRUE"},{"path":"https://marberts.github.io/piar/reference/as_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to a price index — as_index","title":"Coerce to a price index — as_index","text":"Coerce pre-computed index values index object.","code":""},{"path":"https://marberts.github.io/piar/reference/as_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to a price index — as_index","text":"","code":"as_index(x, ...)  # Default S3 method as_index(x, ...)  # S3 method for class 'matrix' as_index(x, ..., chainable = TRUE, contrib = FALSE)  # S3 method for class 'data.frame' as_index(x, ..., contrib = FALSE)  # S3 method for class 'chainable_piar_index' as_index(x, ..., chainable = TRUE)  # S3 method for class 'direct_piar_index' as_index(x, ..., chainable = FALSE)  # S3 method for class 'mts' as_index(x, ...)"},{"path":"https://marberts.github.io/piar/reference/as_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to a price index — as_index","text":"x object coerce price index. ... arguments passed used methods. chainable index values x period--period indexes, suitable chained calculation (default)? FALSE x contains fixed-base (direct) index values. contrib index values x used construct percent-change contributions? default make contributions.","code":""},{"path":"https://marberts.github.io/piar/reference/as_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to a price index — as_index","text":"price index inherits piar_index. chainable = TRUE period--period price index also inherits chainable_piar_index; otherwise, fixed-base index inherits direct_piar_index.","code":""},{"path":"https://marberts.github.io/piar/reference/as_index.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Coerce to a price index — as_index","text":"Numeric matrices coerced index object treating column separate time period, row separate level index (e.g., elemental aggregate). Column names used denote time periods, row names used denote levels (must unique). essentially reverses calling .matrix() index object. dimension unnamed, given sequential label 1 size dimension. default multiple time series methods coerces x matrix prior using matrix method. data frame method as_index() best understood reversing effect .data.frame() index object. constructs matrix taking levels x[[1]] columns levels x[[2]] rows (coercing factor necessary). populates matrix corresponding values x[[3]], uses matrix method as_index(). contrib = TRUE fourth list column product contributions also included resulting index. x period--period index returned unchanged chainable = TRUE chained otherwise. Similarly, x fixed-base index returned unchanged chainable = FALSE unchain otherwise.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/as_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce to a price index — as_index","text":"","code":"prices <- data.frame(   rel = 1:8,   period = rep(1:2, each = 4),   ea = rep(letters[1:2], 4) )  index <- elemental_index(prices, rel ~ period + ea)  all.equal(as_index(as.data.frame(index)), index) #> [1] TRUE all.equal(as_index(as.matrix(index)), index) #> [1] TRUE"},{"path":"https://marberts.github.io/piar/reference/chain.html","id":null,"dir":"Reference","previous_headings":"","what":"Chain and rebase a price index — chain","title":"Chain and rebase a price index — chain","text":"Chain period--period index taking cumulative product values turn fixed-base (direct) index. Unchain fixed-base index dividing values successive periods get period--period index. Rebase fixed-base index dividing values value index new base period.","code":""},{"path":"https://marberts.github.io/piar/reference/chain.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chain and rebase a price index — chain","text":"","code":"chain(x, ...)  # Default S3 method chain(x, ...)  # S3 method for class 'chainable_piar_index' chain(x, link = rep(1, nlevels(x)), ...)  unchain(x, ...)  # Default S3 method unchain(x, ...)  # S3 method for class 'direct_piar_index' unchain(x, base = rep(1, nlevels(x)), ...)  rebase(x, ...)  # Default S3 method rebase(x, ...)  # S3 method for class 'direct_piar_index' rebase(x, base = rep(1, nlevels(x)), ...)"},{"path":"https://marberts.github.io/piar/reference/chain.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chain and rebase a price index — chain","text":"x price index, made , e.g., elemental_index(). ... arguments passed used methods. link numeric vector, something can coerced one, link values level x. default vector 1s linking done. base numeric vector, something can coerced one, base-period index values level x. default vector 1s base period remains . base length-one character vector giving time period x index values time period used base-period values.","code":""},{"path":"https://marberts.github.io/piar/reference/chain.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chain and rebase a price index — chain","text":"chain() rebase() return fixed-base index inherits direct_piar_index. unchain() returns period--period index inherits chainable_piar_index.","code":""},{"path":"https://marberts.github.io/piar/reference/chain.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chain and rebase a price index — chain","text":"default methods attempt coerce x index as_index() prior chaining/unchaining/rebasing. Chaining index takes cumulative product index values level; roughly t(apply(.matrix(x), 1, cumprod)) * link. Unchaining opposite, inverse operations. Note unchaining period--period index nothing, chaining fixed-base index. Rebasing fixed-base index divides values level index corresponding values level new base period. roughly .matrix(x) / base. Like unchaining, rebasing period--period index nothing. Percent-change contributions removed chaining/unchaining/rebasing index usually possible update correctly.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/chain.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chain and rebase a price index — chain","text":"","code":"index <- as_index(matrix(1:9, 3))  # Make period 0 the fixed base period  chain(index) #> Fixed-base price index for 3 levels over 3 time periods  #>   1  2   3 #> 1 1  4  28 #> 2 2 10  80 #> 3 3 18 162  # Chaining and unchaining reverse each other  all.equal(index, unchain(chain(index))) #> [1] TRUE  # Change the base period to period 2 (note the # loss of information for period 0)  index <- chain(index) rebase(index, index[, 2]) #> Fixed-base price index for 3 levels over 3 time periods  #>           1 2 3 #> 1 0.2500000 1 7 #> 2 0.2000000 1 8 #> 3 0.1666667 1 9"},{"path":"https://marberts.github.io/piar/reference/contrib.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract percent-change contributions — contrib","title":"Extract percent-change contributions — contrib","text":"Extract matrix data frame percent-change contributions price index.","code":""},{"path":"https://marberts.github.io/piar/reference/contrib.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract percent-change contributions — contrib","text":"","code":"contrib(x, ...)  # S3 method for class 'piar_index' contrib(x, level = levels(x)[1L], period = time(x), ..., pad = 0)  contrib2DF(x, ...)  # S3 method for class 'piar_index' contrib2DF(x, level = levels(x)[1L], period = time(x), ...)  contrib(x, ...) <- value  # S3 method for class 'piar_index' contrib(x, level = levels(x)[1L], period = time(x), ...) <- value  set_contrib(x, ..., value)  set_contrib_from_index(x)"},{"path":"https://marberts.github.io/piar/reference/contrib.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract percent-change contributions — contrib","text":"x price index, made , e.g., elemental_index(). ... arguments passed used methods. level level index percent-change contributions desired, defaulting first level (usually top-level aggregate index). contrib2DF() can accept multiple levels. period time periods percent-change contributions desired, defaulting time periods. pad numeric value pad contributions fit rectangular array products differ time. default 0. value numeric matrix replacement contributions row product column time period. Recycling occurs along time periods.","code":""},{"path":"https://marberts.github.io/piar/reference/contrib.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract percent-change contributions — contrib","text":"contrib() returns matrix percent-change contributions column period row product (sorted) contributions level. Contributions padded pad fit rectangular array products differ time. replacement methods returns copy x contributions given matrix value. (set_contrib() alias easier use pipes.) set_contrib_from_index() helper return copy x contributions set corresponding index value minus 1. contrib2DF() returns data frame contributions four columns: period, level, product, value.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/contrib.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract percent-change contributions — contrib","text":"","code":"prices <- data.frame(   rel = 1:8,   period = rep(1:2, each = 4),   ea = rep(letters[1:2], 4) )  index <- elemental_index(prices, rel ~ period + ea, contrib = TRUE)  pias <- aggregation_structure(   list(c(\"top\", \"top\", \"top\"), c(\"a\", \"b\", \"c\")), weights = 1:3 )  index <- aggregate(index, pias, na.rm = TRUE)  # Percent-change contributions for the top-level index  contrib(index) #>             1         2 #> a.1 0.0000000 0.5081686 #> a.2 0.2440169 0.6442213 #> b.1 0.3905243 2.0513858 #> b.2 0.8284271 2.4871732  contrib2DF(index) #>   period level product     value #> 1      1   top     a.1 0.0000000 #> 2      1   top     a.2 0.2440169 #> 3      1   top     b.1 0.3905243 #> 4      1   top     b.2 0.8284271 #> 5      2   top     a.1 0.5081686 #> 6      2   top     a.2 0.6442213 #> 7      2   top     b.1 2.0513858 #> 8      2   top     b.2 2.4871732  # Calculate EA contributions for the chained index  library(gpindex)  arithmetic_contributions(   as.matrix(chain(index))[c(\"a\", \"b\", \"c\"), 2],   weights(pias) ) #>        a        b        c  #> 1.541158 6.198639 7.739798"},{"path":"https://marberts.github.io/piar/reference/cut.piar_aggregation_structure.html","id":null,"dir":"Reference","previous_headings":"","what":"Cut an aggregation structure — cut.piar_aggregation_structure","title":"Cut an aggregation structure — cut.piar_aggregation_structure","text":"Keep part aggregation structure certain level.","code":""},{"path":"https://marberts.github.io/piar/reference/cut.piar_aggregation_structure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cut an aggregation structure — cut.piar_aggregation_structure","text":"","code":"# S3 method for class 'piar_aggregation_structure' cut(x, level, ..., na.rm = FALSE, upper = TRUE)"},{"path":"https://marberts.github.io/piar/reference/cut.piar_aggregation_structure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cut an aggregation structure — cut.piar_aggregation_structure","text":"x price index aggregation structure, made aggregation_structure(). level positive integer, something can coerced one, giving level cut x. ... currently used. na.rm missing values removed aggregating weights? default, missing values removed. upper Keep part x level (default); otherwise, return part x level.","code":""},{"path":"https://marberts.github.io/piar/reference/cut.piar_aggregation_structure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cut an aggregation structure — cut.piar_aggregation_structure","text":"price index aggregation structure.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/cut.piar_aggregation_structure.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cut an aggregation structure — cut.piar_aggregation_structure","text":"","code":"# A simple aggregation structure #            1 #      |-----+-----| #      11          12 #  |---+---|       | #  111     112     121 #  (1)     (3)     (4)  aggregation_weights <- data.frame(   level1 = c(\"1\", \"1\", \"1\"),   level2 = c(\"11\", \"11\", \"12\"),   ea     = c(\"111\", \"112\", \"121\"),   weight = c(1, 3, 4) )  pias <- aggregation_structure(   aggregation_weights[1:3],   weights = aggregation_weights[[4]] )  # Turn it into #            1 #      |-----+-----| #      11          12 #     (4)         (4)  cut(pias, 2) #> Aggregation structure for 2 elemental aggregates with 1 levels above the elemental aggregates  #>   level1 level2 weight #> 1      1     11      4 #> 2      1     12      4"},{"path":"https://marberts.github.io/piar/reference/elemental_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Make elemental/elementary price indexes — elemental_index","title":"Make elemental/elementary price indexes — elemental_index","text":"Compute period--period (chainable) fixed-base (direct) elemental price indexes, optional percent-change contributions product.","code":""},{"path":"https://marberts.github.io/piar/reference/elemental_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make elemental/elementary price indexes — elemental_index","text":"","code":"elemental_index(x, ...)  # Default S3 method elemental_index(x, ...)  # S3 method for class 'numeric' elemental_index(   x,   ...,   period = gl(1, length(x)),   ea = gl(1, length(x)),   weights = NULL,   product = NULL,   chainable = TRUE,   na.rm = FALSE,   contrib = FALSE,   r = 0 )  # S3 method for class 'data.frame' elemental_index(x, formula, ..., weights = NULL, product = NULL)  elementary_index(x, ...)"},{"path":"https://marberts.github.io/piar/reference/elemental_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make elemental/elementary price indexes — elemental_index","text":"x Period--period fixed-base price relatives. Currently methods numeric vectors (can made price_relative()) data frames. ... arguments passed used methods. period factor, something can coerced one, giving time period associated price relative x. ordering time periods follows levels period, agree cut(). default makes index one time period. ea factor, something can coerced one, giving elemental aggregate associated price relative x. default makes index one elemental aggregate. weights numeric vector weights price relatives x, something can coerced one. default equal weights. evaluated x data frame method. product character vector product names, something can coerced one, price relative x making percent-change contributions. default uses names x, ; otherwise, elements x given sequential names within elemental aggregate. evaluated x data frame method. chainable price relatives x period--period relatives suitable chained calculation (default)? FALSE x contains fixed-base relatives. na.rm missing values removed? default, missing values removed. Setting na.rm = TRUE equivalent overall mean imputation. contrib percent-change contributions calculated? default calculate contributions. r Order generalized mean aggregate price relatives. 0 geometric index (default making elemental indexes), 1 arithmetic index (default aggregating elemental indexes averaging indexes subperiods), -1 harmonic index (usually Paasche index). values possible; see gpindex::generalized_mean() details. formula two-sided formula price relatives left-hand side, time periods elemental aggregates (order) right-hand side.","code":""},{"path":"https://marberts.github.io/piar/reference/elemental_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make elemental/elementary price indexes — elemental_index","text":"price index inherits piar_index. chainable = TRUE period--period index also inherits chainable_piar_index; otherwise, fixed-based index inherits direct_piar_index.","code":""},{"path":"https://marberts.github.io/piar/reference/elemental_index.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Make elemental/elementary price indexes — elemental_index","text":"supplied numeric vector, elemental_index() simple wrapper applies gpindex::generalized_mean(r)() gpindex::contributions(r)() (contrib = TRUE) x weights grouped ea period. , every combination elemental aggregate time period, elemental_index() calculates index based generalized mean order r , optionally, percent-change contributions. Product names unique within time period making contributions, , , passed make.unique() warning. default (r = 0 weights) makes Jevons elemental indexes. See chapter 8 (pp. 175–190) CPI manual (2020) detail making elemental indexes, chapter 9 PPI manual (2004), chapter 5 Balk (2008). default method simply coerces x numeric vector prior calling method . data frame method provides formula interface specify columns price relatives, time periods, elemental aggregates call method . interpretation index depends price relatives x made. period--period relatives, result collection period--period (chainable) elemental indexes; fixed-base relatives, result collection fixed-base (direct) elemental indexes. latter, chainable set FALSE subsequent methods assume chained calculation used. default, missing price relatives x propagate throughout index calculation. Ignoring missing values na.rm = TRUE overall mean (parental) imputation, needs explicitly set call elemental_index(). Explicit imputation missing relatives, especially imputation missing prices, done prior calling elemental_index(). Indexes based nested generalized means, like Fisher index (superlative quadratic mean indexes generally), can calculated supplying appropriate weights gpindex::nested_transmute(); see example . important note several ways make weights, affects percent-change contributions calculated. elementary_index() alias elemental_index() common literature.","code":""},{"path":"https://marberts.github.io/piar/reference/elemental_index.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Make elemental/elementary price indexes — elemental_index","text":"Balk, B. M. (2008). Price Quantity Index Numbers. Cambridge University Press. ILO, IMF, UNECE, OECD, World Bank. (2004). Producer Price Index Manual: Theory Practice. International Monetary Fund. IMF, ILO, OECD, Eurostat, UNECE, World Bank. (2020). Consumer Price Index Manual: Concepts Methods. International Monetary Fund. von der Lippe, P. (2007). Index Theory Price Statistics. Peter Lang.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/elemental_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make elemental/elementary price indexes — elemental_index","text":"","code":"library(gpindex)  prices <- data.frame(   rel = 1:8,   period = rep(1:2, each = 4),   ea = rep(letters[1:2], 4) )  # Calculate Jevons elemental indexes  elemental_index(prices, rel ~ period + ea) #> Period-over-period price index for 2 levels over 2 time periods  #>          1        2 #> a 1.732051 5.916080 #> b 2.828427 6.928203  # Same as using lm() or tapply()  exp(coef(lm(log(rel) ~ ea:factor(period) - 1, prices))) #> eaa:factor(period)1 eab:factor(period)1 eaa:factor(period)2 eab:factor(period)2  #>            1.732051            2.828427            5.916080            6.928203   with(   prices,   t(tapply(rel, list(period, ea), geometric_mean, na.rm = TRUE)) ) #>          1        2 #> a 1.732051 5.916080 #> b 2.828427 6.928203  # A general function to calculate weights to turn the geometric # mean of the arithmetic and harmonic mean (i.e., Fisher mean) # into an arithmetic mean  fw <- grouped(nested_transmute(0, c(1, -1), 1))  # Calculate a CSWD index (same as the Jevons in this example) # as an arithmetic index by using the appropriate weights  elemental_index(   prices,   rel ~ period + ea,   weights = fw(rel, group = interaction(period, ea)),   r = 1 ) #> Period-over-period price index for 2 levels over 2 time periods  #>          1        2 #> a 1.732051 5.916080 #> b 2.828427 6.928203"},{"path":"https://marberts.github.io/piar/reference/expand_classification.html","id":null,"dir":"Reference","previous_headings":"","what":"Expand a hierarchical classification — expand_classification","title":"Expand a hierarchical classification — expand_classification","text":"Expand character representation hierarchical classification make price index aggregation structure. Expanded classifications interacted together get combinations aggregation structures.","code":""},{"path":"https://marberts.github.io/piar/reference/expand_classification.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expand a hierarchical classification — expand_classification","text":"","code":"expand_classification(x, width = 1L)  interact_classifications(..., sep = \":\")"},{"path":"https://marberts.github.io/piar/reference/expand_classification.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expand a hierarchical classification — expand_classification","text":"x character vector, something can coerced one, codes/labels specific level classification (e.g., 5-digit COICOP, 5-digit NAICS, 4-digit SIC). width integer vector gives width digit x. single value recycled span longest element x. contain NAs. default assumes digit width 1, NAICS, NAPCS, SIC classifications. ... Lists character vectors give codes/labels level classification, ordered moving list goes hierarchy (made expand_classification()). sep character used combine codes/labels across elements .... default uses \":\".","code":""},{"path":"https://marberts.github.io/piar/reference/expand_classification.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expand a hierarchical classification — expand_classification","text":"expand_classification() returns list entry level x giving \"digits\" represent level hierarchy. interact_classfications() returns list lists structure expand_classification().","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/expand_classification.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Expand a hierarchical classification — expand_classification","text":"","code":"# A simple classification structure #            1 #      |-----+-----| #      11          12 #  |---+---|       | #  111     112     121  expand_classification(c(\"111\", \"112\", \"121\")) #> [[1]] #> [1] \"1\" \"1\" \"1\" #>  #> [[2]] #> [1] \"11\" \"11\" \"12\" #>  #> [[3]] #> [1] \"111\" \"112\" \"121\" #>   # Expanding more complex classifications # ... if last 'digit' is either TA or TS  expand_classification(   c(\"111TA\", \"112TA\", \"121TS\"),   width = c(1, 1, 1, 2) ) #> [[1]] #> [1] \"1\" \"1\" \"1\" #>  #> [[2]] #> [1] \"11\" \"11\" \"12\" #>  #> [[3]] #> [1] \"111\" \"112\" \"121\" #>  #> [[4]] #> [1] \"111TA\" \"112TA\" \"121TS\" #>   # ... if first 'digit' is either 11 or 12  expand_classification(c(\"111\", \"112\", \"121\"), width = c(2, 1)) #> [[1]] #> [1] \"11\" \"11\" \"12\" #>  #> [[2]] #> [1] \"111\" \"112\" \"121\" #>   # ...if there are delimiters in the classification (like COICOP)  expand_classification(c(\"01.1.1\", \"01.1.2\", \"01.2.1\"), width = 2) #> [[1]] #> [1] \"01\" \"01\" \"01\" #>  #> [[2]] #> [1] \"01.1\" \"01.1\" \"01.2\" #>  #> [[3]] #> [1] \"01.1.1\" \"01.1.2\" \"01.2.1\" #>"},{"path":"https://marberts.github.io/piar/reference/head.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Return the first/last parts of an index — head.piar_index","title":"Return the first/last parts of an index — head.piar_index","text":"Extract first/last parts index matrix.","code":""},{"path":"https://marberts.github.io/piar/reference/head.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return the first/last parts of an index — head.piar_index","text":"","code":"# S3 method for class 'piar_index' head(x, n = 6L, ...)  # S3 method for class 'piar_index' tail(x, n = 6L, ...)"},{"path":"https://marberts.github.io/piar/reference/head.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return the first/last parts of an index — head.piar_index","text":"x price index, made , e.g., elemental_index(). n See head()/tail(). default takes first/last 6 levels x. ... currently used.","code":""},{"path":"https://marberts.github.io/piar/reference/head.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return the first/last parts of an index — head.piar_index","text":"price index inherits class x.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/head.piar_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Return the first/last parts of an index — head.piar_index","text":"","code":"index <- as_index(matrix(1:9, 3))  head(index, 1) #> Period-over-period price index for 1 levels over 3 time periods  #>   1 2 3 #> 1 1 4 7  tail(index, 1) #> Period-over-period price index for 1 levels over 3 time periods  #>   1 2 3 #> 3 3 6 9"},{"path":"https://marberts.github.io/piar/reference/impute_prices.html","id":null,"dir":"Reference","previous_headings":"","what":"Impute missing prices — impute_prices","title":"Impute missing prices — impute_prices","text":"Impute missing prices using carry forward shadow price method.","code":""},{"path":"https://marberts.github.io/piar/reference/impute_prices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Impute missing prices — impute_prices","text":"","code":"shadow_price(x, ...)  # Default S3 method shadow_price(   x,   ...,   period,   product,   ea,   pias = NULL,   weights = NULL,   r1 = 0,   r2 = 1 )  # S3 method for class 'data.frame' shadow_price(x, formula, ..., weights = NULL)  carry_forward(x, ...)  # Default S3 method carry_forward(x, ..., period, product)  # S3 method for class 'data.frame' carry_forward(x, formula, ...)  carry_backward(x, ...)  # Default S3 method carry_backward(x, ..., period, product)  # S3 method for class 'data.frame' carry_backward(x, formula, ...)"},{"path":"https://marberts.github.io/piar/reference/impute_prices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Impute missing prices — impute_prices","text":"x Either numeric vector (something can coerced one) data frame prices. ... arguments passed used methods. period factor, something can coerced one, giving time period associated price x. ordering time periods follows levels period, agree cut(). product factor, something can coerced one, giving product associated price x. ea factor, something can coerced one, giving elemental aggregate associated price x. pias price index aggregation structure, something can coerced one, made aggregation_structure(). default imputes elemental indexes (.e., recursively). weights numeric vector weights prices x (.e., product weights), something can coerced one. default give price equal weight. evaluated x data frame method. r1 Order generalized-mean price index used calculate elemental price indexes: 0 geometric index (default), 1 arithmetic index, -1 harmonic index. values possible; see gpindex::generalized_mean() details. r2 Order generalized-mean price index used aggregate elemental price indexes: 0 geometric index, 1 arithmetic index (default), -1 harmonic index. values possible; see gpindex::generalized_mean() details. formula two-sided formula prices left-hand side. carry_forward() carry_backward(), right-hand side time periods products (order); shadow_price(), right-hand side time period, products, elemental aggregates (order).","code":""},{"path":"https://marberts.github.io/piar/reference/impute_prices.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Impute missing prices — impute_prices","text":"numeric vector prices missing values replaced (possible).","code":""},{"path":"https://marberts.github.io/piar/reference/impute_prices.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Impute missing prices — impute_prices","text":"carry forward method replaces missing price product price product previous period. tends push index value towards 1, usually avoided; see paragraph 6.61 CPI manual (2020). carry backwards method opposite, rarely used practice. shadow price method recursively imputes missing price value price product previous period multiplied value period--period elemental index elemental aggregate product belongs. requires computing aggregating index (according pias, unless pias supplied) period, imputations can take . index values used imputations returned index needs recalculated get correct percent-change contributions. Shadow price imputation referred self-correcting overall mean imputation chapter 6 CPI manual (2020). identical simply excluding missing price relatives index calculation, except period missing product returns. reason care needed using method. sensitive assumption product change time, cases safer simply omit missing price relatives instead imputing missing prices.","code":""},{"path":"https://marberts.github.io/piar/reference/impute_prices.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Impute missing prices — impute_prices","text":"IMF, ILO, OECD, Eurostat, UNECE, World Bank. (2020). Consumer Price Index Manual: Concepts Methods. International Monetary Fund.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/impute_prices.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Impute missing prices — impute_prices","text":"","code":"prices <- data.frame(   price = c(1:7, NA),   period = rep(1:2, each = 4),   product = 1:4,   ea = rep(letters[1:2], 4) )  carry_forward(prices, price ~ period + product) #> [1] 1 2 3 4 5 6 7 4  shadow_price(prices, price ~ period + product + ea) #> [1]  1  2  3  4  5  6  7 12"},{"path":"https://marberts.github.io/piar/reference/is.na.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Missing values in a price index — is.na.piar_index","title":"Missing values in a price index — is.na.piar_index","text":"Identify missing values price index.","code":""},{"path":"https://marberts.github.io/piar/reference/is.na.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Missing values in a price index — is.na.piar_index","text":"","code":"# S3 method for class 'piar_index' is.na(x)  # S3 method for class 'piar_index' anyNA(x, recursive = FALSE)"},{"path":"https://marberts.github.io/piar/reference/is.na.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Missing values in a price index — is.na.piar_index","text":"x price index, made , e.g., elemental_index(). recursive Check x also missing percent-change contributions. default index values checked missingness.","code":""},{"path":"https://marberts.github.io/piar/reference/is.na.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Missing values in a price index — is.na.piar_index","text":".na() returns logical matrix, row level x columns time period, indicates index values missing. anyNA() returns TRUE index values missing, percent-change contributions (recursive = TRUE).","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/is.na.piar_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Missing values in a price index — is.na.piar_index","text":"","code":"index <- as_index(matrix(c(1, 2, 3, NA, 5, NA), 2))  anyNA(index) #> [1] TRUE is.na(index) #>       1     2     3 #> 1 FALSE FALSE FALSE #> 2 FALSE  TRUE  TRUE  # Carry forward imputation  index[is.na(index)] <- 1 index #> Period-over-period price index for 2 levels over 3 time periods  #>   1 2 3 #> 1 1 3 5 #> 2 2 1 1"},{"path":"https://marberts.github.io/piar/reference/is_aggregation_structure.html","id":null,"dir":"Reference","previous_headings":"","what":"Test if an object is an aggregation structure — is_aggregation_structure","title":"Test if an object is an aggregation structure — is_aggregation_structure","text":"Test object price index aggregation structure.","code":""},{"path":"https://marberts.github.io/piar/reference/is_aggregation_structure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test if an object is an aggregation structure — is_aggregation_structure","text":"","code":"is_aggregation_structure(x)"},{"path":"https://marberts.github.io/piar/reference/is_aggregation_structure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test if an object is an aggregation structure — is_aggregation_structure","text":"x object test.","code":""},{"path":"https://marberts.github.io/piar/reference/is_aggregation_structure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test if an object is an aggregation structure — is_aggregation_structure","text":"Returns TRUE x inherits piar_aggregation_structure.","code":""},{"path":"https://marberts.github.io/piar/reference/is_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Test if an object is a price index — is_index","title":"Test if an object is a price index — is_index","text":"Test object index object subclass index object.","code":""},{"path":"https://marberts.github.io/piar/reference/is_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test if an object is a price index — is_index","text":"","code":"is_index(x)  is_chainable_index(x)  is_direct_index(x)"},{"path":"https://marberts.github.io/piar/reference/is_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test if an object is a price index — is_index","text":"x object test.","code":""},{"path":"https://marberts.github.io/piar/reference/is_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test if an object is a price index — is_index","text":"is_index() returns TRUE x inherits piar_index. is_chainable_index() returns TRUE x inherits chainable_piar_index. is_direct_index() returns TRUE x inherits direct_piar_index.","code":""},{"path":"https://marberts.github.io/piar/reference/levels.piar_aggregation_structure.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the levels for an aggregation structure — levels.piar_aggregation_structure","title":"Get the levels for an aggregation structure — levels.piar_aggregation_structure","text":"Get hierarchical list levels aggregation structure. error try replace values.","code":""},{"path":"https://marberts.github.io/piar/reference/levels.piar_aggregation_structure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the levels for an aggregation structure — levels.piar_aggregation_structure","text":"","code":"# S3 method for class 'piar_aggregation_structure' levels(x)"},{"path":"https://marberts.github.io/piar/reference/levels.piar_aggregation_structure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the levels for an aggregation structure — levels.piar_aggregation_structure","text":"x price index aggregation structure, made aggregation_structure().","code":""},{"path":"https://marberts.github.io/piar/reference/levels.piar_aggregation_structure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the levels for an aggregation structure — levels.piar_aggregation_structure","text":"list character vectors giving levels position aggregation structure.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/levels.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the levels for a price index — levels.piar_index","title":"Get the levels for a price index — levels.piar_index","text":"Methods get set levels price index.","code":""},{"path":"https://marberts.github.io/piar/reference/levels.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the levels for a price index — levels.piar_index","text":"","code":"# S3 method for class 'piar_index' levels(x)  # S3 method for class 'piar_index' levels(x) <- value  set_levels(x, value)"},{"path":"https://marberts.github.io/piar/reference/levels.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the levels for a price index — levels.piar_index","text":"x price index, made , e.g., elemental_index(). value character vector, something can coerced one, giving replacement levels x.","code":""},{"path":"https://marberts.github.io/piar/reference/levels.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the levels for a price index — levels.piar_index","text":"levels() returns character vector levels price index. replacement method returns copy x levels value. (set_levels() alias easier use pipes.)","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/mean.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregate a price index over subperiods — mean.piar_index","title":"Aggregate a price index over subperiods — mean.piar_index","text":"Aggregate index subperiods taking (usually arithmetic) mean index values consecutive windows subperiods.","code":""},{"path":"https://marberts.github.io/piar/reference/mean.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregate a price index over subperiods — mean.piar_index","text":"","code":"# S3 method for class 'chainable_piar_index' mean(   x,   ...,   weights = NULL,   window = ntime(x),   na.rm = FALSE,   contrib = TRUE,   r = 1 )  # S3 method for class 'direct_piar_index' mean(   x,   ...,   weights = NULL,   window = ntime(x),   na.rm = FALSE,   contrib = TRUE,   r = 1 )"},{"path":"https://marberts.github.io/piar/reference/mean.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregate a price index over subperiods — mean.piar_index","text":"x price index, made , e.g., elemental_index(). ... currently used. weights numeric vector weights index values x, something can coerced one. default equal weights. usually easiest specify weights matrix row index value x column time period. window positive integer giving size window used average index values across subperiods. default averages periods x. Non-integers truncated towards 0. na.rm missing values removed? default, missing values removed. Setting na.rm = TRUE equivalent overall mean imputation. contrib Aggregate percent-change contributions x ()? r Order generalized mean aggregate index values. 0 geometric index (default making elemental indexes), 1 arithmetic index (default aggregating elemental indexes averaging indexes subperiods), -1 harmonic index (usually Paasche index). values possible; see gpindex::generalized_mean() details.","code":""},{"path":"https://marberts.github.io/piar/reference/mean.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregate a price index over subperiods — mean.piar_index","text":"price index, averaged subperiods, inherits class x.","code":""},{"path":"https://marberts.github.io/piar/reference/mean.piar_index.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Aggregate a price index over subperiods — mean.piar_index","text":"mean() method constructs set non-overlapping windows length window, starting first period index, takes mean index value windows level index. last window discarded incomplete (warning), index values always averaged window periods. names first time period window form new names aggregated time periods. Percent-change contributions aggregated contrib = TRUE treating product-subperiod pair unique product, following approach aggregate(). number subperiod appended product names make unique across subperiods. optional vector weights can specified aggregating index values subperiods, often useful aggregating Paasche index; see section 4.3 Balk (2008) details.","code":""},{"path":"https://marberts.github.io/piar/reference/mean.piar_index.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Aggregate a price index over subperiods — mean.piar_index","text":"Balk, B. M. (2008). Price Quantity Index Numbers. Cambridge University Press.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/mean.piar_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregate a price index over subperiods — mean.piar_index","text":"","code":"index <- as_index(matrix(c(1:12, 12:1), 2, byrow = TRUE))  # Turn a monthly index into a quarterly index mean(index, window = 3) #> Period-over-period price index for 2 levels over 4 time periods  #>    1 4 7 10 #> 1  2 5 8 11 #> 2 11 8 5  2"},{"path":"https://marberts.github.io/piar/reference/merge.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge price indexes — merge.piar_index","title":"Merge price indexes — merge.piar_index","text":"Combine two price indexes common time periods, merging together index values percent-change contributions time period. useful building index different elemental aggregates come different sources data, use different index-number formulas.","code":""},{"path":"https://marberts.github.io/piar/reference/merge.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge price indexes — merge.piar_index","text":"","code":"# S3 method for class 'chainable_piar_index' merge(x, y, ...)  # S3 method for class 'direct_piar_index' merge(x, y, ...)"},{"path":"https://marberts.github.io/piar/reference/merge.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge price indexes — merge.piar_index","text":"x price index, made , e.g., elemental_index(). y price index, something can coerced one. x period--period index y coerced chainable index; otherwise, y coerced direct index. ... currently used.","code":""},{"path":"https://marberts.github.io/piar/reference/merge.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge price indexes — merge.piar_index","text":"combined price index inherits class x.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/merge.piar_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Merge price indexes — merge.piar_index","text":"","code":"index1 <- as_index(matrix(1:6, 2))  index2 <- index1 levels(index2) <- 3:4  merge(index1, index2) #> Period-over-period price index for 4 levels over 3 time periods  #>   1 2 3 #> 1 1 3 5 #> 2 2 4 6 #> 3 1 3 5 #> 4 2 4 6"},{"path":"https://marberts.github.io/piar/reference/piar-package.html","id":null,"dir":"Reference","previous_headings":"","what":"piar: Price Index Aggregation — piar-package","title":"piar: Price Index Aggregation — piar-package","text":"price indexes made two-step procedure, period--period elemental indexes first calculated collection elemental aggregates point time, aggregated according price index aggregation structure. indexes can chained together form time series gives evolution prices respect fixed base period. package contains collection functions revolve around work flow, making easy build standard price indexes, implement methods described Balk (2008, doi:10.1017/CBO9780511720758 ), von der Lippe (2007, doi:10.3726/978-3-653-01120-3 ), CPI manual (2020, doi:10.5089/9781484354841.069 ) bilateral price indexes.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/piar-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"piar: Price Index Aggregation — piar-package","text":"Maintainer: Steve Martin marberts@protonmail.com (ORCID) [copyright holder]","code":""},{"path":"https://marberts.github.io/piar/reference/piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Price index objects — piar_index","title":"Price index objects — piar_index","text":"several classes represent price indexes. indexes inherit piar_index virtual class. Period--period indexes can chained time inherit chainable_piar_index. Fixed-base indexes inherit direct_piar_index.","code":""},{"path":"https://marberts.github.io/piar/reference/piar_index.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Price index objects — piar_index","text":"piar_index object list-S3 class following components: index list entry period time gives vector index values level levels. contrib list entry period time, contains list entry level levels named vector gives percent-change contribution price relative. levels character vector giving levels index. time character vector giving time periods index. chainable_piar_index direct_piar_index subclasses structure piar_index class, differ methods used manipulate indexes.","code":""},{"path":"https://marberts.github.io/piar/reference/price_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Price data — price_data","title":"Price data — price_data","text":"Sample price weight data match sample fixed sample type index.","code":""},{"path":"https://marberts.github.io/piar/reference/price_relative.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate period-over-period price relatives — price_relative","title":"Calculate period-over-period price relatives — price_relative","text":"Construct period--period price relatives information prices products time.","code":""},{"path":"https://marberts.github.io/piar/reference/price_relative.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate period-over-period price relatives — price_relative","text":"","code":"price_relative(x, ...)  # Default S3 method price_relative(x, ..., period, product)  # S3 method for class 'data.frame' price_relative(x, formula, ...)"},{"path":"https://marberts.github.io/piar/reference/price_relative.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate period-over-period price relatives — price_relative","text":"x Either numeric vector (something can coerced one) data frame prices. ... arguments passed used methods. period factor, something can coerced one, gives corresponding time period element x. ordering time periods follows levels period agree cut(). product factor, something can coerced one, gives corresponding product identifier element x. formula two-sided formula prices left-hand side, time periods products (order) right-hand side.","code":""},{"path":"https://marberts.github.io/piar/reference/price_relative.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate period-over-period price relatives — price_relative","text":"numeric vector price relatives, product names.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/price_relative.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate period-over-period price relatives — price_relative","text":"","code":"price_relative(   1:6,   period = rep(1:2, each = 3),   product = rep(letters[1:3], 2) ) #>   a   b   c   a   b   c  #> 1.0 1.0 1.0 4.0 2.5 2.0"},{"path":"https://marberts.github.io/piar/reference/split.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Split an index into groups — split.piar_index","title":"Split an index into groups — split.piar_index","text":"Split index groups indexes according factor, along either levels time periods index.","code":""},{"path":"https://marberts.github.io/piar/reference/split.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Split an index into groups — split.piar_index","text":"","code":"# S3 method for class 'piar_index' split(x, f, drop = FALSE, ..., margin = c(\"levels\", \"time\"))  # S3 method for class 'piar_index' split(x, f, drop = FALSE, ..., margin = c(\"levels\", \"time\")) <- value"},{"path":"https://marberts.github.io/piar/reference/split.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Split an index into groups — split.piar_index","text":"x price index, made , e.g., elemental_index(). f factor list factors group elements x. drop levels occur f dropped? default levels kept. ... arguments passed split.default(). margin Either 'levels' split levels x (default), 'time' split time periods x. value list values compatible splitting x, something can coerced one, recycled necessary.","code":""},{"path":"https://marberts.github.io/piar/reference/split.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Split an index into groups — split.piar_index","text":"split() returns list index objects level f. replacement method replaces values corresponding element value.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/split.piar_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Split an index into groups — split.piar_index","text":"","code":"index <- as_index(matrix(1:6, 2))  split(index, 1:2) #> $`1` #> Period-over-period price index for 1 levels over 3 time periods  #>   1 2 3 #> 1 1 3 5 #>  #> $`2` #> Period-over-period price index for 1 levels over 3 time periods  #>   1 2 3 #> 2 2 4 6 #>   split(index, c(1, 1, 2), margin = \"time\") #> $`1` #> Period-over-period price index for 2 levels over 2 time periods  #>   1 2 #> 1 1 3 #> 2 2 4 #>  #> $`2` #> Period-over-period price index for 2 levels over 1 time periods  #>   3 #> 1 5 #> 2 6 #>"},{"path":"https://marberts.github.io/piar/reference/split_classification.html","id":null,"dir":"Reference","previous_headings":"","what":"Split a hierarchical classification — split_classification","title":"Split a hierarchical classification — split_classification","text":"Expand character representation hierarchical classification make price index aggregation structure splitting along delimiter.","code":""},{"path":"https://marberts.github.io/piar/reference/split_classification.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Split a hierarchical classification — split_classification","text":"","code":"split_classification(x, split, ..., sep = \".\")"},{"path":"https://marberts.github.io/piar/reference/split_classification.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Split a hierarchical classification — split_classification","text":"x character vector, something can coerced one, codes/labels specific level classification (e.g., 5-digit COICOP). split regular expression delineate split levels x. See strsplit(). ... Additional argument pass strsplit(). sep character used delineate levels x result. default separates levels \".\".","code":""},{"path":"https://marberts.github.io/piar/reference/split_classification.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Split a hierarchical classification — split_classification","text":"list entry level x giving \"digits\" represent level hierarchy.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/split_classification.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Split a hierarchical classification — split_classification","text":"","code":"#' # A simple classification structure #            1 #      |-----+-----| #      11          12 #  |---+---|       | #  111     112     121  split_classification(c(\"111\", \"112\", \"121\"), \"\") #> [[1]] #> [1] \"1\" \"1\" \"1\" #>  #> [[2]] #> [1] \"1.1\" \"1.1\" \"1.2\" #>  #> [[3]] #> [1] \"1.1.1\" \"1.1.2\" \"1.2.1\" #>   # Useful if there are delimiters in the classification (like COICOP)  split_classification(c(\"01.1.1\", \"01.1.2\", \"01.2.1\"), \".\", fixed = TRUE) #> [[1]] #> [1] \"01\" \"01\" \"01\" #>  #> [[2]] #> [1] \"01.1\" \"01.1\" \"01.2\" #>  #> [[3]] #> [1] \"01.1.1\" \"01.1.2\" \"01.2.1\" #>"},{"path":"https://marberts.github.io/piar/reference/stack.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Stack price indexes — stack.piar_index","title":"Stack price indexes — stack.piar_index","text":"stack() combines two price indexes common levels, stacking index values percent-change contributions one index . unstack() breaks price index list indexes time period. methods can used map-reduce make index multiple aggregation structures (like Paasche index).","code":""},{"path":"https://marberts.github.io/piar/reference/stack.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stack price indexes — stack.piar_index","text":"","code":"# S3 method for class 'chainable_piar_index' stack(x, y, ...)  # S3 method for class 'direct_piar_index' stack(x, y, ...)  # S3 method for class 'chainable_piar_index' unstack(x, ...)  # S3 method for class 'direct_piar_index' unstack(x, ...)"},{"path":"https://marberts.github.io/piar/reference/stack.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stack price indexes — stack.piar_index","text":"x price index, made , e.g., elemental_index(). y price index, something can coerced one. x period--period index y coerced chainable index; otherwise, y coerced direct index. ... currently used.","code":""},{"path":"https://marberts.github.io/piar/reference/stack.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stack price indexes — stack.piar_index","text":"stack() returns combined price index inherits class x. unstack() returns list price indexes class x.","code":""},{"path":"https://marberts.github.io/piar/reference/stack.piar_index.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Stack price indexes — stack.piar_index","text":"may necessary use rebase() prior stacking fixed-based price indexes ensure base period.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/stack.piar_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stack price indexes — stack.piar_index","text":"","code":"index1 <- as_index(matrix(1:6, 2))  index2 <- index1 time(index2) <- 4:6  stack(index1, index2) #> Period-over-period price index for 2 levels over 6 time periods  #>   1 2 3 4 5 6 #> 1 1 3 5 1 3 5 #> 2 2 4 6 2 4 6  # Unstack does the reverse  all.equal(   c(unstack(index1), unstack(index2)),   unstack(stack(index1, index2)) ) #> [1] TRUE"},{"path":"https://marberts.github.io/piar/reference/sub-.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract and replace index values — [.piar_index","title":"Extract and replace index values — [.piar_index","text":"Methods extract replace index values like matrix.","code":""},{"path":"https://marberts.github.io/piar/reference/sub-.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract and replace index values — [.piar_index","text":"","code":"# S3 method for class 'piar_index' x[i, j, ...]  # S3 method for class 'piar_index' x[i, j, ...] <- value"},{"path":"https://marberts.github.io/piar/reference/sub-.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract and replace index values — [.piar_index","text":"x price index, made , e.g., elemental_index(). , j Indices levels time periods price index. See details. ... currently used. value numeric vector price index. See details.","code":""},{"path":"https://marberts.github.io/piar/reference/sub-.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract and replace index values — [.piar_index","text":"price index inherits class x.","code":""},{"path":"https://marberts.github.io/piar/reference/sub-.piar_index.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract and replace index values — [.piar_index","text":"extraction method treats x like matrix index values (named) rows level columns time period x. Unlike matrix, dimensions never dropped subscripting x always returns index object. means subscripting matrix possible, \"submatrix\" can extracted. x atomic vector, subscripting single index like x[1] extracts time periods level. replacement method similarly treat x like matrix. value index object number time periods x[, j] inherits class x, index values percent-change contributions x[, j] replaced corresponding levels value. value index, coerced numeric vector behaves replacing values matrix. Note replacing values index remove corresponding percent-change contributions (). Unlike extraction, possible replace value x using logical matrix two-column matrix indices.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/sub-.piar_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract and replace index values — [.piar_index","text":"","code":"index <- as_index(matrix(1:6, 2))  index[\"1\", ] #> Period-over-period price index for 1 levels over 3 time periods  #>   1 2 3 #> 1 1 3 5  index[, 2] #> Period-over-period price index for 2 levels over 1 time periods  #>   2 #> 1 3 #> 2 4  index[1, ] <- 1 # can be useful for doing specific imputations  index #> Period-over-period price index for 2 levels over 3 time periods  #>   1 2 3 #> 1 1 1 1 #> 2 2 4 6"},{"path":"https://marberts.github.io/piar/reference/time.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the time periods for a price index — time.piar_index","title":"Get the time periods for a price index — time.piar_index","text":"Methods get set time periods price index.","code":""},{"path":"https://marberts.github.io/piar/reference/time.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the time periods for a price index — time.piar_index","text":"","code":"# S3 method for class 'piar_index' time(x, ...)  time(x) <- value  # S3 method for class 'piar_index' time(x) <- value  set_time(x, value)  # S3 method for class 'piar_index' start(x, ...)  # S3 method for class 'piar_index' end(x, ...)  ntime(x)"},{"path":"https://marberts.github.io/piar/reference/time.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the time periods for a price index — time.piar_index","text":"x price index, made , e.g., elemental_index(). ... currently used. value character vector, something can coerced one, giving replacement time periods x.","code":""},{"path":"https://marberts.github.io/piar/reference/time.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the time periods for a price index — time.piar_index","text":"time() returns character vector time periods price index. start() end() return first last time period. ntime() returns number time periods, analogous nlevels(). replacement method returns copy x time periods value. (set_time() alias easier use pipes.)","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/update.piar_aggregation_structure.html","id":null,"dir":"Reference","previous_headings":"","what":"Update an aggregation structure — update.piar_aggregation_structure","title":"Update an aggregation structure — update.piar_aggregation_structure","text":"Price update weights price index aggregation structure.","code":""},{"path":"https://marberts.github.io/piar/reference/update.piar_aggregation_structure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update an aggregation structure — update.piar_aggregation_structure","text":"","code":"# S3 method for class 'piar_aggregation_structure' update(object, index, period = end(index), ..., r = 1)"},{"path":"https://marberts.github.io/piar/reference/update.piar_aggregation_structure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update an aggregation structure — update.piar_aggregation_structure","text":"object price index aggregation structure, made aggregation_structure(). index fixed-base (direct) price index, something can coerced one. Usually aggregate price index made aggregate(). period time period used price update weights. default uses last period index. ... currently used. r Order generalized mean update weights. default 1 arithmetic index.","code":""},{"path":"https://marberts.github.io/piar/reference/update.piar_aggregation_structure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update an aggregation structure — update.piar_aggregation_structure","text":"copy object price-updated weights using index values index.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/update.piar_aggregation_structure.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Update an aggregation structure — update.piar_aggregation_structure","text":"","code":"# A simple aggregation structure #            1 #      |-----+-----| #      11          12 #  |---+---|       | #  111     112     121 #  (1)     (3)     (4)  aggregation_weights <- data.frame(   level1 = c(\"1\", \"1\", \"1\"),   level2 = c(\"11\", \"11\", \"12\"),   ea     = c(\"111\", \"112\", \"121\"),   weight = c(1, 3, 4) )  pias <- as_aggregation_structure(aggregation_weights)  index <- as_index(   matrix(1:9, 3, dimnames = list(c(\"111\", \"112\", \"121\"), NULL)) )  weights(pias, ea_only = FALSE) #> $level1 #> 1  #> 8  #>  #> $level2 #> 11 12  #>  4  4  #>  #> $ea #> 111 112 121  #>   1   3   4  #>   weights(update(pias, index), ea_only = FALSE) #> $level1 #>   1  #> 916  #>  #> $level2 #>  11  12  #> 268 648  #>  #> $ea #> 111 112 121  #>  28 240 648  #>"},{"path":"https://marberts.github.io/piar/reference/weights.piar_aggregation_structure.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the weights for an aggregation structure — weights.piar_aggregation_structure","title":"Get the weights for an aggregation structure — weights.piar_aggregation_structure","text":"Get set weights price index aggregation structure.","code":""},{"path":"https://marberts.github.io/piar/reference/weights.piar_aggregation_structure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the weights for an aggregation structure — weights.piar_aggregation_structure","text":"","code":"# S3 method for class 'piar_aggregation_structure' weights(object, ..., ea_only = TRUE, na.rm = FALSE)  weights(object) <- value  # S3 method for class 'piar_aggregation_structure' weights(object) <- value  set_weights(object, value)"},{"path":"https://marberts.github.io/piar/reference/weights.piar_aggregation_structure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the weights for an aggregation structure — weights.piar_aggregation_structure","text":"object price index aggregation structure, made aggregation_structure(). ... currently used. ea_only weights returned elemental aggregates (default)? Setting FALSE gives weights entire aggregation structure. na.rm missing values removed aggregating weights (.e., ea_only = FALSE)? default, missing values removed. value numeric vector weights elemental aggregates object.","code":""},{"path":"https://marberts.github.io/piar/reference/weights.piar_aggregation_structure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the weights for an aggregation structure — weights.piar_aggregation_structure","text":"weights() returns named vector weights elemental aggregates. replacement method replaces values without changing aggregation structure. (set_weights() alias easier use pipes.) ea_only = FALSE return value list named vector weights level aggregation structure.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/weights.piar_aggregation_structure.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the weights for an aggregation structure — weights.piar_aggregation_structure","text":"","code":"# A simple aggregation structure #            1 #      |-----+-----| #      11          12 #  |---+---|       | #  111     112     121 #  (1)     (3)     (4)  aggregation_weights <- data.frame(   level1 = c(\"1\", \"1\", \"1\"),   level2 = c(\"11\", \"11\", \"12\"),   ea     = c(\"111\", \"112\", \"121\"),   weight = c(1, 3, 4) )  pias <- as_aggregation_structure(aggregation_weights)  # Extract the weights  weights(pias) #> 111 112 121  #>   1   3   4   # ... or update them  weights(pias) <- 1:3 weights(pias) #> 111 112 121  #>   1   2   3"},{"path":"https://marberts.github.io/piar/reference/window.piar_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Index window — window.piar_index","title":"Index window — window.piar_index","text":"Extract replace index values window time periods.","code":""},{"path":"https://marberts.github.io/piar/reference/window.piar_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Index window — window.piar_index","text":"","code":"# S3 method for class 'piar_index' window(x, start = NULL, end = NULL, ...)  # S3 method for class 'piar_index' window(x, start = NULL, end = NULL, ...) <- value"},{"path":"https://marberts.github.io/piar/reference/window.piar_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Index window — window.piar_index","text":"x price index, made , e.g., elemental_index(). start time period start window. default first period x. end time period end window. default last period x. ... currently used. value numeric vector price index.","code":""},{"path":"https://marberts.github.io/piar/reference/window.piar_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Index window — window.piar_index","text":"window() extracts price index window time periods inherits class x. replacement method replaces value.","code":""},{"path":[]},{"path":"https://marberts.github.io/piar/reference/window.piar_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Index window — window.piar_index","text":"","code":"x <- as_index(matrix(1:9, 3))  window(x, \"2\") #> Period-over-period price index for 3 levels over 2 time periods  #>   2 3 #> 1 4 7 #> 2 5 8 #> 3 6 9  window(x, \"2\") <- 1 x #> Period-over-period price index for 3 levels over 3 time periods  #>   1 2 3 #> 1 1 1 1 #> 2 2 1 1 #> 3 3 1 1"},{"path":"https://marberts.github.io/piar/news/index.html","id":"version-082","dir":"Changelog","previous_headings":"","what":"Version 0.8.2","title":"Version 0.8.2","text":"vignette re-written, split small examples cover topics, easier follow.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"improvements-0-8-2","dir":"Changelog","previous_headings":"","what":"Improvements","title":"Version 0.8.2","text":"Added set_levels(), set_time(), set_weights() make easier replace levels, times, weights pipes. contrib(index) <- value can now used replace product contributions. alias set_contrib() easier use pipes. elementary_index() now alias elemental_index() common literature. aggregate() can now use two aggregation structures make superlative index. cut(aggregation_structure) can used cut bottom/top aggregation structure. Works conjunction set_contrib_from_index() calculate index-level contributions. Aggregation structures now preserve names levels work cut(). means .data.frame(aggregation_structure) can produce different column names. .data.frame(index) gets option make list-column percent-change contributions. as_index(data.frame) gets analogous option add contributions table index. .ts(index) can now used turn index regular time series as_index(ts) can turn time series index object. split_classification() gives another way generate aggregation structure character vector.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"bug-fixes-0-8-2","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"Version 0.8.2","text":".data.frame() methods now respect signature generic. allows row names set prevents superfluous warnings trying use data.frame(); e.g., write.csv() (#34). Subscripting index object length 0 vector longer error (#48).","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"version-081","dir":"Changelog","previous_headings":"","what":"Version 0.8.1","title":"Version 0.8.1","text":"CRAN release: 2024-09-12","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"significant-changes-0-8-1","dir":"Changelog","previous_headings":"","what":"Significant changes","title":"Version 0.8.1","text":"elemental_index(), price_relative(), shadow_price(), carry_forward(), carry_backward() now formula interface select relevant, e.g., price variables data frame instead using (). changes signature functions, may break old code argument named. as_aggregation_structure(list) mean(index) now require weights argument named consistent functions. aggregate_piar_index class removed. class well thought , added unnecessary restrictions complications certain functions. cases little impact existing code, mean functions related aggregate indexes removed. deprecated cols argument as_index(data.frame) removed. default window size mean(index) now covers entire index. makes mean() doesn’t assume index monthly, makes easier use mean() new window() method index object.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"improvements-0-8-1","dir":"Changelog","previous_headings":"","what":"Improvements","title":"Version 0.8.1","text":"as_index() gains new argument contrib add contributions pre-computed indexes. Added contrib2DF() extract percent-change contributions data frame. elemental_index(), price_relative(), shadow_price(), carry_forward(), carry_backward() now require arguments time periods, products, elemental aggregates named avoid accidentally changing order arguments (#7, @schneiderpy). Added interact_classifications() get interaction different dimensions hierarchical classification. unchain() gets new argument base better interaction chain() rebase(). aggregate(index) gets new argument include_ea control whether elemental indexes returned aggregating. summary() method indexes changed simply print summary index, rather try summarized index values. aggregate(index) now imputes percent-change contributions missing index values na.rm = TRUE. previously undocumented behavior simply drop . Added window(index) extract window price indexes window(index) <- value replace . base period rebase() can now time period specifying new base period. makes easier rebase pipes; e.g., index |> mean() |> rebase(\"202001\"). elemental_index() gets new argument product better control product names.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"version-070","dir":"Changelog","previous_headings":"","what":"Version 0.7.0","title":"Version 0.7.0","text":"CRAN release: 2024-03-08","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"significant-changes-0-7-0","dir":"Changelog","previous_headings":"","what":"Significant changes","title":"Version 0.7.0","text":"arguments elemental_index(), as_index(), aggregate(index), mean(index), vcov(index), update(aggregation_structure), weights(aggregation_structure) now need named (e.g., na.rm, contrib). helps unify signatures several functions similar arguments different positions. cases arguments near beginning function probably named anyways. several bug fixes version make non-backwards compatible changes.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"improvements-0-7-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"Version 0.7.0","text":"Added examples finding imputed index values vignette. contrib() gets new argument period control time periods get included contributions matrix (documented). contrib() gets new argument pad control contributions matrix padded products differ time. Added .na() anyNA() methods find missing values index object. index[] <- value now works matrix. mean() gets new argument contrib control product contributions aggregated subperiods. Added split() method index objects. levels(aggregation_structure) now returns list levels denote position level hierarchy. Use unlist() get old behavior.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"bug-fixes-0-7-0","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"Version 0.7.0","text":"default ea_only changed TRUE calling weights(aggregation_structure) fix bug replacement method. Replacing index value index[] <- value value also index object now works correctly value recycled. Setting stringsAsFactors = TRUE .data.frame(index) now keeps correct ordering factor levels. mean(index) longer returns aggregate index r differs used make index.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"deprecations-0-7-0","dir":"Changelog","previous_headings":"","what":"Deprecations","title":"Version 0.7.0","text":"cols argument as_index() deprecated removed future version.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"version-060","dir":"Changelog","previous_headings":"","what":"Version 0.6.0","title":"Version 0.6.0","text":"CRAN release: 2023-11-19","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"significant-changes-0-6-0","dir":"Changelog","previous_headings":"","what":"Significant changes","title":"Version 0.6.0","text":"[[ method index objects removed created unexpected problems little gain. .matrix(index)[[1, 1]] explicit flexible way get behavior index[[1, 1]]. aggregation_structure() now orders levels aggregation according order appear data. Previously levels ordered lexicographically, except elemental aggregates. can affect order index values appear aggregate index. number changes way product names handled making index extracting percent-change contributions. Names price relatives now need unique within time period elemental_index(). previous (undocumented) behavior require names unique within time period elemental aggregate. implies two non-backward compatible changes. default product names elemental_index() now include name elemental aggregate conform requirement. Percent-change contributions contrib() simplified row names, now need include index-level names make product names unique. contrib() now always returns matrix. Previously return NULL contributions level index. Rows contributions matrix ordered according product names consistent ordering.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"improvements-0-6-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"Version 0.6.0","text":"Printing index gives textual description addition matrix index values. Printing aggregation structure now gives description tabular representation instead list. now methods set levels time periods index. Methods index objects now faster larger indexes. aggregate() gains new argument contrib controls percent-change contributions elemental indexes aggregated. default maintains current behavior aggregating contributions . class names index objects changed fix name conflict Matrix. means ’s now possible use rsmatrix piar. .matrix() method aggregation structures gains new argument sparse. sparse = TRUE aggregation matrix sparse, rather dense, matrix. option can also used vcov() method aggregate price indexes improve performance large indexes. Added carry_backwards() function carry backwards (opposed carry forwards) imputation.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"bug-fixes-0-6-0","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"Version 0.6.0","text":"Viewing index objects RStudio viewer longer gives error. is_direct_index() now exported. Replacing index values aggregate index longer returns aggregate index, may consistent aggregation. Stacking two indexes now returns aggregate index indexes aggregate indexes. Previously possible stack aggregate index non-aggregate index produce aggregate index consistent aggregation.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"version-050","dir":"Changelog","previous_headings":"","what":"Version 0.5.0","title":"Version 0.5.0","text":"CRAN release: 2023-08-10","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"significant-changes-0-5-0","dir":"Changelog","previous_headings":"","what":"Significant changes","title":"Version 0.5.0","text":"piar now requires R >= 4.0. is_chain_index() removed; use is_chainable_index() instead. first argument elemental_index() now x, rel, consistent rest functions. Similarly, first argument expand_classification() now x, class.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"new-features-0-5-0","dir":"Changelog","previous_headings":"","what":"New features","title":"Version 0.5.0","text":"New functions as_aggregation_structure() is_aggregation_structure() coerce (usually) tabular data aggregation weights aggregation structure, test object aggregation structure. method [[ index objects extract replace single index value. weights aggregation structure can replace weights(pias) <- vector.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"improvements-0-5-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"Version 0.5.0","text":"levels() replacement function now gives error indexes aggregation structures, rather adding levels attribute nothing. width argument expand_classification() now recycles single value. Major overhaul documentation make easier use. object structure used represent index object refined. Subscripting index object now much faster. now possible update aggregation structure non-aggregated index. Functions accept price index aggregation structure argument now attempt coerce arguments index object aggregation structure object instead throwing error.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"bug-fixes-0-5-0","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"Version 0.5.0","text":"Fixed bug creating elemental indexes missing product names produce contributions matrix wrong number products. now possible chain index one level. Subscripting index NAs duplicate indices longer allowed.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"version-040","dir":"Changelog","previous_headings":"","what":"Version 0.4.0","title":"Version 0.4.0","text":"CRAN release: 2022-04-30","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"significant-changes-0-4-0","dir":"Changelog","previous_headings":"","what":"Significant changes","title":"Version 0.4.0","text":"vcov() method aggregate indexes now returns matrix variances instead array covariances, covariances usually misleading unnecessary. cases elemental aggregates sampled independently, case covariances 0. backwards compatible. vcov() method aggregate indexes now much faster. options parallel computing removed, ’re unlikely useful even large indexes. head() tail() methods index objects now return index object instead matrix, documented.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"new-features-0-4-0","dir":"Changelog","previous_headings":"","what":"New features","title":"Version 0.4.0","text":"Added .matrix() method pias objects. makes easy aggregate price index matrix operation; just matrix multiply aggregation matrix elemental indexes. Added .data.frame() method pias objects. useful writing price-updated weights , e.g., write.csv(). Added as_index() method data frames. faster simpler turning data frame index elemental_index(df$value, df$period, df$level).","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"improvements-0-4-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"Version 0.4.0","text":"chain argument found methods elemental_index() as_index() mark index chainable replaced descriptive chainable argument. Partial matching argument names means backwards compatible. price_relative() function longer uses gpindex::back_price(), function deprecated. change remove harmless deprecation warning using older version piar newer version gpindex.","code":""},{"path":"https://marberts.github.io/piar/news/index.html","id":"deprecated-functions-0-4-0","dir":"Changelog","previous_headings":"","what":"Deprecated functions","title":"Version 0.4.0","text":"is_chain_index() function now deprecated, replaced is_chainable_index() function.","code":""}]
