
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "piar"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('piar')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("aggregate.piar_index")
> ### * aggregate.piar_index
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aggregate.piar_index
> ### Title: Aggregate elemental price indexes
> ### Aliases: aggregate.piar_index aggregate.chainable_piar_index
> ###   aggregate.direct_piar_index
> 
> ### ** Examples
> 
> prices <- data.frame(
+   rel = 1:8,
+   period = rep(1:2, each = 4),
+   ea = rep(letters[1:2], 4)
+ )
> 
> # A two-level aggregation structure
> 
> pias <- aggregation_structure(
+   list(c("top", "top", "top"), c("a", "b", "c")), 1:3
+ )
> 
> # Calculate Jevons elemental indexes
> 
> (epr <- with(prices, elemental_index(rel, period, ea)))
Period-over-period price index for 2 levels over 2 time periods 
         1        2
a 1.732051 5.916080
b 2.828427 6.928203
> 
> # Aggregate (note the imputation for elemental index 'c')
> 
> (index <- aggregate(epr, pias, na.rm = TRUE))
Aggregate period-over-period price index for 4 levels over 2 time periods 
           1        2
top 2.462968 6.690949
a   1.732051 5.916080
b   2.828427 6.928203
c   2.462968 6.690949
> 
> # Aggregation can equivalently be done as matrix multiplication
> 
> as.matrix(pias) %*% as.matrix(chain(index[letters[1:3]]))
           1       2
top 2.462968 16.4796
> 
> 
> 
> 
> cleanEx()
> nameEx("aggregation_structure")
> ### * aggregation_structure
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aggregation_structure
> ### Title: Make a price index aggregation structure
> ### Aliases: aggregation_structure piar_aggregation_structure
> 
> ### ** Examples
> 
> # A simple aggregation structure
> #            1
> #      |-----+-----|
> #      11          12
> #  |---+---|       |
> #  111     112     121
> #  (1)     (3)     (4)
> 
> aggregation_weights <- data.frame(
+   level1 = c("1", "1", "1"),
+   level2 = c("11", "11", "12"),
+   ea     = c("111", "112", "121"),
+   weight = c(1, 3, 4)
+ )
> 
> pias <- aggregation_structure(
+   aggregation_weights[1:3],
+   weights = aggregation_weights[[4]]
+ )
> 
> # The aggregation structure can also be made by expanding the
> # elemental aggregates
> 
> all.equal(
+   with(
+     aggregation_weights,
+     aggregation_structure(expand_classification(ea), weight)
+   ),
+   pias
+ )
[1] TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("as.data.frame.piar_index")
> ### * as.data.frame.piar_index
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.data.frame.piar_index
> ### Title: Coerce an index into a tabular form
> ### Aliases: as.data.frame.piar_index as.matrix.piar_index
> 
> ### ** Examples
> 
> prices <- data.frame(
+   rel = 1:8,
+   period = rep(1:2, each = 4),
+   ea = rep(letters[1:2], 4)
+ )
> 
> epr <- with(prices, elemental_index(rel, period, ea))
> 
> as.data.frame(epr)
  period level    value
1      1     a 1.732051
2      1     b 2.828427
3      2     a 5.916080
4      2     b 6.928203
> as.matrix(epr)
         1        2
a 1.732051 5.916080
b 2.828427 6.928203
> 
> 
> 
> 
> cleanEx()
> nameEx("as.matrix.piar_aggregation_structure")
> ### * as.matrix.piar_aggregation_structure
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.matrix.piar_aggregation_structure
> ### Title: Coerce a price index aggregation structure into a tabular form
> ### Aliases: as.matrix.piar_aggregation_structure
> ###   as.data.frame.piar_aggregation_structure
> 
> ### ** Examples
> 
> # A simple aggregation structure
> #            1
> #      |-----+-----|
> #      11          12
> #  |---+---|       |
> #  111     112     121
> #  (1)     (3)     (4)
> 
> aggregation_weights <- data.frame(
+   level1 = c("1", "1", "1"),
+   level2 = c("11", "11", "12"),
+   ea     = c("111", "112", "121"),
+   weight = c(1, 3, 4)
+ )
> 
> pias <- as_aggregation_structure(aggregation_weights)
> 
> as.matrix(pias)
     111   112 121
1  0.125 0.375 0.5
11 0.250 0.750 0.0
12 0.000 0.000 1.0
> 
> all.equal(as.data.frame(pias), aggregation_weights)
[1] TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("as_aggregation_structure")
> ### * as_aggregation_structure
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as_aggregation_structure
> ### Title: Coerce to an aggregation structure
> ### Aliases: as_aggregation_structure as_aggregation_structure.default
> ###   as_aggregation_structure.data.frame as_aggregation_structure.matrix
> ###   as_aggregation_structure.aggregate_piar_index
> 
> ### ** Examples
> 
> # A simple aggregation structure
> #            1
> #      |-----+-----|
> #      11          12
> #  |---+---|       |
> #  111     112     121
> #  (1)     (3)     (4)
> 
> aggregation_weights <- data.frame(
+   level1 = c("1", "1", "1"),
+   level2 = c("11", "11", "12"),
+   ea     = c("111", "112", "121"),
+   weight = c(1, 3, 4)
+ )
> 
> pias <- aggregation_structure(aggregation_weights[1:3],
+   weights = aggregation_weights[[4]]
+ )
> 
> all.equal(
+   pias,
+   as_aggregation_structure(aggregation_weights)
+ )
[1] TRUE
> 
> all.equal(
+   pias,
+   as_aggregation_structure(as.matrix(aggregation_weights))
+ )
[1] TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("as_index")
> ### * as_index
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as_index
> ### Title: Coerce to a price index
> ### Aliases: as_index as_index.default as_index.matrix as_index.data.frame
> ###   as_index.chainable_piar_index as_index.direct_piar_index
> 
> ### ** Examples
> 
> prices <- data.frame(
+   rel = 1:8,
+   period = rep(1:2, each = 4),
+   ea = rep(letters[1:2], 4)
+ )
> 
> # Calculate period-over-period Jevons elemental indexes
> 
> epr <- with(prices, elemental_index(rel, period, ea))
> 
> all.equal(as_index(as.data.frame(epr)), epr)
[1] TRUE
> all.equal(as_index(as.matrix(epr)), epr)
[1] TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("chain")
> ### * chain
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: chain
> ### Title: Chain and rebase a price index
> ### Aliases: chain chain.default chain.chainable_piar_index unchain
> ###   unchain.default unchain.direct_piar_index rebase rebase.default
> ###   rebase.direct_piar_index
> 
> ### ** Examples
> 
> prices <- data.frame(
+   rel = 1:8,
+   period = rep(1:2, each = 4),
+   ea = rep(letters[1:2], 4)
+ )
> 
> # A simple period-over-period elemental index
> 
> (epr <- with(prices, elemental_index(rel, period, ea)))
Period-over-period price index for 2 levels over 2 time periods 
         1        2
a 1.732051 5.916080
b 2.828427 6.928203
> 
> # Make period 0 the fixed base period
> 
> chain(epr)
Fixed-base price index for 2 levels over 2 time periods 
         1        2
a 1.732051 10.24695
b 2.828427 19.59592
> 
> # Chaining and unchaining reverse each other
> 
> all.equal(epr, unchain(chain(epr)))
[1] TRUE
> 
> # Change the base period to period 2 (note the
> # loss of information for period 0)
> 
> epr <- chain(epr)
> rebase(epr, epr[, 2])
Fixed-base price index for 2 levels over 2 time periods 
          1 2
a 0.1690309 1
b 0.1443376 1
> 
> 
> 
> 
> cleanEx()
> nameEx("contrib")
> ### * contrib
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: contrib
> ### Title: Extract percent-change contributions
> ### Aliases: contrib contrib.piar_index
> 
> ### ** Examples
> 
> prices <- data.frame(
+   rel = 1:8,
+   period = rep(1:2, each = 4),
+   ea = rep(letters[1:2], 4)
+ )
> 
> epr <- with(
+   prices,
+   elemental_index(rel, period, ea, contrib = TRUE)
+ )
> 
> pias <- aggregation_structure(
+   list(c("top", "top", "top"), c("a", "b", "c")), 1:3
+ )
> 
> index <- aggregate(epr, pias, na.rm = TRUE)
> 
> # Percent-change contributions for the top-level index
> 
> contrib(index)
            1         2
a.1 0.0000000 0.5081686
a.2 0.2440169 0.6442213
b.1 0.3905243 2.0513858
b.2 0.8284271 2.4871732
> 
> # Calculate EA contributions for the chained index
> 
> library(gpindex)
> 
> arithmetic_contributions(
+   as.matrix(chain(index))[c("a", "b", "c"), 2],
+   weights(pias, ea_only = TRUE)
+ )
       a        b        c 
1.541158 6.198639 7.739798 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:gpindex’

> nameEx("elemental_index")
> ### * elemental_index
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: elemental_index
> ### Title: Make elemental price indexes
> ### Aliases: elemental_index elemental_index.default
> ###   elemental_index.numeric
> 
> ### ** Examples
> 
> library(gpindex)
> 
> prices <- data.frame(
+   rel = 1:8,
+   period = rep(1:2, each = 4),
+   ea = rep(letters[1:2], 4)
+ )
> 
> # Calculate Jevons elemental indexes
> 
> (epr <- with(prices, elemental_index(rel, period, ea)))
Period-over-period price index for 2 levels over 2 time periods 
         1        2
a 1.732051 5.916080
b 2.828427 6.928203
> 
> # Same as using lm() or tapply()
> 
> exp(coef(lm(log(rel) ~ ea:factor(period) - 1, prices)))
eaa:factor(period)1 eab:factor(period)1 eaa:factor(period)2 eab:factor(period)2 
           1.732051            2.828427            5.916080            6.928203 
> 
> with(
+   prices,
+   t(tapply(rel, list(period, ea), geometric_mean, na.rm = TRUE))
+ )
         1        2
a 1.732051 5.916080
b 2.828427 6.928203
> 
> # A general function to calculate weights to turn the geometric
> # mean of the arithmetic and harmonic mean (i.e., Fisher mean)
> # into an arithmetic mean
> 
> fw <- grouped(nested_transmute(0, c(1, -1), 1))
> 
> # Calculate a CSWD index (same as the Jevons in this example)
> # as an arithmetic index by using the appropriate weights
> 
> with(
+   prices,
+   elemental_index(
+     rel, period, ea,
+     fw(rel, group = interaction(period, ea)),
+     r = 1
+   )
+ )
Period-over-period price index for 2 levels over 2 time periods 
         1        2
a 1.732051 5.916080
b 2.828427 6.928203
> 
> 
> 
> 
> cleanEx()

detaching ‘package:gpindex’

> nameEx("expand_classification")
> ### * expand_classification
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expand_classification
> ### Title: Expand a hierarchical classification
> ### Aliases: expand_classification
> 
> ### ** Examples
> 
> # A simple classification structure
> #            1
> #      |-----+-----|
> #      11          12
> #  |---+---|       |
> #  111     112     121
> 
> expand_classification(c("111", "112", "121"))
[[1]]
[1] "1" "1" "1"

[[2]]
[1] "11" "11" "12"

[[3]]
[1] "111" "112" "121"

> 
> # Expanding more complex classifications
> # ... if last 'digit' is either TA or TS
> 
> expand_classification(
+   c("111TA", "112TA", "121TS"),
+   width = c(1, 1, 1, 2)
+ )
[[1]]
[1] "1" "1" "1"

[[2]]
[1] "11" "11" "12"

[[3]]
[1] "111" "112" "121"

[[4]]
[1] "111TA" "112TA" "121TS"

> 
> # ... if first 'digit' is either 11 or 12
> 
> expand_classification(c("111", "112", "121"), width = c(2, 1))
[[1]]
[1] "11" "11" "12"

[[2]]
[1] "111" "112" "121"

> 
> # ...if there are delimiters in the classification (like COICOP)
> 
> expand_classification(c("01.1.1", "01.1.2", "01.2.1"), width = 2)
[[1]]
[1] "01" "01" "01"

[[2]]
[1] "01.1" "01.1" "01.2"

[[3]]
[1] "01.1.1" "01.1.2" "01.2.1"

> 
> 
> 
> 
> cleanEx()
> nameEx("head.piar_index")
> ### * head.piar_index
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: head.piar_index
> ### Title: Return the first/last parts of an index
> ### Aliases: head.piar_index tail.piar_index
> 
> ### ** Examples
> 
> prices <- data.frame(
+   rel = 1:8,
+   period = rep(1:2, each = 4),
+   ea = rep(letters[1:2], 4)
+ )
> 
> # Calculate Jevons elemental indexes
> 
> epr <- with(prices, elemental_index(rel, period, ea))
> 
> # Get the first/last time series
> 
> head(epr, 1)
Period-over-period price index for 1 levels over 2 time periods 
         1       2
a 1.732051 5.91608
> 
> tail(epr, 1)
Period-over-period price index for 1 levels over 2 time periods 
         1        2
b 2.828427 6.928203
> 
> 
> 
> 
> cleanEx()
> nameEx("impute_prices")
> ### * impute_prices
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: impute_prices
> ### Title: Impute missing prices
> ### Aliases: impute_prices shadow_price carry_forward carry_backwards
> 
> ### ** Examples
> 
> prices <- data.frame(
+   price = c(1:7, NA),
+   period = rep(1:2, each = 4),
+   product = 1:4,
+   ea = rep(letters[1:2], 4)
+ )
> 
> with(prices, carry_forward(price, period, product))
[1] 1 2 3 4 5 6 7 4
> 
> with(prices, shadow_price(price, period, product, ea))
[1]  1  2  3  4  5  6  7 12
> 
> 
> 
> 
> cleanEx()
> nameEx("is.na.piar_index")
> ### * is.na.piar_index
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.na.piar_index
> ### Title: Missing values in a price index
> ### Aliases: is.na.piar_index anyNA.piar_index
> 
> ### ** Examples
> 
> index <- as_index(matrix(c(1, 2, 3, NA, 5, NA), 2))
> 
> anyNA(index)
[1] TRUE
> is.na(index)
      1     2     3
1 FALSE FALSE FALSE
2 FALSE  TRUE  TRUE
> 
> # Carry forward imputation
> 
> index[is.na(index)] <- 1
> index
Period-over-period price index for 2 levels over 3 time periods 
  1 2 3
1 1 3 5
2 2 1 1
> 
> 
> 
> 
> cleanEx()
> nameEx("mean.piar_index")
> ### * mean.piar_index
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mean.piar_index
> ### Title: Aggregate a price index over subperiods
> ### Aliases: mean.piar_index
> 
> ### ** Examples
> 
> prices <- data.frame(
+   rel = 1:8,
+   period = rep(1:2, each = 4),
+   ea = rep(letters[1:2], 4)
+ )
> 
> epr <- with(prices, elemental_index(rel, period, ea))
> 
> mean(epr, window = 2)
Period-over-period price index for 2 levels over 1 time periods 
         1
a 3.824065
b 4.878315
> 
> 
> 
> 
> cleanEx()
> nameEx("merge.piar_index")
> ### * merge.piar_index
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: merge.piar_index
> ### Title: Merge price indexes
> ### Aliases: merge.piar_index
> 
> ### ** Examples
> 
> prices <- data.frame(
+   rel = 1:8,
+   period = rep(1:2, each = 4),
+   ea = rep(letters[1:2], 4)
+ )
> 
> prices2 <- data.frame(
+   rel = 1:8,
+   period = rep(1:2, each = 4),
+   ea = rep(letters[3:4], 4)
+ )
> 
> epr <- with(prices, elemental_index(rel, period, ea))
> 
> epr2 <- with(prices2, elemental_index(rel, period, ea))
> 
> merge(epr, epr2)
Period-over-period price index for 4 levels over 2 time periods 
         1        2
a 1.732051 5.916080
b 2.828427 6.928203
c 1.732051 5.916080
d 2.828427 6.928203
> 
> 
> 
> 
> cleanEx()
> nameEx("price_relative")
> ### * price_relative
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: price_relative
> ### Title: Calculate period-over-period price relatives
> ### Aliases: price_relative
> 
> ### ** Examples
> 
> price_relative(1:6, rep(1:2, each = 3), rep(letters[1:3], 2))
  a   b   c   a   b   c 
1.0 1.0 1.0 4.0 2.5 2.0 
> 
> 
> 
> 
> cleanEx()
> nameEx("split.piar_index")
> ### * split.piar_index
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: split.piar_index
> ### Title: Split an index into groups
> ### Aliases: split.piar_index split<-.piar_index
> 
> ### ** Examples
> 
> index <- as_index(matrix(1:6, 2))
> 
> split(index, 1:2)
$`1`
Period-over-period price index for 1 levels over 3 time periods 
  1 2 3
1 1 3 5

$`2`
Period-over-period price index for 1 levels over 3 time periods 
  1 2 3
2 2 4 6

> 
> split(index, c(1, 1, 2), margin = "time")
$`1`
Period-over-period price index for 2 levels over 2 time periods 
  1 2
1 1 3
2 2 4

$`2`
Period-over-period price index for 2 levels over 1 time periods 
  3
1 5
2 6

> 
> 
> 
> 
> cleanEx()
> nameEx("stack.piar_index")
> ### * stack.piar_index
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stack.piar_index
> ### Title: Stack price indexes
> ### Aliases: stack.piar_index unstack.piar_index
> 
> ### ** Examples
> 
> prices <- data.frame(
+   rel = 1:8,
+   period = rep(1:2, each = 4),
+   ea = rep(letters[1:2], 4)
+ )
> 
> prices2 <- data.frame(
+   rel = 1:8,
+   period = rep(3:4, each = 4),
+   ea = rep(letters[1:2], 4)
+ )
> 
> epr <- with(prices, elemental_index(rel, period, ea))
> 
> epr2 <- with(prices2, elemental_index(rel, period, ea))
> 
> stack(epr, epr2)
Period-over-period price index for 2 levels over 4 time periods 
         1        2        3        4
a 1.732051 5.916080 1.732051 5.916080
b 2.828427 6.928203 2.828427 6.928203
> 
> # Unstack does the reverse
> 
> all.equal(
+   c(unstack(epr), unstack(epr2)),
+   unstack(stack(epr, epr2))
+ )
[1] TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("sub-.piar_index")
> ### * sub-.piar_index
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: [.piar_index
> ### Title: Extract and replace index values
> ### Aliases: [.piar_index [<-.piar_index
> 
> ### ** Examples
> 
> prices <- data.frame(
+   rel = 1:8,
+   period = rep(1:2, each = 4),
+   ea = rep(letters[1:2], 4)
+ )
> 
> # Calculate Jevons elemental indexes
> 
> epr <- with(prices, elemental_index(rel, period, ea))
> 
> # Extract the indexes like a matrix
> 
> epr["a", ]
Period-over-period price index for 1 levels over 2 time periods 
         1       2
a 1.732051 5.91608
> 
> epr[, 2]
Period-over-period price index for 2 levels over 1 time periods 
         2
a 5.916080
b 6.928203
> 
> epr[1, ] <- 1 # can be useful for doing specific imputations
> epr
Period-over-period price index for 2 levels over 2 time periods 
         1        2
a 1.000000 1.000000
b 2.828427 6.928203
> 
> 
> 
> 
> cleanEx()
> nameEx("summary.piar_index")
> ### * summary.piar_index
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary.piar_index
> ### Title: Summarize a price index
> ### Aliases: summary.piar_index
> 
> ### ** Examples
> 
> prices <- data.frame(
+   rel = 1:8,
+   period = rep(1:2, each = 4),
+   ea = rep(letters[1:2], 4)
+ )
> 
> epr <- with(prices, elemental_index(rel, period, ea))
> 
> summary(epr)
Indexes
       1               2        
 Min.   :1.732   Min.   :5.916  
 1st Qu.:2.006   1st Qu.:6.169  
 Median :2.280   Median :6.422  
 Mean   :2.280   Mean   :6.422  
 3rd Qu.:2.554   3rd Qu.:6.675  
 Max.   :2.828   Max.   :6.928  
> 
> 
> 
> 
> cleanEx()
> nameEx("update.piar_aggregation_structure")
> ### * update.piar_aggregation_structure
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: update.piar_aggregation_structure
> ### Title: Update a price index aggregation structure
> ### Aliases: update.piar_aggregation_structure
> 
> ### ** Examples
> 
> # A simple aggregation structure
> #            1
> #      |-----+-----|
> #      11          12
> #  |---+---|       |
> #  111     112     121
> #  (1)     (3)     (4)
> 
> aggregation_weights <- data.frame(
+   level1 = c("1", "1", "1"),
+   level2 = c("11", "11", "12"),
+   ea     = c("111", "112", "121"),
+   weight = c(1, 3, 4)
+ )
> 
> pias <- as_aggregation_structure(aggregation_weights)
> 
> index <- as_index(
+   matrix(1:9, 3, dimnames = list(c("111", "112", "121"), NULL))
+ )
> 
> weights(pias, ea_only = FALSE)
[[1]]
1 
8 

[[2]]
11 12 
 4  4 

[[3]]
111 112 121 
  1   3   4 

> 
> weights(update(pias, index), ea_only = FALSE)
[[1]]
  1 
916 

[[2]]
 11  12 
268 648 

[[3]]
111 112 121 
 28 240 648 

> 
> 
> 
> 
> cleanEx()
> nameEx("vcov.aggregate_piar_index")
> ### * vcov.aggregate_piar_index
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: vcov.aggregate_piar_index
> ### Title: Bootstrap variance for a price index with replicate weights
> ### Aliases: vcov.aggregate_piar_index
> 
> ### ** Examples
> 
> prices <- data.frame(
+   rel = 1:8,
+   period = rep(1:2, each = 4),
+   ea = rep(letters[1:2], 4)
+ )
> 
> # A two-level aggregation structure
> 
> pias <- aggregation_structure(
+   list(c("top", "top", "top"), c("a", "b", "c")), 1:3
+ )
> 
> repweights <- matrix(c(0, 2, 3, 1, 2, 4, 2, 3, 3), 3)
> 
> # Calculate Jevons elemental indexes
> 
> epr <- with(prices, elemental_index(rel, period, ea))
> 
> # Aggregate
> 
> index <- aggregate(epr, pias, na.rm = TRUE)
> 
> # Calculate variance
> 
> vcov(index, repweights)
              1           2
top 0.007818832 0.003929299
> 
> 
> 
> 
> cleanEx()
> nameEx("weights.piar_aggregation_structure")
> ### * weights.piar_aggregation_structure
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: weights.piar_aggregation_structure
> ### Title: Get the weights for a price index aggregation structure
> ### Aliases: weights.piar_aggregation_structure weights<-
> ###   weights<-.piar_aggregation_structure
> 
> ### ** Examples
> 
> # A simple aggregation structure
> #            1
> #      |-----+-----|
> #      11          12
> #  |---+---|       |
> #  111     112     121
> #  (1)     (3)     (4)
> 
> aggregation_weights <- data.frame(
+   level1 = c("1", "1", "1"),
+   level2 = c("11", "11", "12"),
+   ea     = c("111", "112", "121"),
+   weight = c(1, 3, 4)
+ )
> 
> pias <- as_aggregation_structure(aggregation_weights)
> 
> # Extract the weights
> 
> weights(pias)
111 112 121 
  1   3   4 
> 
> # ... or update them
> 
> weights(pias) <- 1:3
> weights(pias)
111 112 121 
  1   2   3 
> 
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.119 0.004 0.124 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
