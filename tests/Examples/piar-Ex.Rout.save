
R version 4.3.1 (2023-06-16) -- "Beagle Scouts"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "piar"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('piar')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("aggregate.pindex")
> ### * aggregate.pindex
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aggregate.pindex
> ### Title: Aggregate elemental price indexes
> ### Aliases: aggregate.pindex
> 
> ### ** Examples
> 
> prices <- data.frame(
+   rel = 1:8,
+   period = rep(1:2, each = 4),
+   ea = rep(letters[1:2], 4)
+ )
> 
> # A two-level aggregation structure
> 
> pias <- aggregation_structure(
+   list(c("top", "top", "top"), c("a", "b", "c")), 1:3
+ )
> 
> # Calculate Jevons elemental indexes
> 
> (epr <- with(prices, elemental_index(rel, period, ea)))
Period-over-period price index for 2 levels over 2 time periods 
         1        2
a 1.732051 5.916080
b 2.828427 6.928203
> 
> # Aggregate (note the imputation for elemental index 'c')
> 
> (index <- aggregate(epr, pias, na.rm = TRUE))
Aggregate period-over-period price index for 4 levels over 2 time periods 
           1        2
top 2.462968 6.690949
a   1.732051 5.916080
b   2.828427 6.928203
c   2.462968 6.690949
> 
> # Aggregation can equivalently be done as matrix multiplication
> 
> as.matrix(pias) %*% as.matrix(chain(index[letters[1:3]]))
           1       2
top 2.462968 16.4796
> 
> 
> 
> cleanEx()
> nameEx("aggregation-structure-attributes")
> ### * aggregation-structure-attributes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aggregation-structure-attributes
> ### Title: Methods to get the weights and levels for a price index
> ###   aggregation structure
> ### Aliases: weights.aggregation_structure weights<-
> ###   weights<-.aggregation_structure levels.aggregation_structure
> 
> ### ** Examples
> 
> # A simple aggregation structure
> #            1
> #      |-----+-----|
> #      11          12
> #  |---+---|       |
> #  111     112     121
> #  (1)     (3)     (4)
> 
> aggregation_weights <- data.frame(
+   level1 = c("1",   "1",   "1"),
+   level2 = c("11",  "11",  "12"),
+   ea     = c("111", "112", "121"),
+   weight = c(1,     3,     4)
+ )
> 
> pias <- as_aggregation_structure(aggregation_weights)
> 
> # Extract the weights
> 
> weights(pias)
[[1]]
1 
8 

[[2]]
11 12 
 4  4 

[[3]]
111 112 121 
  1   3   4 

> 
> # ... or update them
> 
> weights(pias) <- 1:3
> weights(pias)
[[1]]
1 
6 

[[2]]
11 12 
 3  3 

[[3]]
111 112 121 
  1   2   3 

> 
> 
> 
> cleanEx()
> nameEx("aggregation_structure")
> ### * aggregation_structure
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aggregation_structure
> ### Title: Make a price index aggregation structure
> ### Aliases: aggregation_structure
> 
> ### ** Examples
> 
> # A simple aggregation structure
> #            1
> #      |-----+-----|
> #      11          12
> #  |---+---|       |
> #  111     112     121
> #  (1)     (3)     (4)
> 
> aggregation_weights <- data.frame(
+   level1 = c("1",   "1",   "1"),
+   level2 = c("11",  "11",  "12"),
+   ea     = c("111", "112", "121"),
+   weight = c(1,     3,     4)
+ )
>                                   
> pias <- aggregation_structure(
+   aggregation_weights[1:3], w = aggregation_weights[[4]]
+ )
> 
> # The aggregation structure can also be made by expanding the
> # elemental aggregates
> 
> all.equal(
+   with(aggregation_weights,
+        aggregation_structure(expand_classification(ea), weight)),
+   pias
+ )
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("as_aggregation_structure")
> ### * as_aggregation_structure
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as_aggregation_structure
> ### Title: Coerce to an aggregation structure
> ### Aliases: as_aggregation_structure as_aggregation_structure.default
> ###   as_aggregation_structure.data.frame as_aggregation_structure.matrix
> ###   as_aggregation_structure.aggregate_pindex
> ###   as_aggregation_structure.aggregation_structure
> ###   is_aggregation_structure
> 
> ### ** Examples
> 
> # A simple aggregation structure
> #            1
> #      |-----+-----|
> #      11          12
> #  |---+---|       |
> #  111     112     121
> #  (1)     (3)     (4)
> 
> aggregation_weights <- data.frame(
+   level1 = c("1",   "1",   "1"),
+   level2 = c("11",  "11",  "12"),
+   ea     = c("111", "112", "121"),
+   weight = c(1,     3,     4)
+ )
>                                   
> pias <- aggregation_structure(aggregation_weights[1:3],
+                               w = aggregation_weights[[4]])
>                               
> all.equal(
+   pias,
+   as_aggregation_structure(aggregation_weights)
+ )
[1] TRUE
> 
> all.equal(
+   pias,
+   as_aggregation_structure(as.matrix(aggregation_weights))
+ )
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("as_index")
> ### * as_index
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as_index
> ### Title: Coerce to a price index
> ### Aliases: as_index as_index.default as_index.matrix as_index.data.frame
> ###   as_index.chainable_pindex as_index.direct_pindex is_index
> ###   is_aggregate_index is_chainable_index is_direct_index
> 
> ### ** Examples
> 
> prices <- data.frame(
+   rel = 1:8,
+   period = rep(1:2, each = 4),
+   ea = rep(letters[1:2], 4)
+ )
> 
> pias <- aggregation_structure(
+   list(c("top", "top", "top"), c("a", "b", "c")), 1:3
+ )
> 
> # Calculate period-over-period Jevons elemental indexes
> 
> epr <- with(prices, elemental_index(rel, period, ea))
> 
> # Aggregate as an arithmetic index
> 
> index <- aggregate(epr, pias, na.rm = TRUE)
> 
> is_index(epr)
[1] TRUE
> is_chainable_index(epr)
[1] TRUE
> is_direct_index(epr)
[1] FALSE
> is_aggregate_index(epr)
[1] FALSE
> 
> is_index(index)
[1] TRUE
> is_chainable_index(index)
[1] TRUE
> is_direct_index(index)
[1] FALSE
> is_aggregate_index(index)
[1] TRUE
> 
> all.equal(as_index(as.data.frame(epr)), epr)
[1] TRUE
> all.equal(as_index(as.matrix(epr)), epr)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("chain")
> ### * chain
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: chain
> ### Title: Chain and rebase a price index
> ### Aliases: chain chain.default chain.aggregate_pindex
> ###   chain.chainable_pindex chain.direct_pindex unchain unchain.default
> ###   unchain.aggregate_pindex unchain.direct_pindex
> ###   unchain.chainable_pindex rebase rebase.default rebase.direct_pindex
> ###   rebase.chainable_pindex
> 
> ### ** Examples
> 
> prices <- data.frame(
+   rel = 1:8,
+   period = rep(1:2, each = 4),
+   ea = rep(letters[1:2], 4)
+ )
> 
> # A simple period-over-period elemental index
> 
> (epr <- with(prices, elemental_index(rel, period, ea)))
Period-over-period price index for 2 levels over 2 time periods 
         1        2
a 1.732051 5.916080
b 2.828427 6.928203
> 
> # Make period 0 the fixed base period
> 
> chain(epr)
Fixed-base price index for 2 levels over 2 time periods 
         1        2
a 1.732051 10.24695
b 2.828427 19.59592
> 
> # Chaining and unchaining reverse each other
> 
> all.equal(epr, unchain(chain(epr)))
[1] TRUE
> 
> # Change the base period to period 2 (note the
> # loss of information for period 0)
> 
> epr <- chain(epr)
> rebase(epr, epr[, 2])
Fixed-base price index for 2 levels over 2 time periods 
          1 2
a 0.1690309 1
b 0.1443376 1
> 
> 
> 
> cleanEx()
> nameEx("coerce-aggregation-structure")
> ### * coerce-aggregation-structure
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: coerce-aggregation-structure
> ### Title: Coerce a price index aggregation structure into a tabular form
> ### Aliases: as.matrix.aggregation_structure
> ###   as.data.frame.aggregation_structure
> 
> ### ** Examples
> 
> # A simple aggregation structure
> #            1
> #      |-----+-----|
> #      11          12
> #  |---+---|       |
> #  111     112     121
> #  (1)     (3)     (4)
> 
> aggregation_weights <- data.frame(
+   level1 = c("1",   "1",   "1"),
+   level2 = c("11",  "11",  "12"),
+   ea     = c("111", "112", "121"),
+   weight = c(1,     3,     4)
+ )
> 
> pias <- as_aggregation_structure(aggregation_weights)
> 
> as.matrix(pias)
     111   112 121
1  0.125 0.375 0.5
11 0.250 0.750 0.0
12 0.000 0.000 1.0
> 
> all.equal(as.data.frame(pias), aggregation_weights)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("coerce-index")
> ### * coerce-index
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: coerce-index
> ### Title: Coerce an index into a tabular form
> ### Aliases: as.matrix.pindex as.data.frame.pindex
> 
> ### ** Examples
> 
> prices <- data.frame(
+   rel = 1:8,
+   period = rep(1:2, each = 4),
+   ea = rep(letters[1:2], 4)
+ )
> 
> epr <- with(prices, elemental_index(rel, period, ea))
> 
> as.data.frame(epr)
  period level    value
1      1     a 1.732051
2      1     b 2.828427
3      2     a 5.916080
4      2     b 6.928203
> as.matrix(epr)
         1        2
a 1.732051 5.916080
b 2.828427 6.928203
> 
> 
> 
> cleanEx()
> nameEx("contrib")
> ### * contrib
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: contrib
> ### Title: Extract percent-change contributions
> ### Aliases: contrib contrib.pindex
> 
> ### ** Examples
> 
> prices <- data.frame(
+   rel = 1:8,
+   period = rep(1:2, each = 4),
+   ea = rep(letters[1:2], 4)
+ )
> 
> epr <- with(
+   prices,
+   elemental_index(rel, period, ea, contrib = TRUE)
+ )
> 
> pias <- aggregation_structure(
+   list(c("top", "top", "top"), c("a", "b", "c")), 1:3
+ )
> 
> index <- aggregate(epr, pias, na.rm = TRUE)
> 
> # Percent-change contributions for the top-level index
> 
> contrib(index)
            1         2
a.1 0.0000000 0.5081686
a.2 0.2440169 0.6442213
b.1 0.3905243 2.0513858
b.2 0.8284271 2.4871732
> 
> # Calculate EA contributions for the chained index
> 
> library(gpindex)
> 
> arithmetic_contributions(
+   as.matrix(chain(index))[c("a", "b", "c"), 2], 
+   weights(pias, ea_only = TRUE)
+ )
       a        b        c 
1.541158 6.198639 7.739798 
> 
> 
> 
> cleanEx()

detaching ‘package:gpindex’

> nameEx("elemental_index")
> ### * elemental_index
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: elemental_index
> ### Title: Make elemental price indexes
> ### Aliases: elemental_index elemental_index.default
> ###   elemental_index.numeric
> 
> ### ** Examples
> 
> library(gpindex)
> 
> prices <- data.frame(
+   rel = 1:8,
+   period = rep(1:2, each = 4),
+   ea = rep(letters[1:2], 4)
+ )
> 
> # Calculate Jevons elemental indexes
> 
> (epr <- with(prices, elemental_index(rel, period, ea)))
Period-over-period price index for 2 levels over 2 time periods 
         1        2
a 1.732051 5.916080
b 2.828427 6.928203
> 
> # Same as using lm() or tapply()
> 
> exp(coef(lm(log(rel) ~ ea:factor(period) - 1, prices)))
eaa:factor(period)1 eab:factor(period)1 eaa:factor(period)2 eab:factor(period)2 
           1.732051            2.828427            5.916080            6.928203 
> 
> with(
+   prices,
+   t(tapply(rel, list(period, ea), geometric_mean, na.rm = TRUE))
+ )
         1        2
a 1.732051 5.916080
b 2.828427 6.928203
> 
> # A general function to calculate weights to turn the geometric
> # mean of the arithmetic and harmonic mean (i.e., Fisher mean)
> # into an arithmetic mean
> 
> fw <- grouped(nested_transmute(0, c(1, -1), 1))
> 
> # Calculate a CSWD index (same as the Jevons in this example) 
> # as an arithmetic index by using the appropriate weights
> 
> with(
+   prices, 
+   elemental_index(
+     rel, period, ea,
+     fw(rel, group = interaction(period, ea)), r = 1
+   )
+ )
Period-over-period price index for 2 levels over 2 time periods 
         1        2
a 1.732051 5.916080
b 2.828427 6.928203
> 
> 
> 
> cleanEx()

detaching ‘package:gpindex’

> nameEx("expand_classification")
> ### * expand_classification
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expand_classification
> ### Title: Expand a hierarchical classification
> ### Aliases: expand_classification
> 
> ### ** Examples
> 
> # A simple classification structure
> #            1
> #      |-----+-----|
> #      11          12
> #  |---+---|       |
> #  111     112     121
> 
> expand_classification(c("111", "112", "121"))
[[1]]
[1] "1" "1" "1"

[[2]]
[1] "11" "11" "12"

[[3]]
[1] "111" "112" "121"

> 
> # Expanding more complex classifications
> # ... if last 'digit' is either TA or TS
> 
> expand_classification(
+   c("111TA", "112TA", "121TS"), width = c(1, 1, 1, 2)
+ )
[[1]]
[1] "1" "1" "1"

[[2]]
[1] "11" "11" "12"

[[3]]
[1] "111" "112" "121"

[[4]]
[1] "111TA" "112TA" "121TS"

> 
> # ... if first 'digit' is either 11 or 12
> 
> expand_classification(c("111", "112", "121"), width = c(2, 1))
[[1]]
[1] "11" "11" "12"

[[2]]
[1] "111" "112" "121"

> 
> # ...if there are delimiters in the classification (like COICOP)
> 
> expand_classification(c("01.1.1", "01.1.2", "01.2.1"), width = 2)
[[1]]
[1] "01" "01" "01"

[[2]]
[1] "01.1" "01.1" "01.2"

[[3]]
[1] "01.1.1" "01.1.2" "01.2.1"

> 
> 
> 
> cleanEx()
> nameEx("extract-index")
> ### * extract-index
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: extract-index
> ### Title: Extract and replace index values
> ### Aliases: [.pindex [.aggregate_pindex [<-.pindex head.pindex tail.pindex
> 
> ### ** Examples
> 
> prices <- data.frame(
+   rel = 1:8,
+   period = rep(1:2, each = 4),
+   ea = rep(letters[1:2], 4)
+ )
> 
> # Calculate Jevons elemental indexes
> 
> epr <- with(prices, elemental_index(rel, period, ea))
> 
> # Extract the indexes like a matrix
> 
> epr["a", ]
Period-over-period price index for 1 levels over 2 time periods 
         1       2
a 1.732051 5.91608
> 
> epr[, 2]
Period-over-period price index for 2 levels over 1 time periods 
         2
a 5.916080
b 6.928203
> 
> epr[1, ] <- 1 # can be useful for doing specific imputations
> epr
Period-over-period price index for 2 levels over 2 time periods 
         1        2
a 1.000000 1.000000
b 2.828427 6.928203
> 
> 
> 
> cleanEx()
> nameEx("impute-prices")
> ### * impute-prices
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: impute-prices
> ### Title: Impute missing prices
> ### Aliases: carry_forward shadow_price
> 
> ### ** Examples
> 
> prices <- data.frame(
+   price = c(1:7, NA),
+   period = rep(1:2, each = 4), 
+   product = 1:4,
+   ea = rep(letters[1:2], 4)
+ )
>                      
> with(prices, carry_forward(price, period, product))
[1] 1 2 3 4 5 6 7 4
> 
> with(prices, shadow_price(price, period, product, ea))
[1]  1  2  3  4  5  6  7 12
> 
> 
> 
> cleanEx()
> nameEx("index-attributes")
> ### * index-attributes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: index-attributes
> ### Title: Get the attributes for a price index
> ### Aliases: levels.pindex time.pindex start.pindex end.pindex
> 
> ### ** Examples
> 
> prices <- data.frame(
+   rel = 1:8,
+   period = rep(1:2, each = 4),
+   ea = rep(letters[1:2], 4)
+ )
> 
> epr <- with(prices, elemental_index(rel, period, ea))
> 
> levels(epr)
[1] "a" "b"
> time(epr)
[1] "1" "2"
> start(epr)
[1] "1"
> end(epr)
[1] "2"
> 
> 
> 
> cleanEx()
> nameEx("mean.pindex")
> ### * mean.pindex
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mean.pindex
> ### Title: Aggregate a price index over subperiods
> ### Aliases: mean.pindex
> 
> ### ** Examples
> 
> prices <- data.frame(
+   rel = 1:8,
+   period = rep(1:2, each = 4),
+   ea = rep(letters[1:2], 4)
+ )
> 
> epr <- with(prices, elemental_index(rel, period, ea))
> 
> mean(epr, window = 2)
Period-over-period price index for 2 levels over 1 time periods 
         1
a 3.824065
b 4.878315
> 
> 
> 
> cleanEx()
> nameEx("merge.pindex")
> ### * merge.pindex
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: merge.pindex
> ### Title: Merge price indexes
> ### Aliases: merge.pindex merge.aggregate_pindex merge.chainable_pindex
> ###   merge.direct_pindex
> 
> ### ** Examples
> 
> prices <- data.frame(
+   rel = 1:8,
+   period = rep(1:2, each = 4),
+   ea = rep(letters[1:2], 4)
+ )
> 
> prices2 <- data.frame(
+   rel = 1:8,
+   period = rep(1:2, each = 4),
+   ea = rep(letters[3:4], 4)
+ )
> 
> epr <- with(prices, elemental_index(rel, period, ea))
> 
> epr2 <- with(prices2, elemental_index(rel, period, ea))
> 
> merge(epr, epr2)
Period-over-period price index for 4 levels over 2 time periods 
         1        2
a 1.732051 5.916080
b 2.828427 6.928203
c 1.732051 5.916080
d 2.828427 6.928203
> 
> 
> 
> cleanEx()
> nameEx("price_relative")
> ### * price_relative
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: price_relative
> ### Title: Calculate period-over-period price relatives
> ### Aliases: price_relative
> 
> ### ** Examples
> 
> price_relative(1:6, rep(1:2, each = 3), rep(letters[1:3], 2))
  a   b   c   a   b   c 
1.0 1.0 1.0 4.0 2.5 2.0 
> 
> 
> 
> cleanEx()
> nameEx("stack.pindex")
> ### * stack.pindex
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stack.pindex
> ### Title: Stack price indexes
> ### Aliases: stack.pindex stack.aggregate_pindex stack.chainable_pindex
> ###   stack.direct_pindex unstack.pindex
> 
> ### ** Examples
> 
> prices <- data.frame(
+   rel = 1:8,
+   period = rep(1:2, each = 4),
+   ea = rep(letters[1:2], 4)
+ )
> 
> prices2 <- data.frame(
+   rel = 1:8,
+   period = rep(3:4, each = 4),
+   ea = rep(letters[1:2], 4)
+ )
> 
> epr <- with(prices, elemental_index(rel, period, ea))
> 
> epr2 <- with(prices2, elemental_index(rel, period, ea))
> 
> stack(epr, epr2)
Period-over-period price index for 2 levels over 4 time periods 
         1        2        3        4
a 1.732051 5.916080 1.732051 5.916080
b 2.828427 6.928203 2.828427 6.928203
> 
> # Unstack does the reverse
> 
> all.equal(c(unstack(epr), unstack(epr2)),
+           unstack(stack(epr, epr2)))
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("summary.pindex")
> ### * summary.pindex
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary.pindex
> ### Title: Summarize a price index
> ### Aliases: summary.pindex
> 
> ### ** Examples
> 
> prices <- data.frame(
+   rel = 1:8,
+   period = rep(1:2, each = 4),
+   ea = rep(letters[1:2], 4)
+ )
> 
> epr <- with(prices, elemental_index(rel, period, ea))
> 
> summary(epr)
Indexes
       1               2        
 Min.   :1.732   Min.   :5.916  
 1st Qu.:2.006   1st Qu.:6.169  
 Median :2.280   Median :6.422  
 Mean   :2.280   Mean   :6.422  
 3rd Qu.:2.554   3rd Qu.:6.675  
 Max.   :2.828   Max.   :6.928  
> 
> 
> 
> cleanEx()
> nameEx("update.aggregation_structure")
> ### * update.aggregation_structure
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: update.aggregation_structure
> ### Title: Update a price index aggregation structure
> ### Aliases: update.aggregation_structure
> 
> ### ** Examples
> 
> # A simple aggregation structure
> #            1
> #      |-----+-----|
> #      11          12
> #  |---+---|       |
> #  111     112     121
> #  (1)     (3)     (4)
> 
> aggregation_weights <- data.frame(
+   level1 = c("1",   "1",   "1"),
+   level2 = c("11",  "11",  "12"),
+   ea     = c("111", "112", "121"),
+   weight = c(1,     3,     4)
+ )
> 
> pias <- as_aggregation_structure(aggregation_weights)
> 
> index <- as_index(
+   matrix(1:9, 3, dimnames = list(c("111", "112", "121"), NULL))
+ )
> 
> weights(pias)
[[1]]
1 
8 

[[2]]
11 12 
 4  4 

[[3]]
111 112 121 
  1   3   4 

> 
> weights(update(pias, index))
[[1]]
  1 
916 

[[2]]
 11  12 
268 648 

[[3]]
111 112 121 
 28 240 648 

> 
> 
> 
> cleanEx()
> nameEx("vcov.aggregate_pindex")
> ### * vcov.aggregate_pindex
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: vcov.aggregate_pindex
> ### Title: Bootstrap variance for a price index with replicate weights
> ### Aliases: vcov.aggregate_pindex
> 
> ### ** Examples
> 
> prices <- data.frame(
+   rel = 1:8,
+   period = rep(1:2, each = 4),
+   ea = rep(letters[1:2], 4)
+ )
> 
> # A two-level aggregation structure
> 
> pias <- aggregation_structure(
+   list(c("top", "top", "top"), c("a", "b", "c")), 1:3
+ )
>                             
> repweights <- matrix(c(0, 2, 3, 1, 2, 4, 2, 3, 3), 3)
> 
> # Calculate Jevons elemental indexes
> 
> epr <- with(prices, elemental_index(rel, period, ea))
> 
> # Aggregate
> 
> index <- aggregate(epr, pias, na.rm = TRUE)
> 
> # Calculate variance
> 
> vcov(index, repweights)
              1           2
top 0.007818832 0.003929299
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.495 0.048 1.023 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
