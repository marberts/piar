
R version 4.1.1 (2021-08-10) -- "Kick Things"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> library(piar)
> library(sps)
> library(gpindex)
> 
> set.seed(4321)
> 
> # Corner case
> vcov(aggregate(elemental_index(numeric(0)), aggregation_structure(1:5)),
+      matrix(runif(10), ncol = 10))
, , 1

   1  2  3  4
1 NA NA NA NA
2 NA NA NA NA
3 NA NA NA NA
4 NA NA NA NA

> 
> # Toy example
> prices <- data.frame(rel = runif(24), 
+                      period = 1:3, 
+                      id = rep(letters[1:8], each = 3))
> 
> weights <- data.frame(l1 = rep(1, 8), 
+                       l2 = rep(c(11, 12), each = 4), 
+                       l3 = rep(c(111, 112, 121, 122), each = 2),
+                       l4 = letters[1:8],
+                       ew = round(1000 * runif(8)),
+                       dw = c(1, runif(6, 1, 10), 1))
> 
> epr <- with(prices, elemental_index(rel, period, id))
> pias <- with(weights, aggregation_structure(weights[1:4], ew * dw))
> index <- aggregate(epr, pias)
> 
> rw <- sps_repweights(weights$dw, B = 25, tau = 2)
> 
> #---- mse = FALSE case ----
> covar <- vcov(index, rw * weights$ew, mse = FALSE)
> 
> # Variance matrix should be symmetric
> apply(covar, 3, function(x) all.equal(x[upper.tri(x)], t(x)[upper.tri(x)]))
   1    2    3 
TRUE TRUE TRUE 
> all.equal(apply(covar, 3, rownames), apply(covar, 3, colnames))
[1] TRUE
> 
> # Variance matrix should have a positive diagonal
> apply(covar, 3, function(x) all(diag(x) >= 0))
   1    2    3 
TRUE TRUE TRUE 
> 
> # Variance for higher levels should agree with manual calculation
> # Period 1
> rws <- apply(rw * weights$ew, 2, scale_weights)
> all.equal(sum(crossprod(epr[, 1], tcrossprod(sweep(rws, 1, rowMeans(rws))) / 25) * t(epr[, 1])),
+           covar[1, 1, 1])
[1] TRUE
> 
> # Period 2
> rws <- apply(rw * weights(update(pias, index, 1), TRUE) / weights$dw, 2, scale_weights)
> all.equal(sum(crossprod(epr[, 2], tcrossprod(sweep(rws, 1, rowMeans(rws))) / 25) * t(epr[, 2])),
+           covar[1, 1, 2])
[1] TRUE
> 
> #---- mse = TRUE case ----
> covar <- vcov(index, rw * weights$ew)
> 
> # Variance matrix should be symmetric
> apply(covar, 3, function(x) all.equal(x[upper.tri(x)], t(x)[upper.tri(x)]))
   1    2    3 
TRUE TRUE TRUE 
> all.equal(apply(covar, 3, rownames), apply(covar, 3, colnames))
[1] TRUE
> 
> # Variance matrix should have a positive diagonal
> apply(covar, 3, function(x) all(diag(x) >= 0))
   1    2    3 
TRUE TRUE TRUE 
> 
> # Variance for higher levels should agree with manual calculation
> # Period 1
> rws <- apply(rw * weights$ew, 2, scale_weights)
> w <- weights(pias, ea_only = TRUE)
> all.equal(sum(crossprod(epr[, 1], tcrossprod(sweep(rws, 1, scale_weights(w))) / 25) * t(epr[, 1])),
+           covar[1, 1, 1])
[1] TRUE
> 
> # Period 2
> rws <- apply(rw * weights(update(pias, index, 1), TRUE) / weights$dw, 2, scale_weights)
> all.equal(sum(crossprod(epr[, 2], tcrossprod(sweep(rws, 1, scale_weights(weights(update(pias, index, 1), TRUE)))) / 25) * t(epr[, 2])),
+           covar[1, 1, 2])
[1] TRUE
> 
> proc.time()
   user  system elapsed 
  0.156   0.008   0.157 
