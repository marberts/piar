
R version 4.1.0 (2021-05-18) -- "Camp Pontanezen"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> #---- Tests for elemental_index(), superlative_elemental_index(), and index methods ----
> library(piar)
> 
> set.seed(1234)
> 
> # Make sure index objects are correctly structured with length-0 inputs
> unclass(elemental_index(integer(0), integer(0), integer(0)))
$index
named list()

$contributions
named list()

$levels
character(0)

$periods
character(0)

$contrib
[1] FALSE

> 
> unclass(superlative_elemental_index(integer(0), integer(0), integer(0), integer(0)))
$index
named list()

$contributions
named list()

$levels
character(0)

$periods
character(0)

$contrib
[1] FALSE

> 
> # Make sure matrix/data.frame methods work with length-0 indexes
> as.matrix(elemental_index(numeric(0)))
<0 x 0 matrix>
> 
> all.equal(as_elemental_index(as.matrix(elemental_index(numeric(0)))),
+           elemental_index(numeric(0)))
[1] TRUE
> 
> as.matrix(elemental_index(numeric(0)), type = "contributions")
<0 x 0 matrix>
>
> all.equal(as.data.frame(elemental_index(numeric(0))),
+           data.frame(period = character(0), level = character(0), value = numeric(0)))
[1] TRUE
> 
> all.equal(as.data.frame(elemental_index(numeric(0)), type = "contributions"),
+           data.frame(period = character(0), level = character(0), value = numeric(0)))
[1] TRUE
>
> # Make sure indexing methods work with length-0 indexes
> epr <- elemental_index(integer(0), integer(0), integer(0))
> epr[]
<0 x 0 matrix>
> epr[0, ]
<0 x 0 matrix>
> epr[, 0]
<0 x 0 matrix>
> epr[-1, ]
<0 x 0 matrix>
> epr[-1]
<0 x 0 matrix>
> epr[0] <- 1
> all.equal(epr, elemental_index(integer(0), integer(0), integer(0)))
[1] TRUE
> 
> # Make indexes with some random data
> dat <- data.frame(rel = replace(rlnorm(1e4), sample(1e4, 10), NA),
+                   period = sample(letters, 1e4, TRUE),
+                   ea = sample(1:5, 1e4, TRUE),
+                   w1 = replace(rlnorm(1e4), sample(1e4, 10), NA),
+                   w2 = runif(1e4))
> 
> epr1 <- with(
+   dat, 
+   elemental_index(rel, period, ea, contrib = TRUE)
+ )
> epr2 <- with(
+   dat, 
+   elemental_index(rel, period, ea, r = -1, contrib = TRUE, na.rm = TRUE)
+ )
> epr3 <- with(
+   dat, 
+   superlative_elemental_index(rel, period, ea, w1, w2, contrib = TRUE, na.rm = TRUE)
+ )
> 
> # Compare with an alternate implementation
> epr11 <- aggregate(rel ~ as.character(ea) + period, dat, 
+                    function(x) exp(weighted.mean(log(x))), 
+                    na.action = na.pass)
> epr22 <- aggregate(rel ~ as.character(ea) + period, dat, 
+                    function(x) 1 / weighted.mean(1 / x),
+                    na.action = na.omit)
> 
> all.equal(as.data.frame(epr1), epr11[c(2, 1, 3)], check.attributes = FALSE)
[1] TRUE
> all.equal(as.data.frame(epr2), epr22[c(2, 1, 3)], check.attributes = FALSE)
[1] TRUE
> 
> # cumprod.index() method should be the same as using apply
> all.equal(cumprod(epr1), t(apply(as.matrix(epr1), 1, cumprod)))
[1] TRUE
> 
> # Contributions should add up
> all.equal(epr1$index, 
+           lapply(epr1$contributions, function(x) sapply(x, sum) + 1))
[1] TRUE
> all.equal(epr2$index, 
+           lapply(epr2$contributions, function(x) sapply(x, sum, na.rm = TRUE) + 1))
[1] TRUE
> all.equal(epr3$index, 
+           lapply(epr3$contributions, function(x) sapply(x, sum, na.rm = TRUE) + 1))
[1] TRUE
> 
> # Compare Fisher index with the manual calculation
> l <- with(dat, elemental_index(rel, period, ea, w1, r = 1, na.rm = TRUE))
> p <- with(dat, elemental_index(rel, period, ea, w2, r = -1, na.rm = TRUE))
> all.equal(sqrt(as.matrix(l) * as.matrix(p)), as.matrix(epr3))
[1] TRUE
> 
> # Should work for other kinds of superlative indexes
> sepr <- with(dat, superlative_elemental_index(rel, period, ea, w2 = w2, na.rm = TRUE, s = 3))
> l <- with(dat, elemental_index(rel, period, ea, r = 1.5, na.rm = TRUE))
> p <- with(dat, elemental_index(rel, period, ea, w2, r = -1.5, na.rm = TRUE))
> all.equal(sqrt(as.matrix(l) * as.matrix(p)), as.matrix(sepr))
[1] TRUE
> 
> # Test merge.index() method
> epr3 <- merge(epr1, epr2)
Warning message:
In merge.index(epr1, epr2) : some levels appear in both 'x' and 'y'
> all.equal(epr3[], rbind(epr1[], epr2[]))
[1] TRUE
> all.equal(epr3$index$a, sapply(epr3$contributions$a, sum, na.rm = TRUE) + 1)
[1] TRUE
> epr3$levels
[1] "1" "2" "3" "4" "5"
> epr3$periods
 [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
[20] "t" "u" "v" "w" "x" "y" "z"
> 
> # Merging length-0 indexes does nothing
> all.equal(merge(elemental_index(integer(0), integer(0), integer(0)), 
+                 elemental_index(integer(0), integer(0), integer(0))),
+           elemental_index(integer(0), integer(0), integer(0)))
[1] TRUE
> 
> # Test stack.index() method
> epr2 <- with(
+   dat, 
+   elemental_index(rel, toupper(period), ea, r = -1, contrib = TRUE, na.rm = TRUE)
+ )
> epr3 <- stack(epr1, epr2)
> all.equal(epr3[], cbind(epr1[], epr2[]))
[1] TRUE
> all.equal(epr3$index$A, sapply(epr3$contributions$A, sum, na.rm = TRUE) + 1)
[1] TRUE
> epr3$levels
[1] "1" "2" "3" "4" "5"
> epr3$periods
 [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
[20] "t" "u" "v" "w" "x" "y" "z" "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L"
[39] "M" "N" "O" "P" "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z"
> 
> # Stacking and unstacking are opposite operations
> all.equal(epr1, Reduce(stack, unstack(epr1)))
[1] TRUE
> 
> # Stacking/unstacking length-0 indexes does nothing
> all.equal(stack(elemental_index(integer(0), integer(0), integer(0)), 
+                 elemental_index(integer(0), integer(0), integer(0))),
+           elemental_index(integer(0), integer(0), integer(0)))
[1] TRUE
> 
> all.equal(unstack(stack(elemental_index(integer(0), integer(0), integer(0)), 
+                         elemental_index(integer(0), integer(0), integer(0)))),
+           elemental_index(integer(0), integer(0), integer(0)))
[1] TRUE
> 
> # Toy example that can be easily verified
> dat <- data.frame(rel = c(1:6, NA, 7, 8),
+                   period = c(1, 1, 1, 1, 1, 2, 2, 2, 2),
+                   ea = c("11", "11", "12", "12", "13", "11", "12", "11", "14"))
> 
> (epr <- with(dat, elemental_index(rel, period, ea, contrib = TRUE)))
          1        2
11 1.414214 6.480741
12 3.464102       NA
13 5.000000      NaN
14      NaN 8.000000
> unclass(epr)
$index
$index$`1`
      11       12       13       14 
1.414214 3.464102 5.000000      NaN 

$index$`2`
      11       12       13       14 
6.480741       NA      NaN 8.000000 


$contributions
$contributions$`1`
$contributions$`1`$`11`
        1         2 
0.0000000 0.4142136 

$contributions$`1`$`12`
       1        2 
1.071797 1.392305 

$contributions$`1`$`13`
1 
4 

$contributions$`1`$`14`
numeric(0)


$contributions$`2`
$contributions$`2`$`11`
       1        2 
2.596297 2.884444 

$contributions$`2`$`12`
 1 
NA 

$contributions$`2`$`13`
numeric(0)

$contributions$`2`$`14`
1 
7 



$levels
[1] "11" "12" "13" "14"

$periods
[1] "1" "2"

$contrib
[1] TRUE

> as.matrix(epr)
          1        2
11 1.414214 6.480741
12 3.464102       NA
13 5.000000      NaN
14      NaN 8.000000
> as.matrix(epr, type = "contributions")
             1        2
11.1 0.0000000 2.596297
11.2 0.4142136 2.884444
12.1 1.0717968       NA
12.2 1.3923048       NA
13.1 4.0000000       NA
14.1        NA 7.000000
> as.data.frame(epr)
  period level    value
1      1    11 1.414214
2      1    12 3.464102
3      1    13 5.000000
4      1    14      NaN
5      2    11 6.480741
6      2    12       NA
7      2    13      NaN
8      2    14 8.000000
> as.data.frame(epr, type = "contributions")
  period level     value
1      1  11.1 0.0000000
2      1  11.2 0.4142136
3      1  12.1 1.0717968
4      1  12.2 1.3923048
5      1  13.1 4.0000000
6      2  11.1 2.5962965
7      2  11.2 2.8844442
8      2  12.1        NA
9      2  14.1 7.0000000
> epr[, 1]
          1
11 1.414214         
12 3.464102
13 5.000000
14      NaN
> epr[1, ]
          1        2 
11 1.414214 6.480741 
> cumprod(epr)
          1        2
11 1.414214 9.165151
12 3.464102       NA
13 5.000000      NaN
14      NaN      NaN
> 
> epr2 <- with(dat, elemental_index(rel, period, ea))
> 
> all.equal(epr[], epr2[])
[1] TRUE
> all.equal(epr2, with(as.data.frame(epr2), elemental_index(value, period, level)))
[1] TRUE
> all.equal(epr$levels, epr2$levels)
[1] TRUE
> all.equal(epr$periods, epr2$periods)
[1] TRUE
> 
> as.matrix(epr2, type = "contributions")
<0 x 0 matrix>
> as.data.frame(epr2, type = "contributions")
[1] period level  value 
<0 rows> (or 0-length row.names)
>
> epr[] <- epr2[]
> all.equal(epr[-5], epr2[-5]) # contrib doesn't match
[1] TRUE
>
> # It shouldn't be possible to make a non-numeric index
> epr <- as_elemental_index(data.frame(a = as.character(1:5), b = 1:5))
> is.numeric(as.matrix(epr))
[1] TRUE
> 
> epr[, "b"] <- as.character(1:5)
> all.equal(epr, as_elemental_index(data.frame(a = as.character(1:5), b = 1:5)))
[1] TRUE
>
> # Nor one without EA names
> as_elemental_index(matrix(1:5, ncol = 5, dimnames = list("a", 1:5)))
  1 2 3 4 5
a 1 2 3 4 5
> 
> proc.time()
   user  system elapsed 
  0.216   0.008   0.218 
